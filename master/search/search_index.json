{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyadi-jif: Python interface for the ADI JESD Interface Framework This project tries to simplify JESD204 configuration exploration and validation for ADI JESD based converters and clock chips with different FPGA vendors. Now supporting the AD9081 MxFE","title":"Home"},{"location":"#pyadi-jif-python-interface-for-the-adi-jesd-interface-framework","text":"This project tries to simplify JESD204 configuration exploration and validation for ADI JESD based converters and clock chips with different FPGA vendors. Now supporting the AD9081 MxFE","title":"pyadi-jif: Python interface for the ADI JESD Interface Framework"},{"location":"cli/","text":"","title":"Cli"},{"location":"clocks/","text":"Clock chips Clock chip models are the central components of the pyadi-jif library and govern the majority of most configuration limitations. Since clock chips are responsible for providing all the necessary clocks for the different components they must understand all component clock requirements. Theory of operation In traditional systems clock chips work as frequency generation systems with multiple PLLs. One PLL, typically called PLL1, is used for synchronization and jitter cleanup. The second PLL, typically called PLL2, is used for frequency generation from a VCXO or PLL1 and will be divided down to provide different output frequencies. The current clock chip models only model PLL2 with a VCXO source. Standalone usage Clock chip models can be used standalone if the required clocks are known. This requires them to be directly provided. Below is an example of a configuration of a clock chip where the three desired output clocks and VCXO are supplied but the internal dividers need to be determined. The input divider n2 is also constrained to 24 as well. Without applying this constraint, the solver could set n2 to values between 12 and 255. # Create instance of AD9523-1 clocking model clk = adijif . ad9523_1 () # Constrain feedback divider n2 to only 24 clk . n2 = 24 # Define clock sources and output clocks vcxo = 125000000 output_clocks = [ 1e9 , 500e6 , 7.8125e6 ] clock_names = [ \"ADC\" , \"FPGA\" , \"SYSREF\" ] clk . set_requested_clocks ( vcxo , output_clocks , clock_names ) # Call solver and collect configuration clk . solve () o = clk . get_config () pprint . pprint ( o ) Sample Output { 'm1' : 3 .0, 'n2' : 24 , 'out_dividers' : [ 1 .0, 2 .0, 128 .0 ] , 'output_clocks' : { 'ADC' : { 'divider' : 1 .0, 'rate' : 1000000000 .0 } , 'FPGA' : { 'divider' : 2 .0, 'rate' : 500000000 .0 } , 'SYSREF' : { 'divider' : 128 .0, 'rate' : 7812500 .0 }} , 'r2' : 1 .0, 'vcxo' : 125000000 .0 } When using clock chip models standalone the method set_requested_clocks must be called before solve . When using the system class this is automatically handled internally based on the components set at initialization.","title":"Clock Chips"},{"location":"clocks/#clock-chips","text":"Clock chip models are the central components of the pyadi-jif library and govern the majority of most configuration limitations. Since clock chips are responsible for providing all the necessary clocks for the different components they must understand all component clock requirements.","title":"Clock chips"},{"location":"clocks/#theory-of-operation","text":"In traditional systems clock chips work as frequency generation systems with multiple PLLs. One PLL, typically called PLL1, is used for synchronization and jitter cleanup. The second PLL, typically called PLL2, is used for frequency generation from a VCXO or PLL1 and will be divided down to provide different output frequencies. The current clock chip models only model PLL2 with a VCXO source.","title":"Theory of operation"},{"location":"clocks/#standalone-usage","text":"Clock chip models can be used standalone if the required clocks are known. This requires them to be directly provided. Below is an example of a configuration of a clock chip where the three desired output clocks and VCXO are supplied but the internal dividers need to be determined. The input divider n2 is also constrained to 24 as well. Without applying this constraint, the solver could set n2 to values between 12 and 255. # Create instance of AD9523-1 clocking model clk = adijif . ad9523_1 () # Constrain feedback divider n2 to only 24 clk . n2 = 24 # Define clock sources and output clocks vcxo = 125000000 output_clocks = [ 1e9 , 500e6 , 7.8125e6 ] clock_names = [ \"ADC\" , \"FPGA\" , \"SYSREF\" ] clk . set_requested_clocks ( vcxo , output_clocks , clock_names ) # Call solver and collect configuration clk . solve () o = clk . get_config () pprint . pprint ( o ) Sample Output { 'm1' : 3 .0, 'n2' : 24 , 'out_dividers' : [ 1 .0, 2 .0, 128 .0 ] , 'output_clocks' : { 'ADC' : { 'divider' : 1 .0, 'rate' : 1000000000 .0 } , 'FPGA' : { 'divider' : 2 .0, 'rate' : 500000000 .0 } , 'SYSREF' : { 'divider' : 128 .0, 'rate' : 7812500 .0 }} , 'r2' : 1 .0, 'vcxo' : 125000000 .0 } When using clock chip models standalone the method set_requested_clocks must be called before solve . When using the system class this is automatically handled internally based on the components set at initialization.","title":"Standalone usage"},{"location":"converters/","text":"Data converters Four types of data converters are supported: ADCs, DACs, transceivers, and ADC/DAC combinations. However, fundamentally from a clocking perspective, it does not matter if a component is a DAC or ADC, and integrated parts like transceivers only have more constraints. It is also possible to connect multiple converters into the same system and jointly present these requirements to clock chips and FPGAs also in the system. Clocking architectures pyadi-jif supports both direct clocking and on-board PLL generation for different converters. Assuming the desired parts support those features. Usually, an external clock generation source, like a PLL, is used to have better phase noise performance. However, routing faster clocks can be challenging above 10 GHz. If a part does support both options (like the AD9081 ) the internal solver does not look across both options. One mode must be selected before the solver is called. If both options are available the internal PLL is used by default. This is set through the property use_direct_clocking . sys = adijif . system ( \"ad9081_rx\" , \"hmc7044\" , \"xilinx\" , vcxo ) # Enable internal PLL sys . converter . use_direct_clocking = False Below is a diagram of the AD9081 internal clock generation PLL. pyadi-jif determines the necessary input clock (CLOCK RECEIVER) and dividers (D,M,N,R,L) for a given data rate specification. Configuring converters Currently converter objects cannot be used outside of the system class when leveraging solvers. Standalone they could be used to evaluate basic JESD parameters and clocks, but you cannot solve for internal dividers standalone. Here is an example below of examining different effective rates based on the JESD configuration: cnv = adijif . ad9680 () cnv . sample_clock = 1e9 cnv . datapath_decimation = 1 cnv . L = 4 cnv . M = 2 cnv . N = 14 cnv . Np = 16 cnv . K = 32 cnv . F = 1 print ( cnv . bit_clock , cnv . multiframe_clock , cnv . device_clock ) 10000000000 .0 31250000 .0 250000000 .0 Nested converters For devices with both ADCs and DACs like transceivers or mixed-signal front-ends, nested models are used that model both ADC and DAC paths together. This is important since they can share a common device clock or reference clock but have different JESD link configurations. AD9081 ) is an example of a part that has such an implementation. AD9081 also has RX or TX only models. When using a nested converter model there are sub-properties adc and dac which handle the individual configurations. When the solver is called the cross configurations are validated first then possible clocking configurations are explored. Below is an example of this type of converter model in use: # Set up system model with nested AD9081 model sys = adijif . system ( \"ad9081\" , \"hmc7044\" , \"xilinx\" , 125000000 ) sys . fpga . setup_by_dev_kit_name ( \"zc706\" ) # Use built in PLLs sys . converter . dac . use_direct_clocking = False sys . converter . adc . use_direct_clocking = False # Set DAC clocking requirements sys . converter . dac . sample_clock = 250e6 sys . converter . dac . datapath_interpolation = 48 sys . converter . dac . L = 4 sys . converter . dac . M = 8 sys . converter . dac . N = 16 sys . converter . dac . Np = 16 sys . converter . dac . K = 32 sys . converter . dac . F = 4 # Set ADC clocking requirements sys . converter . adc . sample_clock = 250e6 sys . converter . adc . datapath_decimation = 16 sys . converter . adc . L = 4 sys . converter . adc . M = 8 sys . converter . adc . N = 16 sys . converter . adc . Np = 16 sys . converter . adc . K = 32 sys . converter . adc . F = 4","title":"Data Converters"},{"location":"converters/#data-converters","text":"Four types of data converters are supported: ADCs, DACs, transceivers, and ADC/DAC combinations. However, fundamentally from a clocking perspective, it does not matter if a component is a DAC or ADC, and integrated parts like transceivers only have more constraints. It is also possible to connect multiple converters into the same system and jointly present these requirements to clock chips and FPGAs also in the system.","title":"Data converters"},{"location":"converters/#clocking-architectures","text":"pyadi-jif supports both direct clocking and on-board PLL generation for different converters. Assuming the desired parts support those features. Usually, an external clock generation source, like a PLL, is used to have better phase noise performance. However, routing faster clocks can be challenging above 10 GHz. If a part does support both options (like the AD9081 ) the internal solver does not look across both options. One mode must be selected before the solver is called. If both options are available the internal PLL is used by default. This is set through the property use_direct_clocking . sys = adijif . system ( \"ad9081_rx\" , \"hmc7044\" , \"xilinx\" , vcxo ) # Enable internal PLL sys . converter . use_direct_clocking = False Below is a diagram of the AD9081 internal clock generation PLL. pyadi-jif determines the necessary input clock (CLOCK RECEIVER) and dividers (D,M,N,R,L) for a given data rate specification.","title":"Clocking architectures"},{"location":"converters/#configuring-converters","text":"Currently converter objects cannot be used outside of the system class when leveraging solvers. Standalone they could be used to evaluate basic JESD parameters and clocks, but you cannot solve for internal dividers standalone. Here is an example below of examining different effective rates based on the JESD configuration: cnv = adijif . ad9680 () cnv . sample_clock = 1e9 cnv . datapath_decimation = 1 cnv . L = 4 cnv . M = 2 cnv . N = 14 cnv . Np = 16 cnv . K = 32 cnv . F = 1 print ( cnv . bit_clock , cnv . multiframe_clock , cnv . device_clock ) 10000000000 .0 31250000 .0 250000000 .0","title":"Configuring converters"},{"location":"converters/#nested-converters","text":"For devices with both ADCs and DACs like transceivers or mixed-signal front-ends, nested models are used that model both ADC and DAC paths together. This is important since they can share a common device clock or reference clock but have different JESD link configurations. AD9081 ) is an example of a part that has such an implementation. AD9081 also has RX or TX only models. When using a nested converter model there are sub-properties adc and dac which handle the individual configurations. When the solver is called the cross configurations are validated first then possible clocking configurations are explored. Below is an example of this type of converter model in use: # Set up system model with nested AD9081 model sys = adijif . system ( \"ad9081\" , \"hmc7044\" , \"xilinx\" , 125000000 ) sys . fpga . setup_by_dev_kit_name ( \"zc706\" ) # Use built in PLLs sys . converter . dac . use_direct_clocking = False sys . converter . adc . use_direct_clocking = False # Set DAC clocking requirements sys . converter . dac . sample_clock = 250e6 sys . converter . dac . datapath_interpolation = 48 sys . converter . dac . L = 4 sys . converter . dac . M = 8 sys . converter . dac . N = 16 sys . converter . dac . Np = 16 sys . converter . dac . K = 32 sys . converter . dac . F = 4 # Set ADC clocking requirements sys . converter . adc . sample_clock = 250e6 sys . converter . adc . datapath_decimation = 16 sys . converter . adc . L = 4 sys . converter . adc . M = 8 sys . converter . adc . N = 16 sys . converter . adc . Np = 16 sys . converter . adc . K = 32 sys . converter . adc . F = 4","title":"Nested converters"},{"location":"defs/","text":"JESD204 Definitions To better understand the system as a whole common definitions must be used between converters, clock chips, and FPGAs used within the system. This page will outline the different clocks and standard configuration parameters for JESD204B and JESD204C. Link parameters E : Number of multiblocks in an extended multiblock F : Octets per frame per link HD : High Density User Data Format K : Frames per multiframe L : Number of lanes M : Number of virtual converters N : Number of non-dummy bits per sample. Usually converter resolution. Np : Number of bits per sample S : Samples per converter per frame Clocks frame_clock : Frames per second $$ \\text{frame clock} = \\frac{\\text{sample clock}}{S} $$. Clock rate at which samples are generated/processed. Has the same rate as the conversion clock, except for interpolating DACs or decimating DACs, where it is slower by the interpolation/decimation factor. sample clock : Data rate in samples per second after decimation stages for ADCs or before interpolation stages for DACs. This is usually referred to as device clock local multi-frame clock (LMFC) : Clock which is equivalent to the link clock counts $$ LMFC = (F \\times K/4) $$ system reference (SYSREF) clock : Clock used for synchronization in subclass 1 and subclass 2 configurations for deterministic latency. It is assumed to be aligned with the sample clock from the clock chip but with periods at integer multiples of the device clock. character clock : Clock with which 8b10b characters and octets are generated. conversion clock : Clock used by a converter device to perform the A2D or D2A conversion. device clock : Master clock supplied to the JESD204B device from which all other clock signals must be derived. line clock : Clock for the high-speed serial interface. local clock : A clock generated inside a JESD204B device. SYSREF clock : Slow clock used for cross-device synchronization purposes. All clocks inside a JESD204B system must have a integer relationship Control characters /R/ K28.0 : Initial lane alignment sequence multi-frame start. /A/ K28.3 : Lane alignment /Q/ K28.4 : Initial lane alignment sequence configuration marker. /K/ K28.5 : Code group synchronization. /F/ K28.7 : Frame synchronization. Abbreviations CGS : Code Group Synchronization ILAS : Initial Lane Alignment Sequence LMFC : Local Multi Frame Clock LEMC : Local Extended Multiblock Clock MCDA : Multiple Converter Device Alignment NMCDA : No Multiple Converter Device Alignment RBD : RX Buffer Delay EMB : Extended Multiblock EoMB : End-of-multiblock sequence (00001) EoEMB : End of extended multiblock identifier bit","title":"Definitions"},{"location":"defs/#jesd204-definitions","text":"To better understand the system as a whole common definitions must be used between converters, clock chips, and FPGAs used within the system. This page will outline the different clocks and standard configuration parameters for JESD204B and JESD204C.","title":"JESD204 Definitions"},{"location":"defs/#link-parameters","text":"E : Number of multiblocks in an extended multiblock F : Octets per frame per link HD : High Density User Data Format K : Frames per multiframe L : Number of lanes M : Number of virtual converters N : Number of non-dummy bits per sample. Usually converter resolution. Np : Number of bits per sample S : Samples per converter per frame","title":"Link parameters"},{"location":"defs/#clocks","text":"frame_clock : Frames per second $$ \\text{frame clock} = \\frac{\\text{sample clock}}{S} $$. Clock rate at which samples are generated/processed. Has the same rate as the conversion clock, except for interpolating DACs or decimating DACs, where it is slower by the interpolation/decimation factor. sample clock : Data rate in samples per second after decimation stages for ADCs or before interpolation stages for DACs. This is usually referred to as device clock local multi-frame clock (LMFC) : Clock which is equivalent to the link clock counts $$ LMFC = (F \\times K/4) $$ system reference (SYSREF) clock : Clock used for synchronization in subclass 1 and subclass 2 configurations for deterministic latency. It is assumed to be aligned with the sample clock from the clock chip but with periods at integer multiples of the device clock. character clock : Clock with which 8b10b characters and octets are generated. conversion clock : Clock used by a converter device to perform the A2D or D2A conversion. device clock : Master clock supplied to the JESD204B device from which all other clock signals must be derived. line clock : Clock for the high-speed serial interface. local clock : A clock generated inside a JESD204B device. SYSREF clock : Slow clock used for cross-device synchronization purposes. All clocks inside a JESD204B system must have a integer relationship","title":"Clocks"},{"location":"defs/#control-characters","text":"/R/ K28.0 : Initial lane alignment sequence multi-frame start. /A/ K28.3 : Lane alignment /Q/ K28.4 : Initial lane alignment sequence configuration marker. /K/ K28.5 : Code group synchronization. /F/ K28.7 : Frame synchronization.","title":"Control characters"},{"location":"defs/#abbreviations","text":"CGS : Code Group Synchronization ILAS : Initial Lane Alignment Sequence LMFC : Local Multi Frame Clock LEMC : Local Extended Multiblock Clock MCDA : Multiple Converter Device Alignment NMCDA : No Multiple Converter Device Alignment RBD : RX Buffer Delay EMB : Extended Multiblock EoMB : End-of-multiblock sequence (00001) EoEMB : End of extended multiblock identifier bit","title":"Abbreviations"},{"location":"developers/","text":"Developer documentation pyadi-jif uses a modern python flow based around Poetry and Nox . This is done to keep development isolated from the rest of developer's system Set up python Python 3.8 is required for development as it is considered the target release. Nox tests other variants when available as well but 3.8 is required. If you do not have 3.8 installed the recommended option is to use pyenv Install pyenv pyenv is a handy tool for installing different and isolated versions of python on your system. Since distributions can ship with rather random versions of python, pyenv can help install exactly the versions required. The quick way to install pyenv is with their bash script: curl https://pyenv.run | bash Add to your path and shell startup script (like .bashrc or .zshrc) export PATH = \"/home/<username>/.pyenv/bin: $PATH eval \" $( pyenv init - ) \" eval \" $( pyenv virtualenv-init - ) \" Install the desired python version pyenv install 3 .8.7 Set up poetry Poetry manages the virtual environment for the project which includes the dependencies. Poetry can be installed manually or the Makefile can be leveraged as at this point a valid version of Python is installed. To install poetry and set up the environment run: make dev If you already have poetry installed it is not reinstalled. Using make Make is muscle memory for most developers so it is a driver of pyadi-jif development if you want to use it. Running make help provides the possible operations. Note that the Makefile wraps most commands in poetry calls so you do not necessarily need to enable the poetry shell. make help make [ 1 ] : Entering directory '/tmp/pyadi-jif' clean remove all build, test, coverage and Python artifacts clean-build remove build artifacts clean-pyc remove Python file artifacts clean-test remove test and coverage artifacts test run tests testp run tests parallel coverage run test with coverage enabled lint format and lint code docs build documentation install install module dev setup development environment When committing code Before committing code and creating pull-requests make sure all tests are passing. CI verifies commits but any assigned reviewers ignore any PRs that have not passed CI checks. Please run the linters: make lint and the tests: make test","title":"Developers"},{"location":"developers/#developer-documentation","text":"pyadi-jif uses a modern python flow based around Poetry and Nox . This is done to keep development isolated from the rest of developer's system","title":"Developer documentation"},{"location":"developers/#set-up-python","text":"Python 3.8 is required for development as it is considered the target release. Nox tests other variants when available as well but 3.8 is required. If you do not have 3.8 installed the recommended option is to use pyenv","title":"Set up python"},{"location":"developers/#install-pyenv","text":"pyenv is a handy tool for installing different and isolated versions of python on your system. Since distributions can ship with rather random versions of python, pyenv can help install exactly the versions required. The quick way to install pyenv is with their bash script: curl https://pyenv.run | bash Add to your path and shell startup script (like .bashrc or .zshrc) export PATH = \"/home/<username>/.pyenv/bin: $PATH eval \" $( pyenv init - ) \" eval \" $( pyenv virtualenv-init - ) \" Install the desired python version pyenv install 3 .8.7","title":"Install pyenv"},{"location":"developers/#set-up-poetry","text":"Poetry manages the virtual environment for the project which includes the dependencies. Poetry can be installed manually or the Makefile can be leveraged as at this point a valid version of Python is installed. To install poetry and set up the environment run: make dev If you already have poetry installed it is not reinstalled.","title":"Set up poetry"},{"location":"developers/#using-make","text":"Make is muscle memory for most developers so it is a driver of pyadi-jif development if you want to use it. Running make help provides the possible operations. Note that the Makefile wraps most commands in poetry calls so you do not necessarily need to enable the poetry shell. make help make [ 1 ] : Entering directory '/tmp/pyadi-jif' clean remove all build, test, coverage and Python artifacts clean-build remove build artifacts clean-pyc remove Python file artifacts clean-test remove test and coverage artifacts test run tests testp run tests parallel coverage run test with coverage enabled lint format and lint code docs build documentation install install module dev setup development environment","title":"Using make"},{"location":"developers/#when-committing-code","text":"Before committing code and creating pull-requests make sure all tests are passing. CI verifies commits but any assigned reviewers ignore any PRs that have not passed CI checks. Please run the linters: make lint and the tests: make test","title":"When committing code"},{"location":"flow/","text":"Usage Flows pyadi-jif at its core is a modeling tool for configuration and can be used to determine configurations at the component and system levels. Component level : Certain components can be isolated or used standalone like clock chip models. This is useful when compartmentalizing a problem or checking an existing configuration. System level : When all or most of the top-level constraints need to be modeled together leveraging the system classes provides the most consistent connection between the constraints across the components that must work together. Component Level When working at the component level each component's settings can be constrained or left unconstrained. Since each class's implementation will model possible settings as well as their limitations, any user-applied constraints are checked for validity. By default, all settings are left unconstrained. Constraints for divider settings and clocks can be scalars, lists, or even ranges. This applies to dividers and clock rates. Below is an example of a configuration of a clock chip where the three desired output clocks and VCXO are supplied but the internal dividers need to be determined. The input divider n2 is also constrained to 24 as well. Without applying this constraint, the solver could set n2 to values between 12 and 255. AD9523-1 Component Example # Create instance of AD9523-1 clocking model clk = adijif . ad9523_1 () # Constrain feedback divider n2 to only 24 clk . n2 = 24 # Define clock sources and output clocks vcxo = 125000000 output_clocks = [ 1e9 , 500e6 , 7.8125e6 ] clock_names = [ \"ADC\" , \"FPGA\" , \"SYSREF\" ] clk . set_requested_clocks ( vcxo , output_clocks , clock_names ) # Call solver and collect configuration clk . solve () o = clk . get_config () pprint . pprint ( o ) Sample Output { 'm1' : 3 .0, 'n2' : 24 , 'out_dividers' : [ 1 .0, 2 .0, 128 .0 ] , 'output_clocks' : { 'ADC' : { 'divider' : 1 .0, 'rate' : 1000000000 .0 } , 'FPGA' : { 'divider' : 2 .0, 'rate' : 500000000 .0 } , 'SYSREF' : { 'divider' : 128 .0, 'rate' : 7812500 .0 }} , 'r2' : 1 .0, 'vcxo' : 125000000 .0 } After the solver runs successfully, all the internal dividers and clocks are provided in a single dictionary. Alternatively a range for the VCXO could be provided using the types classes as: vcxo = adijif . types . range ( 100000000 , 251000000 , 1000000 , \"vcxo\" ) In this case, any VCXO could be used in the range 100 MHz to 250 MHz in 1 MHz steps. System Level When component constraints need to be mixed together the system class is used and is designed to support an FPGA, clock chip, and multiple data converters. Below is an example of the system class usage for a board similar to AD-FMCDAQ2-EBZ , but just looking at the ADC side alone. AD-FMCDAQ2-EBZ ADC Side System Example vcxo = 125000000 # Create instance of system class with desired parts sys = adijif . system ( \"ad9680\" , \"ad9523_1\" , \"xilinx\" , vcxo ) # Set Converter clocking requirements sys . converter . sample_clock = 1e9 sys . converter . datapath_decimation = 1 sys . converter . L = 4 sys . converter . M = 2 sys . converter . N = 14 sys . converter . Np = 16 sys . converter . K = 32 sys . converter . F = 1 # Set FPGA clocking requirements sys . fpga . setup_by_dev_kit_name ( \"zc706\" ) # Call solver and collect configuration config = sys . solve () pprint . pprint ( config ) Sample Output { 'clock' : { 'm1' : 3 .0, 'n2' : 24 .0, 'out_dividers' : [ 1 .0, 32 .0, 10 .0 ] , 'output_clocks' : { 'ad9680_adc_clock' : { 'divider' : 1 .0, 'rate' : 1000000000 .0 } , 'ad9680_sysref' : { 'divider' : 32 .0, 'rate' : 31250000 .0 } , 'fpga_ref' : { 'divider' : 10 .0, 'rate' : 100000000 .0 }} , 'r2' : 1 .0, 'vcxo' : 125000000 } , 'converter' : [ 'AD9680' ] , 'fpga' : { 'band' : 1 .0, 'd' : 1 .0, 'm' : 1 .0, 'n' : 100 .0, 'qty4_full_rate_enabled' : 0 .0, 'type' : 'qpll' , 'vco' : 10000000000 .0 }} The output in this case contains information for all three components. Listing divider settings, certain enabled modes, and clock rates. The ADC is directly clocked so it requires no configuration. Alternatively, the output dividers d could be limited to power of two: sys . clock . d = [ 2 ** n for n in range ( 0 , 7 )] config = sys . solve () pprint . pprint ( config [ 'clock' ]) Clock output { 'm1' : 3 .0, 'n2' : 24 .0, 'out_dividers' : [ 1 .0, 32 .0, 8 .0 ] , 'output_clocks' : { 'ad9680_adc_clock' : { 'divider' : 1 .0, 'rate' : 1000000000 .0 } , 'ad9680_sysref' : { 'divider' : 32 .0, 'rate' : 31250000 .0 } , 'fpga_ref' : { 'divider' : 8 .0, 'rate' : 125000000 .0 }} , 'r2' : 1 .0, 'vcxo' : 125000000 }","title":"Usage Flow"},{"location":"flow/#usage-flows","text":"pyadi-jif at its core is a modeling tool for configuration and can be used to determine configurations at the component and system levels. Component level : Certain components can be isolated or used standalone like clock chip models. This is useful when compartmentalizing a problem or checking an existing configuration. System level : When all or most of the top-level constraints need to be modeled together leveraging the system classes provides the most consistent connection between the constraints across the components that must work together.","title":"Usage Flows"},{"location":"flow/#component-level","text":"When working at the component level each component's settings can be constrained or left unconstrained. Since each class's implementation will model possible settings as well as their limitations, any user-applied constraints are checked for validity. By default, all settings are left unconstrained. Constraints for divider settings and clocks can be scalars, lists, or even ranges. This applies to dividers and clock rates. Below is an example of a configuration of a clock chip where the three desired output clocks and VCXO are supplied but the internal dividers need to be determined. The input divider n2 is also constrained to 24 as well. Without applying this constraint, the solver could set n2 to values between 12 and 255.","title":"Component Level"},{"location":"flow/#ad9523-1-component-example","text":"# Create instance of AD9523-1 clocking model clk = adijif . ad9523_1 () # Constrain feedback divider n2 to only 24 clk . n2 = 24 # Define clock sources and output clocks vcxo = 125000000 output_clocks = [ 1e9 , 500e6 , 7.8125e6 ] clock_names = [ \"ADC\" , \"FPGA\" , \"SYSREF\" ] clk . set_requested_clocks ( vcxo , output_clocks , clock_names ) # Call solver and collect configuration clk . solve () o = clk . get_config () pprint . pprint ( o ) Sample Output { 'm1' : 3 .0, 'n2' : 24 , 'out_dividers' : [ 1 .0, 2 .0, 128 .0 ] , 'output_clocks' : { 'ADC' : { 'divider' : 1 .0, 'rate' : 1000000000 .0 } , 'FPGA' : { 'divider' : 2 .0, 'rate' : 500000000 .0 } , 'SYSREF' : { 'divider' : 128 .0, 'rate' : 7812500 .0 }} , 'r2' : 1 .0, 'vcxo' : 125000000 .0 } After the solver runs successfully, all the internal dividers and clocks are provided in a single dictionary. Alternatively a range for the VCXO could be provided using the types classes as: vcxo = adijif . types . range ( 100000000 , 251000000 , 1000000 , \"vcxo\" ) In this case, any VCXO could be used in the range 100 MHz to 250 MHz in 1 MHz steps.","title":"AD9523-1 Component Example"},{"location":"flow/#system-level","text":"When component constraints need to be mixed together the system class is used and is designed to support an FPGA, clock chip, and multiple data converters. Below is an example of the system class usage for a board similar to AD-FMCDAQ2-EBZ , but just looking at the ADC side alone.","title":"System Level"},{"location":"flow/#ad-fmcdaq2-ebz-adc-side-system-example","text":"vcxo = 125000000 # Create instance of system class with desired parts sys = adijif . system ( \"ad9680\" , \"ad9523_1\" , \"xilinx\" , vcxo ) # Set Converter clocking requirements sys . converter . sample_clock = 1e9 sys . converter . datapath_decimation = 1 sys . converter . L = 4 sys . converter . M = 2 sys . converter . N = 14 sys . converter . Np = 16 sys . converter . K = 32 sys . converter . F = 1 # Set FPGA clocking requirements sys . fpga . setup_by_dev_kit_name ( \"zc706\" ) # Call solver and collect configuration config = sys . solve () pprint . pprint ( config ) Sample Output { 'clock' : { 'm1' : 3 .0, 'n2' : 24 .0, 'out_dividers' : [ 1 .0, 32 .0, 10 .0 ] , 'output_clocks' : { 'ad9680_adc_clock' : { 'divider' : 1 .0, 'rate' : 1000000000 .0 } , 'ad9680_sysref' : { 'divider' : 32 .0, 'rate' : 31250000 .0 } , 'fpga_ref' : { 'divider' : 10 .0, 'rate' : 100000000 .0 }} , 'r2' : 1 .0, 'vcxo' : 125000000 } , 'converter' : [ 'AD9680' ] , 'fpga' : { 'band' : 1 .0, 'd' : 1 .0, 'm' : 1 .0, 'n' : 100 .0, 'qty4_full_rate_enabled' : 0 .0, 'type' : 'qpll' , 'vco' : 10000000000 .0 }} The output in this case contains information for all three components. Listing divider settings, certain enabled modes, and clock rates. The ADC is directly clocked so it requires no configuration. Alternatively, the output dividers d could be limited to power of two: sys . clock . d = [ 2 ** n for n in range ( 0 , 7 )] config = sys . solve () pprint . pprint ( config [ 'clock' ]) Clock output { 'm1' : 3 .0, 'n2' : 24 .0, 'out_dividers' : [ 1 .0, 32 .0, 8 .0 ] , 'output_clocks' : { 'ad9680_adc_clock' : { 'divider' : 1 .0, 'rate' : 1000000000 .0 } , 'ad9680_sysref' : { 'divider' : 32 .0, 'rate' : 31250000 .0 } , 'fpga_ref' : { 'divider' : 8 .0, 'rate' : 125000000 .0 }} , 'r2' : 1 .0, 'vcxo' : 125000000 }","title":"AD-FMCDAQ2-EBZ ADC Side System Example"},{"location":"fpga_internal/","text":"FPGA Clocking JESD204 is a protocol that is made up of layers to manage the different aspects of the data link between the converters and FPGA. On the converter side this is handled for you by the ASIC designer but the FPGA side requires a lot more work. This is heavily managed by the ADI JESD204 Framework , but it still needs to be specifically configured and laid out correctly for a specific use case or set of use cases. From the diagram above, we can see in the FPGA there are explicit cores within the FPGA to manager the PHY Layer, Link Layer, and Transport Layer aspects for the JESD204 protocol. These will have specific drivers and HDL IP that need to configured for a configuration. By configuration, it primarily refers to the clocking and JESD modes. In the diagram there are both TX and RX data paths but generically they can considered identical, data will just flow in a specific direction in each case. Clocking Layout Focusing on an individual chain, we can consider the diagram below where the individual clocks are detailed. These clocks can be provided externally or internally but must meet some basic requirements. Traditionally they will come from an external clocking devices, which can drastically save power and resources, and adijif takes this approach. The clocks will have the following constraints: ref clock : This clock's primary purpose is to drive the SERDES which will typically happen by feeding the CPLL or QPLL inside the transceiver primitives of the FPGA. Therefore, it's frequency is determined base on the PLL dividers and range limitations. The constraint here is that the ref clock times the PLL multiply/divide ratio must meet the lane rate of the desired link, which is fixed. link clock : This clock must be lane rate /40 (204B) or lane rate /60 (204C). It most cases the ref clock and the link clock will be the same value, or the ref clock is just selected to be equal to the link clock from the start for simplicity. However, this is not always possible. Therefore, the FPGA PLL clock dividers and muxes can be used to correctly meet this requirement from an upstream clock. These dividers and muxed are detailed in the diagram below, where RXOUTCLK is itself used to drive the link layer. device clock : This clock is unique since it must be derived from the same source as SYSREF , since it is used to sample SYSREF and be a multiple of the sample clock. The device clock determines the output rate of the link layer, and when this rate is different than the link clock it will enable the Gearbox inside the link layer HDL core. This will occur usually when N' is not 8 or 16, or when F != 1, 2, or 4. It is also important to select this clock with respect to desired data rate constraints for downstream logic since this is the rate application logic must consume data at. This clock will be at the sample clock / N where N is some integer. However, this rate should not exceed the Fmax of the FPGA logic. SYSREF : This clock is simple the system reference and will be lane rate / M where M is a power of 2 and should be large. Technically, only the device clock is needed by the FPGA and all other clocks (except for SYSREF ) could be derived from it. This assumes the necessary ratios are possible by the internal dividers. However, in most cases SYSREF is used for deterministic latency. From Xilinx UG576 API Controls To manage the generation of these clocks, APIs are provided in the FPGA specific classes ( adijif.fpga.xilinx ). These are: out_clk_select : Control {RX/TX}CLKSEL mux. Options are XCVR_REFCLK , XCVR_REFCLK_DIV2 , XCVR_PROGDIV_CLK force_cpll : Force use of CPLL force_qpll : Force use of QPLL force_qpll1 : Force use of QPLL1 (only available on GTH and GTY transceivers) requires_separate_link_layer_out_clock : Enable generation of separate device clock . This rate is automatically determined base on Fmax of FPGA By default adijif will try to determine valid PLL settings and necessary muxing settings to meet the link clock and ref clock requirements. If a separate device clock is needed enable requires_separate_link_layer_out_clock . Below is an example of an explicit request for a separate device clock and since out_clk_select is set to XCVR_REFCLK it will force the ref clock to be equal to the link clock . import adijif vcxo = 125e6 sys = adijif . system ( \"ad9680\" , \"ad9523_1\" , \"xilinx\" , vcxo ) sys . Debug_Solver = False sys . fpga . setup_by_dev_kit_name ( \"zcu102\" ) sys . fpga . force_cpll = True sys . fpga . out_clk_select = \"XCVR_REFCLK\" # force reference to be core clock rate sys . fpga . requires_separate_link_layer_out_clock = True # Get extra clock sys . converter . use_direct_clocking = True sys . converter . set_quick_configuration_mode ( 0x88 ) assert sys . converter . S == 1 # Limit upper dividers to powers of 2 sys . clock . d = [ int ( 2 ** i ) for i in range ( 8 )] # Current configuration sys . converter . sample_clock = 1e9 / 2 cfg = sys . solve () In the output the lines specific to the link layer and mux configuration have been highlighted: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 { 'clock' : { 'm1' : 3 , 'n2' : 24 , 'out_dividers' : [ 2 , 64 , 8 , 4 ] , 'output_clocks' : { 'AD9680_fpga_link_out_clk' : { 'divider' : 4 , 'rate' : 250000000 .0 } , 'ADC_CLK' : { 'divider' : 2 , 'rate' : 500000000 .0 } , 'ADC_CLK_FMC' : { 'divider' : 8 , 'rate' : 125000000 .0 } , 'ADC_SYSREF' : { 'divider' : 64 , 'rate' : 15625000 .0 } , 'CLKD_ADC_SYSREF' : { 'divider' : 64 , 'rate' : 15625000 .0 }} , 'part' : 'AD9523-1' , 'r2' : 1 , 'vco' : 1000000000 .0, 'vcxo' : 125000000 .0 } , 'converter' : [] , 'converter_AD9680' : { 'clocking_option' : 'direct' , 'decimation' : 1 } , 'fpga_AD9680' : { 'd' : 1 , 'm' : 1 , 'n1' : 4 , 'n2' : 5 , 'out_clk_select' : 'XCVR_REF_CLK' , 'sys_clk_select' : 'XCVR_QPLL1' , 'transport_samples_per_clock' : 2 , 'type' : 'cpll' , 'vco' : 2500000000 .0 } , 'jesd_AD9680' : { 'CS' : 0 , 'F' : 1 , 'HD' : 1 , 'K' : 32 , 'L' : 4 , 'M' : 2 , 'Np' : 16 , 'S' : 1 , 'bit_clock' : 5000000000 .0, 'converter_clock' : 500000000 .0, 'jesd_class' : 'jesd204b' , 'jesd_mode' : '136' , 'multiframe_clock' : 15625000 .0, 'sample_clock' : 500000000 .0 }} Per Part Configuration By default individual FPGA properties will be applies to all signal chains. However, if a specific only wants to be applied to the ADC or DAC side, or ADC1 but not ADC2, this configuration is possible. This is done through dictionary parameterization as following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 sys = adijif . system ([ \"ad9680\" , \"ad9144\" ], \"ad9523_1\" , \"xilinx\" , 125e6 ) sys . fpga . setup_by_dev_kit_name ( \"zcu102\" ) sys . fpga . force_cpll = True sys . fpga . out_clk_select = { sys . converter [ 0 ]: \"XCVR_REFCLK\" , sys . converter [ 1 ]: \"XCVR_REFCLK_DIV2\" , } sys . fpga . requires_separate_link_layer_out_clock = { sys . converter [ 0 ]: True , sys . converter [ 1 ]: False , } ...","title":"Clocking"},{"location":"fpga_internal/#fpga-clocking","text":"JESD204 is a protocol that is made up of layers to manage the different aspects of the data link between the converters and FPGA. On the converter side this is handled for you by the ASIC designer but the FPGA side requires a lot more work. This is heavily managed by the ADI JESD204 Framework , but it still needs to be specifically configured and laid out correctly for a specific use case or set of use cases. From the diagram above, we can see in the FPGA there are explicit cores within the FPGA to manager the PHY Layer, Link Layer, and Transport Layer aspects for the JESD204 protocol. These will have specific drivers and HDL IP that need to configured for a configuration. By configuration, it primarily refers to the clocking and JESD modes. In the diagram there are both TX and RX data paths but generically they can considered identical, data will just flow in a specific direction in each case.","title":"FPGA Clocking"},{"location":"fpga_internal/#clocking-layout","text":"Focusing on an individual chain, we can consider the diagram below where the individual clocks are detailed. These clocks can be provided externally or internally but must meet some basic requirements. Traditionally they will come from an external clocking devices, which can drastically save power and resources, and adijif takes this approach. The clocks will have the following constraints: ref clock : This clock's primary purpose is to drive the SERDES which will typically happen by feeding the CPLL or QPLL inside the transceiver primitives of the FPGA. Therefore, it's frequency is determined base on the PLL dividers and range limitations. The constraint here is that the ref clock times the PLL multiply/divide ratio must meet the lane rate of the desired link, which is fixed. link clock : This clock must be lane rate /40 (204B) or lane rate /60 (204C). It most cases the ref clock and the link clock will be the same value, or the ref clock is just selected to be equal to the link clock from the start for simplicity. However, this is not always possible. Therefore, the FPGA PLL clock dividers and muxes can be used to correctly meet this requirement from an upstream clock. These dividers and muxed are detailed in the diagram below, where RXOUTCLK is itself used to drive the link layer. device clock : This clock is unique since it must be derived from the same source as SYSREF , since it is used to sample SYSREF and be a multiple of the sample clock. The device clock determines the output rate of the link layer, and when this rate is different than the link clock it will enable the Gearbox inside the link layer HDL core. This will occur usually when N' is not 8 or 16, or when F != 1, 2, or 4. It is also important to select this clock with respect to desired data rate constraints for downstream logic since this is the rate application logic must consume data at. This clock will be at the sample clock / N where N is some integer. However, this rate should not exceed the Fmax of the FPGA logic. SYSREF : This clock is simple the system reference and will be lane rate / M where M is a power of 2 and should be large. Technically, only the device clock is needed by the FPGA and all other clocks (except for SYSREF ) could be derived from it. This assumes the necessary ratios are possible by the internal dividers. However, in most cases SYSREF is used for deterministic latency. From Xilinx UG576","title":"Clocking Layout"},{"location":"fpga_internal/#api-controls","text":"To manage the generation of these clocks, APIs are provided in the FPGA specific classes ( adijif.fpga.xilinx ). These are: out_clk_select : Control {RX/TX}CLKSEL mux. Options are XCVR_REFCLK , XCVR_REFCLK_DIV2 , XCVR_PROGDIV_CLK force_cpll : Force use of CPLL force_qpll : Force use of QPLL force_qpll1 : Force use of QPLL1 (only available on GTH and GTY transceivers) requires_separate_link_layer_out_clock : Enable generation of separate device clock . This rate is automatically determined base on Fmax of FPGA By default adijif will try to determine valid PLL settings and necessary muxing settings to meet the link clock and ref clock requirements. If a separate device clock is needed enable requires_separate_link_layer_out_clock . Below is an example of an explicit request for a separate device clock and since out_clk_select is set to XCVR_REFCLK it will force the ref clock to be equal to the link clock . import adijif vcxo = 125e6 sys = adijif . system ( \"ad9680\" , \"ad9523_1\" , \"xilinx\" , vcxo ) sys . Debug_Solver = False sys . fpga . setup_by_dev_kit_name ( \"zcu102\" ) sys . fpga . force_cpll = True sys . fpga . out_clk_select = \"XCVR_REFCLK\" # force reference to be core clock rate sys . fpga . requires_separate_link_layer_out_clock = True # Get extra clock sys . converter . use_direct_clocking = True sys . converter . set_quick_configuration_mode ( 0x88 ) assert sys . converter . S == 1 # Limit upper dividers to powers of 2 sys . clock . d = [ int ( 2 ** i ) for i in range ( 8 )] # Current configuration sys . converter . sample_clock = 1e9 / 2 cfg = sys . solve () In the output the lines specific to the link layer and mux configuration have been highlighted: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 { 'clock' : { 'm1' : 3 , 'n2' : 24 , 'out_dividers' : [ 2 , 64 , 8 , 4 ] , 'output_clocks' : { 'AD9680_fpga_link_out_clk' : { 'divider' : 4 , 'rate' : 250000000 .0 } , 'ADC_CLK' : { 'divider' : 2 , 'rate' : 500000000 .0 } , 'ADC_CLK_FMC' : { 'divider' : 8 , 'rate' : 125000000 .0 } , 'ADC_SYSREF' : { 'divider' : 64 , 'rate' : 15625000 .0 } , 'CLKD_ADC_SYSREF' : { 'divider' : 64 , 'rate' : 15625000 .0 }} , 'part' : 'AD9523-1' , 'r2' : 1 , 'vco' : 1000000000 .0, 'vcxo' : 125000000 .0 } , 'converter' : [] , 'converter_AD9680' : { 'clocking_option' : 'direct' , 'decimation' : 1 } , 'fpga_AD9680' : { 'd' : 1 , 'm' : 1 , 'n1' : 4 , 'n2' : 5 , 'out_clk_select' : 'XCVR_REF_CLK' , 'sys_clk_select' : 'XCVR_QPLL1' , 'transport_samples_per_clock' : 2 , 'type' : 'cpll' , 'vco' : 2500000000 .0 } , 'jesd_AD9680' : { 'CS' : 0 , 'F' : 1 , 'HD' : 1 , 'K' : 32 , 'L' : 4 , 'M' : 2 , 'Np' : 16 , 'S' : 1 , 'bit_clock' : 5000000000 .0, 'converter_clock' : 500000000 .0, 'jesd_class' : 'jesd204b' , 'jesd_mode' : '136' , 'multiframe_clock' : 15625000 .0, 'sample_clock' : 500000000 .0 }}","title":"API Controls"},{"location":"fpga_internal/#per-part-configuration","text":"By default individual FPGA properties will be applies to all signal chains. However, if a specific only wants to be applied to the ADC or DAC side, or ADC1 but not ADC2, this configuration is possible. This is done through dictionary parameterization as following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 sys = adijif . system ([ \"ad9680\" , \"ad9144\" ], \"ad9523_1\" , \"xilinx\" , 125e6 ) sys . fpga . setup_by_dev_kit_name ( \"zcu102\" ) sys . fpga . force_cpll = True sys . fpga . out_clk_select = { sys . converter [ 0 ]: \"XCVR_REFCLK\" , sys . converter [ 1 ]: \"XCVR_REFCLK_DIV2\" , } sys . fpga . requires_separate_link_layer_out_clock = { sys . converter [ 0 ]: True , sys . converter [ 1 ]: False , } ...","title":"Per Part Configuration"},{"location":"fpga_ref/","text":"FPGA Reference APIs Xilinx FPGA clocking model. xilinx Xilinx FPGA clocking model. This model captures different limitations of the Xilinx PLLs and interfaces used for JESD. Currently only Zynq 7000 devices have been fully tested. force_cpll Force all transceiver sources to be from a single PLL quad. This will try to leverage the output dividers of the PLLs force_qpll Force use of QPLL1 for transceiver source (GTH3,GTH4,GTY4) force_qpll1 Force use of CPLL for transceiver source force_single_quad_tile Request that clock chip generated device clock device clock == LMFC/40 NOTE: THIS IS NOT FPGA REF CLOCK N : List [ int ] property readonly Get available feedback divider settings. This is applicable for QPLLs only. Returns: Type Description List[int] list[int]: List of divider integers. Exceptions: Type Description Exception Unsupported transceiver type configured. out_clk_select : Union [ int , float ] property writable Get current PLL clock output mux options for link layer clock. Valid options are: \"XCVR_REFCLK\", \"XCVR_REFCLK_DIV2\", \"XCVR_PROGDIV_CLK\" If a list of these is provided, the solver will determine one to use Returns: Type Description Union[int, float] str,list(str): Mux selection for link layer clock. target_Fmax Require generation of separate clock specifically for link layer vco0_max : int property readonly Get maximum QPLL VCO0 rate for config. This is applicable for QPLLs only. Returns: Type Description int int: Rate in samples per second. Exceptions: Type Description Exception Unsupported transceiver type configured. vco0_min : int property readonly Get minimum QPLL VCO0 rate for config. This is applicable for QPLLs only. Returns: Type Description int int: Rate in samples per second. Exceptions: Type Description Exception Unsupported transceiver type configured. vco1_max : int property readonly Get maximum QPLL VCO1 rate for config. This is applicable for QPLLs only. Returns: Type Description int int: Rate in samples per second. Exceptions: Type Description Exception Unsupported transceiver type configured. vco1_min : int property readonly Get minimum QPLL VCO1 rate for config. This is applicable for QPLLs only. Returns: Type Description int int: Rate in samples per second. Exceptions: Type Description Exception Unsupported transceiver type configured. vco_max : int property readonly Get maximum CPLL VCO rate for config. Returns: Type Description int int: Rate in samples per second. Exceptions: Type Description Exception Unsupported transceiver type configured. vco_min : int property readonly Get minimum CPLL VCO rate for config. Returns: Type Description int int: Rate in samples per second. Exceptions: Type Description Exception Unsupported transceiver type configured. determine_pll ( self , bit_clock , fpga_ref_clock ) Determin if configuration is possible with CPLL or QPLL. CPLL is checked first and will check QPLL if that case is invalid. This is only used for brute-force implementations. Parameters: Name Type Description Default bit_clock int Equivalent to lane rate in bits/second required fpga_ref_clock int System reference clock required Returns: Type Description Dict Dict: Dictionary of PLL configuration get_config ( self , converter , fpga_ref , solution = None ) Extract configurations from solver results. Collect internal FPGA configuration and output clock definitions. Parameters: Name Type Description Default converter converter Converter object connected to FPGA who config is collected required fpga_ref Union[float, int] Reference clock generated for FPGA for specific converter required solution Optional[docplex.cp.solution.CpoSolveResult] CPlex solution. Only needed for CPlex solver None Exceptions: Type Description Exception Invalid PLL configuration. Returns: Type Description Union[List[Dict], Dict] Dict: Dictionary of clocking rates and dividers for configuration get_required_clock_names ( self ) Get list of strings of names of requested clocks. This list of names is for the clocks defined by get_required_clocks Returns: Type Description List[str] List[str]: List of strings of clock names in order Exceptions: Type Description Exception Clock have not been enumerated aka get_required_clocks not not called yet. get_required_clocks ( self , converter , fpga_ref , link_out_ref = None ) Get necessary clocks for QPLL/CPLL configuration. Parameters: Name Type Description Default converter converter Converter object of converter connected to FPGA required fpga_ref Union[int, NoneType, docplex.cp.expression.CpoIntVar] Abstract or concrete reference to FPGA reference clock required link_out_ref Union[int, NoneType, docplex.cp.expression.CpoIntVar] Reference clock generated for FPGA link layer output None Returns: Type Description List List: List of solver variables and constraints Exceptions: Type Description Exception If solver is not valid Exception Link layer out clock required setup_by_dev_kit_name ( self , name ) Configure object based on board name. Ex: zc706, zcu102. Parameters: Name Type Description Default name str Name of dev kit. Ex: zc706, zcu102 required Exceptions: Type Description Exception Unsupported board requested.","title":"FPGAs"},{"location":"fpga_ref/#fpga-reference-apis","text":"","title":"FPGA Reference APIs"},{"location":"fpga_ref/#adijif.fpgas.xilinx","text":"Xilinx FPGA clocking model.","title":"adijif.fpgas.xilinx"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx","text":"Xilinx FPGA clocking model. This model captures different limitations of the Xilinx PLLs and interfaces used for JESD. Currently only Zynq 7000 devices have been fully tested.","title":"xilinx"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.force_cpll","text":"Force all transceiver sources to be from a single PLL quad. This will try to leverage the output dividers of the PLLs","title":"force_cpll"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.force_qpll","text":"Force use of QPLL1 for transceiver source (GTH3,GTH4,GTY4)","title":"force_qpll"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.force_qpll1","text":"Force use of CPLL for transceiver source","title":"force_qpll1"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.force_single_quad_tile","text":"Request that clock chip generated device clock device clock == LMFC/40 NOTE: THIS IS NOT FPGA REF CLOCK","title":"force_single_quad_tile"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.N","text":"Get available feedback divider settings. This is applicable for QPLLs only. Returns: Type Description List[int] list[int]: List of divider integers. Exceptions: Type Description Exception Unsupported transceiver type configured.","title":"N"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.out_clk_select","text":"Get current PLL clock output mux options for link layer clock. Valid options are: \"XCVR_REFCLK\", \"XCVR_REFCLK_DIV2\", \"XCVR_PROGDIV_CLK\" If a list of these is provided, the solver will determine one to use Returns: Type Description Union[int, float] str,list(str): Mux selection for link layer clock.","title":"out_clk_select"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.target_Fmax","text":"Require generation of separate clock specifically for link layer","title":"target_Fmax"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.vco0_max","text":"Get maximum QPLL VCO0 rate for config. This is applicable for QPLLs only. Returns: Type Description int int: Rate in samples per second. Exceptions: Type Description Exception Unsupported transceiver type configured.","title":"vco0_max"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.vco0_min","text":"Get minimum QPLL VCO0 rate for config. This is applicable for QPLLs only. Returns: Type Description int int: Rate in samples per second. Exceptions: Type Description Exception Unsupported transceiver type configured.","title":"vco0_min"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.vco1_max","text":"Get maximum QPLL VCO1 rate for config. This is applicable for QPLLs only. Returns: Type Description int int: Rate in samples per second. Exceptions: Type Description Exception Unsupported transceiver type configured.","title":"vco1_max"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.vco1_min","text":"Get minimum QPLL VCO1 rate for config. This is applicable for QPLLs only. Returns: Type Description int int: Rate in samples per second. Exceptions: Type Description Exception Unsupported transceiver type configured.","title":"vco1_min"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.vco_max","text":"Get maximum CPLL VCO rate for config. Returns: Type Description int int: Rate in samples per second. Exceptions: Type Description Exception Unsupported transceiver type configured.","title":"vco_max"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.vco_min","text":"Get minimum CPLL VCO rate for config. Returns: Type Description int int: Rate in samples per second. Exceptions: Type Description Exception Unsupported transceiver type configured.","title":"vco_min"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.determine_pll","text":"Determin if configuration is possible with CPLL or QPLL. CPLL is checked first and will check QPLL if that case is invalid. This is only used for brute-force implementations. Parameters: Name Type Description Default bit_clock int Equivalent to lane rate in bits/second required fpga_ref_clock int System reference clock required Returns: Type Description Dict Dict: Dictionary of PLL configuration","title":"determine_pll()"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.get_config","text":"Extract configurations from solver results. Collect internal FPGA configuration and output clock definitions. Parameters: Name Type Description Default converter converter Converter object connected to FPGA who config is collected required fpga_ref Union[float, int] Reference clock generated for FPGA for specific converter required solution Optional[docplex.cp.solution.CpoSolveResult] CPlex solution. Only needed for CPlex solver None Exceptions: Type Description Exception Invalid PLL configuration. Returns: Type Description Union[List[Dict], Dict] Dict: Dictionary of clocking rates and dividers for configuration","title":"get_config()"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.get_required_clock_names","text":"Get list of strings of names of requested clocks. This list of names is for the clocks defined by get_required_clocks Returns: Type Description List[str] List[str]: List of strings of clock names in order Exceptions: Type Description Exception Clock have not been enumerated aka get_required_clocks not not called yet.","title":"get_required_clock_names()"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.get_required_clocks","text":"Get necessary clocks for QPLL/CPLL configuration. Parameters: Name Type Description Default converter converter Converter object of converter connected to FPGA required fpga_ref Union[int, NoneType, docplex.cp.expression.CpoIntVar] Abstract or concrete reference to FPGA reference clock required link_out_ref Union[int, NoneType, docplex.cp.expression.CpoIntVar] Reference clock generated for FPGA link layer output None Returns: Type Description List List: List of solver variables and constraints Exceptions: Type Description Exception If solver is not valid Exception Link layer out clock required","title":"get_required_clocks()"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.setup_by_dev_kit_name","text":"Configure object based on board name. Ex: zc706, zcu102. Parameters: Name Type Description Default name str Name of dev kit. Ex: zc706, zcu102 required Exceptions: Type Description Exception Unsupported board requested.","title":"setup_by_dev_kit_name()"},{"location":"fpgas/","text":"FPGA Configuration FPGA clock models focus upon the PLLs inside different FPGA variants that drive different transceivers which connect to data converters. Currently, only specific Xilinx FPGA models are supported, but more are planned. However, the configurations determined by pyadi-jif are in the context of the ADI JESD Interface Framework and their related HDL cores. This is important since IP from different vendors have different supported modes. The FPGA models are similar to converter models but they require converter objects to be passed to them for configuration. From the converter objects the FPGA classes can derive the dependent clocks and JESD configuration. Due to this limitation, FPGA classes cannot be used standalone like data converter or clock chip classes. The second primary limitation is that the FPGA hardware model must be known and set beforehand. The FPGA hardware model determines clock ranges, internal PLL limits, and transceiver constraints. Since these can vary widely, making the internal solvers directly determine supported FPGAs would be a very burdensome task. However, pyadi-jif could be called in a loop to validate against different FPGA hardware models. pyadi-jif is not endorsed or verified by Xilinx or Intel Xilinx FPGAs For Xilinx FPGAs both 7000 and Ultrascale device types can be parameterized. However, since specifications can vary widely depending on chip model or board, extensive configuration needs to be provided. A pre-existing table of boards can be leveraged through the setup_by_dev_kit_name method. This includes support for: ZC706 ZCU102 VCU118 Otherwise to manually configure an FPGA object requires setting the following: fpga . transceiver_voltage = 800 fpga . transciever_type = \"GTX2\" fpga . fpga_family = \"Zynq\" fpga . fpga_package = \"FF\" fpga . speed_grade = - 2 fpga . ref_clock_min = 60000000 fpga . ref_clock_max = 670000000 fpga . max_serdes_lanes = 8 Selecting QPLL or CPLL Both CPLL and QPLL types are supported and can either be automatically determined or forced to use either. This is done through two class properties: sys = adijif . system ( \"ad9680\" , \"ad9523_1\" , \"xilinx\" , vcxo ) ... sys . fpga . force_cpll = 1 # Force use of CPLL # or sys . fpga . force_qpll = 1 # Force use of QPLL # or (Default) let solver select sys . fpga . force_cpll = 0 sys . fpga . force_qpll = 0 The solver tries to use the CPLL since it is more flexible architecturally. For more detail on the 7000 Series PLL architecture consult ug476 . Current known limitations When multiple converters are connected to the same FPGA, or RX and TX from the same converter, the solver does not force the clocks to come from a single QTile. Intel FPGAs None supported yet. Example usage As mentioned the FPGA classes can not be used standalone. Therefore, the system class must be used when interfacing with the solvers. Below is a simple example based around using the AD-FMCDAQ2-EBZ and a Xilinx ZC706. # Create instance of system class with desired parts sys = adijif . system ( \"ad9680\" , \"ad9523_1\" , \"xilinx\" , 125000000 ) # Set Converter clocking requirements sys . converter . sample_clock = 1e9 sys . converter . datapath_decimation = 1 sys . converter . L = 4 sys . converter . M = 2 sys . converter . N = 14 sys . converter . Np = 16 sys . converter . K = 32 sys . converter . F = 1 # Set FPGA clocking requirements sys . fpga . setup_by_dev_kit_name ( \"zc706\" ) # Call solver and collect configuration config = sys . solve () pprint . pprint ( config [ 'fpga' ]) Sample Output { 'band' : 1 .0, 'd' : 1 .0, 'm' : 1 .0, 'n' : 100 .0, 'qty4_full_rate_enabled' : 0 .0, 'type' : 'qpll' , 'vco' : 10000000000 .0 } The output in this case shows that the QPLL is used (probably required), the upper band related to VCO1 is used, and all the necessary dividers are provided for configuration.","title":"Configuration Class"},{"location":"fpgas/#fpga-configuration","text":"FPGA clock models focus upon the PLLs inside different FPGA variants that drive different transceivers which connect to data converters. Currently, only specific Xilinx FPGA models are supported, but more are planned. However, the configurations determined by pyadi-jif are in the context of the ADI JESD Interface Framework and their related HDL cores. This is important since IP from different vendors have different supported modes. The FPGA models are similar to converter models but they require converter objects to be passed to them for configuration. From the converter objects the FPGA classes can derive the dependent clocks and JESD configuration. Due to this limitation, FPGA classes cannot be used standalone like data converter or clock chip classes. The second primary limitation is that the FPGA hardware model must be known and set beforehand. The FPGA hardware model determines clock ranges, internal PLL limits, and transceiver constraints. Since these can vary widely, making the internal solvers directly determine supported FPGAs would be a very burdensome task. However, pyadi-jif could be called in a loop to validate against different FPGA hardware models. pyadi-jif is not endorsed or verified by Xilinx or Intel","title":"FPGA Configuration"},{"location":"fpgas/#xilinx-fpgas","text":"For Xilinx FPGAs both 7000 and Ultrascale device types can be parameterized. However, since specifications can vary widely depending on chip model or board, extensive configuration needs to be provided. A pre-existing table of boards can be leveraged through the setup_by_dev_kit_name method. This includes support for: ZC706 ZCU102 VCU118 Otherwise to manually configure an FPGA object requires setting the following: fpga . transceiver_voltage = 800 fpga . transciever_type = \"GTX2\" fpga . fpga_family = \"Zynq\" fpga . fpga_package = \"FF\" fpga . speed_grade = - 2 fpga . ref_clock_min = 60000000 fpga . ref_clock_max = 670000000 fpga . max_serdes_lanes = 8","title":"Xilinx FPGAs"},{"location":"fpgas/#selecting-qpll-or-cpll","text":"Both CPLL and QPLL types are supported and can either be automatically determined or forced to use either. This is done through two class properties: sys = adijif . system ( \"ad9680\" , \"ad9523_1\" , \"xilinx\" , vcxo ) ... sys . fpga . force_cpll = 1 # Force use of CPLL # or sys . fpga . force_qpll = 1 # Force use of QPLL # or (Default) let solver select sys . fpga . force_cpll = 0 sys . fpga . force_qpll = 0 The solver tries to use the CPLL since it is more flexible architecturally. For more detail on the 7000 Series PLL architecture consult ug476 .","title":"Selecting QPLL or CPLL"},{"location":"fpgas/#current-known-limitations","text":"When multiple converters are connected to the same FPGA, or RX and TX from the same converter, the solver does not force the clocks to come from a single QTile.","title":"Current known limitations"},{"location":"fpgas/#intel-fpgas","text":"None supported yet.","title":"Intel FPGAs"},{"location":"fpgas/#example-usage","text":"As mentioned the FPGA classes can not be used standalone. Therefore, the system class must be used when interfacing with the solvers. Below is a simple example based around using the AD-FMCDAQ2-EBZ and a Xilinx ZC706. # Create instance of system class with desired parts sys = adijif . system ( \"ad9680\" , \"ad9523_1\" , \"xilinx\" , 125000000 ) # Set Converter clocking requirements sys . converter . sample_clock = 1e9 sys . converter . datapath_decimation = 1 sys . converter . L = 4 sys . converter . M = 2 sys . converter . N = 14 sys . converter . Np = 16 sys . converter . K = 32 sys . converter . F = 1 # Set FPGA clocking requirements sys . fpga . setup_by_dev_kit_name ( \"zc706\" ) # Call solver and collect configuration config = sys . solve () pprint . pprint ( config [ 'fpga' ]) Sample Output { 'band' : 1 .0, 'd' : 1 .0, 'm' : 1 .0, 'n' : 100 .0, 'qty4_full_rate_enabled' : 0 .0, 'type' : 'qpll' , 'vco' : 10000000000 .0 } The output in this case shows that the QPLL is used (probably required), the upper band related to VCO1 is used, and all the necessary dividers are provided for configuration.","title":"Example usage"},{"location":"install/","text":"Installing PyADI-JIF Before installing the module make sure is installed. pyadi-jif has been validated to function on Windows, Linux, and MacOS. However, not all internal solvers function across all architectures. Specifically the CPLEX solver will not function under ARM. This does not limit functionality, only solving speed. Installing from pip (Recommended) pyadi-jif can be installed from pip with all its dependencies: $ pip install --index-url https://test.pypi.org/simple/ pyadi-jif ---> 100% Installing from source Alternatively, pyadi-jif can be installed directly from source. This will require git to be installed $ git clone https://github.com/analogdevicesinc/pyadi-jif.git Cloning into 'pyadi-jif'... remote: Enumerating objects: 61, done. remote: Counting objects: 100% (61/61), done. remote: Compressing objects: 100% (53/53), done. remote: Total 1063 (delta 16), reused 30 (delta 8), pack-reused 1002 Receiving objects: 100% (1063/1063), 553.66 KiB | 3.24 MiB/s, done. Resolving deltas: 100% (681/681), done. $ cd pyadi-jif $ python setup.py install ---> 100% For developers check out the Developers section.","title":"Quick Start"},{"location":"install/#installing-pyadi-jif","text":"Before installing the module make sure is installed. pyadi-jif has been validated to function on Windows, Linux, and MacOS. However, not all internal solvers function across all architectures. Specifically the CPLEX solver will not function under ARM. This does not limit functionality, only solving speed.","title":"Installing PyADI-JIF"},{"location":"install/#installing-from-pip-recommended","text":"pyadi-jif can be installed from pip with all its dependencies: $ pip install --index-url https://test.pypi.org/simple/ pyadi-jif ---> 100%","title":"Installing from pip (Recommended)"},{"location":"install/#installing-from-source","text":"Alternatively, pyadi-jif can be installed directly from source. This will require git to be installed $ git clone https://github.com/analogdevicesinc/pyadi-jif.git Cloning into 'pyadi-jif'... remote: Enumerating objects: 61, done. remote: Counting objects: 100% (61/61), done. remote: Compressing objects: 100% (53/53), done. remote: Total 1063 (delta 16), reused 30 (delta 8), pack-reused 1002 Receiving objects: 100% (1063/1063), 553.66 KiB | 3.24 MiB/s, done. Resolving deltas: 100% (681/681), done. $ cd pyadi-jif $ python setup.py install ---> 100% For developers check out the Developers section.","title":"Installing from source"},{"location":"parts/","text":"Supported Parts Data Converters AD9081 AD9680 AD9144 ADRV9009 Clock Chips AD9523-1 AD9528 HMC7044","title":"Supported Parts"},{"location":"parts/#supported-parts","text":"","title":"Supported Parts"},{"location":"parts/#data-converters","text":"AD9081 AD9680 AD9144 ADRV9009","title":"Data Converters"},{"location":"parts/#clock-chips","text":"AD9523-1 AD9528 HMC7044","title":"Clock Chips"},{"location":"ref/","text":"Reference AD9523-1 clock chip model. ad9523_1 AD9523-1 clock chip model. This model currently supports VCXO+PLL2 configurations d : Union [ int , List [ int ]] property writable Output dividers. Valid dividers are 1->1023 Returns: Type Description Union[int, List[int]] int: Current allowable dividers m1 : Union [ int , List [ int ]] property writable VCO divider path 1. Valid dividers are 3,4,5 Returns: Type Description Union[int, List[int]] int: Current allowable dividers minimize_feedback_dividers Enable internal VCXO/PLL1 doubler n2 : Union [ int , List [ int ]] property writable n2: VCO feedback divider. Valid dividers are 12, 16, 17, 20, 21, 22, 24, 25, 26, 28->255 Returns: Type Description Union[int, List[int]] int: Current allowable dividers r2 : Union [ int , List [ int ]] property writable VCXO input dividers. Valid dividers are 1->31 Returns: Type Description Union[int, List[int]] int: Current allowable dividers get_config ( self , solution : CpoSolveResult = None ) -> Dict Extract configurations from solver results. Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration Exceptions: Type Description Exception If solver is not called first set_requested_clocks ( self , vcxo : int , out_freqs : List , clk_names : List [ str ]) -> None Define necessary clocks to be generated in model. Parameters: Name Type Description Default vcxo int VCXO frequency in hertz required out_freqs List list of required clocks to be output required clk_names List[str] list of strings of clock names required Exceptions: Type Description Exception If len(out_freqs) != len(clk_names) AD9528 clock chip model. ad9528 AD9528 clock chip model. This model currently supports VCXO+PLL2 configurations a : Union [ int , List [ int ]] property writable VCO calibration divider 1. Valid dividers are 0->3 Returns: Type Description Union[int, List[int]] int: Current allowable dividers b : Union [ int , List [ int ]] property writable VCO calibration divider 2. Valid dividers are 3->63 Returns: Type Description Union[int, List[int]] int: Current allowable dividers b_availble VCXO dividers d : Union [ int , List [ int ]] property writable Output dividers. Valid dividers are 1->1023 Returns: Type Description Union[int, List[int]] int: Current allowable dividers d_available VCXO multiplier m1 : Union [ int , List [ int ]] property writable VCO divider path 1. Valid dividers are 3,4,5 Returns: Type Description Union[int, List[int]] int: Current allowable dividers m1_available Output dividers n2 : Union [ int , List [ int ]] property writable n2: VCO feedback divider. Valid dividers are 12->255 Returns: Type Description Union[int, List[int]] int: Current allowable dividers n2_available VCO calibration dividers r1 : Union [ int , List [ int ]] property writable VCXO input dividers. Valid dividers are 1->31 Returns: Type Description Union[int, List[int]] int: Current allowable dividers get_config ( self , solution = None ) Extract configurations from solver results. Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration Exceptions: Type Description Exception If solver is not called first set_requested_clocks ( self , vcxo , out_freqs , clk_names ) Define necessary clocks to be generated in model. Parameters: Name Type Description Default vcxo int VCXO frequency in hertz required out_freqs List list of required clocks to be output required clk_names List[str] list of strings of clock names required Exceptions: Type Description Exception If len(out_freqs) != len(clk_names) HMC7044 clock chip model. hmc7044 HMC7044 clock chip model. This model currently supports VCXO+PLL2 configurations d : Union [ int , List [ int ]] property writable Output dividers. Valid dividers are 1,2,3,4,5,6->(even)->4094 Returns: Type Description Union[int, List[int]] int: Current allowable dividers n2 : Union [ int , List [ int ]] property writable n2: VCO feedback divider. Valid dividers are 8->65536 Returns: Type Description Union[int, List[int]] int: Current allowable dividers r2 : Union [ int , List [ int ]] property writable VCXO input dividers. Valid dividers are 1->4096 Returns: Type Description Union[int, List[int]] int: Current allowable dividers r2_available Output dividers vxco_doubler : Union [ int , List [ int ]] property writable VCXO doubler. Valid dividers are 1,2 Returns: Type Description Union[int, List[int]] int: Current doubler value __init__ ( self , model = None , solver = 'CPLEX' ) special Initialize HMC7044 clock chip model. Parameters: Name Type Description Default model Union[NoneType, docplex.cp.model.CpoModel] Model to add constraints to None solver str Solver to use. Should be one of \"CPLEX\" or \"gekko\" 'CPLEX' Exceptions: Type Description Exception Invalid solver get_config ( self , solution = None ) Extract configurations from solver results. Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration Exceptions: Type Description Exception If solver is not called first set_requested_clocks ( self , vcxo , out_freqs , clk_names ) Define necessary clocks to be generated in model. Parameters: Name Type Description Default vcxo int VCXO frequency in hertz required out_freqs List list of required clocks to be output required clk_names List[str] list of strings of clock names required Exceptions: Type Description Exception If len(out_freqs) != len(clk_names)","title":"Reference"},{"location":"ref/#reference","text":"","title":"Reference"},{"location":"ref/#adijif.clocks.ad9523","text":"AD9523-1 clock chip model.","title":"adijif.clocks.ad9523"},{"location":"ref/#adijif.clocks.ad9523.ad9523_1","text":"AD9523-1 clock chip model. This model currently supports VCXO+PLL2 configurations","title":"ad9523_1"},{"location":"ref/#adijif.clocks.ad9523.ad9523_1.d","text":"Output dividers. Valid dividers are 1->1023 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"d"},{"location":"ref/#adijif.clocks.ad9523.ad9523_1.m1","text":"VCO divider path 1. Valid dividers are 3,4,5 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"m1"},{"location":"ref/#adijif.clocks.ad9523.ad9523_1.minimize_feedback_dividers","text":"Enable internal VCXO/PLL1 doubler","title":"minimize_feedback_dividers"},{"location":"ref/#adijif.clocks.ad9523.ad9523_1.n2","text":"n2: VCO feedback divider. Valid dividers are 12, 16, 17, 20, 21, 22, 24, 25, 26, 28->255 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"n2"},{"location":"ref/#adijif.clocks.ad9523.ad9523_1.r2","text":"VCXO input dividers. Valid dividers are 1->31 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"r2"},{"location":"ref/#adijif.clocks.ad9523.ad9523_1.get_config","text":"Extract configurations from solver results. Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration Exceptions: Type Description Exception If solver is not called first","title":"get_config()"},{"location":"ref/#adijif.clocks.ad9523.ad9523_1.set_requested_clocks","text":"Define necessary clocks to be generated in model. Parameters: Name Type Description Default vcxo int VCXO frequency in hertz required out_freqs List list of required clocks to be output required clk_names List[str] list of strings of clock names required Exceptions: Type Description Exception If len(out_freqs) != len(clk_names)","title":"set_requested_clocks()"},{"location":"ref/#adijif.clocks.ad9528","text":"AD9528 clock chip model.","title":"adijif.clocks.ad9528"},{"location":"ref/#adijif.clocks.ad9528.ad9528","text":"AD9528 clock chip model. This model currently supports VCXO+PLL2 configurations","title":"ad9528"},{"location":"ref/#adijif.clocks.ad9528.ad9528.a","text":"VCO calibration divider 1. Valid dividers are 0->3 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"a"},{"location":"ref/#adijif.clocks.ad9528.ad9528.b","text":"VCO calibration divider 2. Valid dividers are 3->63 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"b"},{"location":"ref/#adijif.clocks.ad9528.ad9528.b_availble","text":"VCXO dividers","title":"b_availble"},{"location":"ref/#adijif.clocks.ad9528.ad9528.d","text":"Output dividers. Valid dividers are 1->1023 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"d"},{"location":"ref/#adijif.clocks.ad9528.ad9528.d_available","text":"VCXO multiplier","title":"d_available"},{"location":"ref/#adijif.clocks.ad9528.ad9528.m1","text":"VCO divider path 1. Valid dividers are 3,4,5 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"m1"},{"location":"ref/#adijif.clocks.ad9528.ad9528.m1_available","text":"Output dividers","title":"m1_available"},{"location":"ref/#adijif.clocks.ad9528.ad9528.n2","text":"n2: VCO feedback divider. Valid dividers are 12->255 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"n2"},{"location":"ref/#adijif.clocks.ad9528.ad9528.n2_available","text":"VCO calibration dividers","title":"n2_available"},{"location":"ref/#adijif.clocks.ad9528.ad9528.r1","text":"VCXO input dividers. Valid dividers are 1->31 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"r1"},{"location":"ref/#adijif.clocks.ad9528.ad9528.get_config","text":"Extract configurations from solver results. Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration Exceptions: Type Description Exception If solver is not called first","title":"get_config()"},{"location":"ref/#adijif.clocks.ad9528.ad9528.set_requested_clocks","text":"Define necessary clocks to be generated in model. Parameters: Name Type Description Default vcxo int VCXO frequency in hertz required out_freqs List list of required clocks to be output required clk_names List[str] list of strings of clock names required Exceptions: Type Description Exception If len(out_freqs) != len(clk_names)","title":"set_requested_clocks()"},{"location":"ref/#adijif.clocks.hmc7044","text":"HMC7044 clock chip model.","title":"adijif.clocks.hmc7044"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044","text":"HMC7044 clock chip model. This model currently supports VCXO+PLL2 configurations","title":"hmc7044"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.d","text":"Output dividers. Valid dividers are 1,2,3,4,5,6->(even)->4094 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"d"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.n2","text":"n2: VCO feedback divider. Valid dividers are 8->65536 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"n2"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.r2","text":"VCXO input dividers. Valid dividers are 1->4096 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"r2"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.r2_available","text":"Output dividers","title":"r2_available"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.vxco_doubler","text":"VCXO doubler. Valid dividers are 1,2 Returns: Type Description Union[int, List[int]] int: Current doubler value","title":"vxco_doubler"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.__init__","text":"Initialize HMC7044 clock chip model. Parameters: Name Type Description Default model Union[NoneType, docplex.cp.model.CpoModel] Model to add constraints to None solver str Solver to use. Should be one of \"CPLEX\" or \"gekko\" 'CPLEX' Exceptions: Type Description Exception Invalid solver","title":"__init__()"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.get_config","text":"Extract configurations from solver results. Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration Exceptions: Type Description Exception If solver is not called first","title":"get_config()"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.set_requested_clocks","text":"Define necessary clocks to be generated in model. Parameters: Name Type Description Default vcxo int VCXO frequency in hertz required out_freqs List list of required clocks to be output required clk_names List[str] list of strings of clock names required Exceptions: Type Description Exception If len(out_freqs) != len(clk_names)","title":"set_requested_clocks()"},{"location":"devs/clocks/","text":"Reference AD9523-1 clock chip model. ad9523_1 AD9523-1 clock chip model. This model currently supports VCXO+PLL2 configurations d : Union [ int , List [ int ]] property writable Output dividers. Valid dividers are 1->1023 Returns: Type Description Union[int, List[int]] int: Current allowable dividers m1 : Union [ int , List [ int ]] property writable VCO divider path 1. Valid dividers are 3,4,5 Returns: Type Description Union[int, List[int]] int: Current allowable dividers minimize_feedback_dividers Enable internal VCXO/PLL1 doubler n2 : Union [ int , List [ int ]] property writable n2: VCO feedback divider. Valid dividers are 12, 16, 17, 20, 21, 22, 24, 25, 26, 28->255 Returns: Type Description Union[int, List[int]] int: Current allowable dividers r2 : Union [ int , List [ int ]] property writable VCXO input dividers. Valid dividers are 1->31 Returns: Type Description Union[int, List[int]] int: Current allowable dividers get_config ( self , solution : CpoSolveResult = None ) -> Dict Extract configurations from solver results. Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration Exceptions: Type Description Exception If solver is not called first set_requested_clocks ( self , vcxo : int , out_freqs : List , clk_names : List [ str ]) -> None Define necessary clocks to be generated in model. Parameters: Name Type Description Default vcxo int VCXO frequency in hertz required out_freqs List list of required clocks to be output required clk_names List[str] list of strings of clock names required Exceptions: Type Description Exception If len(out_freqs) != len(clk_names) AD9528 clock chip model. ad9528 AD9528 clock chip model. This model currently supports VCXO+PLL2 configurations a : Union [ int , List [ int ]] property writable VCO calibration divider 1. Valid dividers are 0->3 Returns: Type Description Union[int, List[int]] int: Current allowable dividers b : Union [ int , List [ int ]] property writable VCO calibration divider 2. Valid dividers are 3->63 Returns: Type Description Union[int, List[int]] int: Current allowable dividers b_availble VCXO dividers d : Union [ int , List [ int ]] property writable Output dividers. Valid dividers are 1->1023 Returns: Type Description Union[int, List[int]] int: Current allowable dividers d_available VCXO multiplier m1 : Union [ int , List [ int ]] property writable VCO divider path 1. Valid dividers are 3,4,5 Returns: Type Description Union[int, List[int]] int: Current allowable dividers m1_available Output dividers n2 : Union [ int , List [ int ]] property writable n2: VCO feedback divider. Valid dividers are 12->255 Returns: Type Description Union[int, List[int]] int: Current allowable dividers n2_available VCO calibration dividers r1 : Union [ int , List [ int ]] property writable VCXO input dividers. Valid dividers are 1->31 Returns: Type Description Union[int, List[int]] int: Current allowable dividers get_config ( self , solution = None ) Extract configurations from solver results. Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration Exceptions: Type Description Exception If solver is not called first set_requested_clocks ( self , vcxo , out_freqs , clk_names ) Define necessary clocks to be generated in model. Parameters: Name Type Description Default vcxo int VCXO frequency in hertz required out_freqs List list of required clocks to be output required clk_names List[str] list of strings of clock names required Exceptions: Type Description Exception If len(out_freqs) != len(clk_names) HMC7044 clock chip model. hmc7044 HMC7044 clock chip model. This model currently supports VCXO+PLL2 configurations d : Union [ int , List [ int ]] property writable Output dividers. Valid dividers are 1,2,3,4,5,6->(even)->4094 Returns: Type Description Union[int, List[int]] int: Current allowable dividers n2 : Union [ int , List [ int ]] property writable n2: VCO feedback divider. Valid dividers are 8->65536 Returns: Type Description Union[int, List[int]] int: Current allowable dividers r2 : Union [ int , List [ int ]] property writable VCXO input dividers. Valid dividers are 1->4096 Returns: Type Description Union[int, List[int]] int: Current allowable dividers r2_available Output dividers vxco_doubler : Union [ int , List [ int ]] property writable VCXO doubler. Valid dividers are 1,2 Returns: Type Description Union[int, List[int]] int: Current doubler value __init__ ( self , model = None , solver = 'CPLEX' ) special Initialize HMC7044 clock chip model. Parameters: Name Type Description Default model Union[NoneType, docplex.cp.model.CpoModel] Model to add constraints to None solver str Solver to use. Should be one of \"CPLEX\" or \"gekko\" 'CPLEX' Exceptions: Type Description Exception Invalid solver get_config ( self , solution = None ) Extract configurations from solver results. Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration Exceptions: Type Description Exception If solver is not called first set_requested_clocks ( self , vcxo , out_freqs , clk_names ) Define necessary clocks to be generated in model. Parameters: Name Type Description Default vcxo int VCXO frequency in hertz required out_freqs List list of required clocks to be output required clk_names List[str] list of strings of clock names required Exceptions: Type Description Exception If len(out_freqs) != len(clk_names)","title":"Clocks"},{"location":"devs/clocks/#reference","text":"","title":"Reference"},{"location":"devs/clocks/#adijif.clocks.ad9523","text":"AD9523-1 clock chip model.","title":"adijif.clocks.ad9523"},{"location":"devs/clocks/#adijif.clocks.ad9523.ad9523_1","text":"AD9523-1 clock chip model. This model currently supports VCXO+PLL2 configurations","title":"ad9523_1"},{"location":"devs/clocks/#adijif.clocks.ad9523.ad9523_1.d","text":"Output dividers. Valid dividers are 1->1023 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"d"},{"location":"devs/clocks/#adijif.clocks.ad9523.ad9523_1.m1","text":"VCO divider path 1. Valid dividers are 3,4,5 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"m1"},{"location":"devs/clocks/#adijif.clocks.ad9523.ad9523_1.minimize_feedback_dividers","text":"Enable internal VCXO/PLL1 doubler","title":"minimize_feedback_dividers"},{"location":"devs/clocks/#adijif.clocks.ad9523.ad9523_1.n2","text":"n2: VCO feedback divider. Valid dividers are 12, 16, 17, 20, 21, 22, 24, 25, 26, 28->255 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"n2"},{"location":"devs/clocks/#adijif.clocks.ad9523.ad9523_1.r2","text":"VCXO input dividers. Valid dividers are 1->31 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"r2"},{"location":"devs/clocks/#adijif.clocks.ad9523.ad9523_1.get_config","text":"Extract configurations from solver results. Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration Exceptions: Type Description Exception If solver is not called first","title":"get_config()"},{"location":"devs/clocks/#adijif.clocks.ad9523.ad9523_1.set_requested_clocks","text":"Define necessary clocks to be generated in model. Parameters: Name Type Description Default vcxo int VCXO frequency in hertz required out_freqs List list of required clocks to be output required clk_names List[str] list of strings of clock names required Exceptions: Type Description Exception If len(out_freqs) != len(clk_names)","title":"set_requested_clocks()"},{"location":"devs/clocks/#adijif.clocks.ad9528","text":"AD9528 clock chip model.","title":"adijif.clocks.ad9528"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528","text":"AD9528 clock chip model. This model currently supports VCXO+PLL2 configurations","title":"ad9528"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.a","text":"VCO calibration divider 1. Valid dividers are 0->3 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"a"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.b","text":"VCO calibration divider 2. Valid dividers are 3->63 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"b"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.b_availble","text":"VCXO dividers","title":"b_availble"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.d","text":"Output dividers. Valid dividers are 1->1023 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"d"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.d_available","text":"VCXO multiplier","title":"d_available"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.m1","text":"VCO divider path 1. Valid dividers are 3,4,5 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"m1"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.m1_available","text":"Output dividers","title":"m1_available"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.n2","text":"n2: VCO feedback divider. Valid dividers are 12->255 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"n2"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.n2_available","text":"VCO calibration dividers","title":"n2_available"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.r1","text":"VCXO input dividers. Valid dividers are 1->31 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"r1"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.get_config","text":"Extract configurations from solver results. Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration Exceptions: Type Description Exception If solver is not called first","title":"get_config()"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.set_requested_clocks","text":"Define necessary clocks to be generated in model. Parameters: Name Type Description Default vcxo int VCXO frequency in hertz required out_freqs List list of required clocks to be output required clk_names List[str] list of strings of clock names required Exceptions: Type Description Exception If len(out_freqs) != len(clk_names)","title":"set_requested_clocks()"},{"location":"devs/clocks/#adijif.clocks.hmc7044","text":"HMC7044 clock chip model.","title":"adijif.clocks.hmc7044"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044","text":"HMC7044 clock chip model. This model currently supports VCXO+PLL2 configurations","title":"hmc7044"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.d","text":"Output dividers. Valid dividers are 1,2,3,4,5,6->(even)->4094 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"d"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.n2","text":"n2: VCO feedback divider. Valid dividers are 8->65536 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"n2"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.r2","text":"VCXO input dividers. Valid dividers are 1->4096 Returns: Type Description Union[int, List[int]] int: Current allowable dividers","title":"r2"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.r2_available","text":"Output dividers","title":"r2_available"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.vxco_doubler","text":"VCXO doubler. Valid dividers are 1,2 Returns: Type Description Union[int, List[int]] int: Current doubler value","title":"vxco_doubler"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.__init__","text":"Initialize HMC7044 clock chip model. Parameters: Name Type Description Default model Union[NoneType, docplex.cp.model.CpoModel] Model to add constraints to None solver str Solver to use. Should be one of \"CPLEX\" or \"gekko\" 'CPLEX' Exceptions: Type Description Exception Invalid solver","title":"__init__()"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.get_config","text":"Extract configurations from solver results. Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration Exceptions: Type Description Exception If solver is not called first","title":"get_config()"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.set_requested_clocks","text":"Define necessary clocks to be generated in model. Parameters: Name Type Description Default vcxo int VCXO frequency in hertz required out_freqs List list of required clocks to be output required clk_names List[str] list of strings of clock names required Exceptions: Type Description Exception If len(out_freqs) != len(clk_names)","title":"set_requested_clocks()"},{"location":"devs/converters/","text":"Reference AD9081 high speed MxFE clocking model. ad9081 AD9081 combined transmit and receive model. __init__ ( self , model = None , solver = None ) special Initialize AD9081 clocking model for TX and RX. This is a common class used to handle TX and RX constraints together. Parameters: Name Type Description Default model Union[NoneType, docplex.cp.model.CpoModel] Solver model None solver str Solver name (gekko or CPLEX) None get_required_clock_names ( self ) Get list of strings of names of requested clocks. This list of names is for the clocks defined by get_required_clocks Returns: Type Description List[str] List[str]: List of strings of clock names in order get_required_clocks ( self ) Generate list required clocks. For AD9081 this will contain [converter clock, sysref requirement SOS] Returns: Type Description List List: List of solver variables, equations, and constants Exceptions: Type Description Exception If direct clocking is used. Not yet implemented validate_config ( self ) Validate device configurations including JESD and clocks of both ADC and DAC. This check only is for static configuration that does not include variables which are solved. ad9081_core AD9081 high speed MxFE model. This model supports both direct clock configurations and on-board generation Clocking: AD9081 can internally generate or leverage external clocks. The high speed clock within the system is referred to as the DAC clock and the ADC clock will be a divided down version of the clock: adc_clock == dac_clock / L, where L = 1,2,3,4 For internal generation, the DAC clock is generated through an integer PLL through the following relation: dac_clock == ((m_vco * n_vco) / R * ref_clock) / D For external clocks, the clock must be provided at the DAC clock rate Once we have the DAC clock the data rates can be directly evaluated into each JESD framer: rx_baseband_sample_rate = (dac_clock / L) / datapath_decimation tx_baseband_sample_rate = dac_clock / datapath_interpolation get_config ( self , solution = None ) Extract configurations from solver results. Collect internal converter configuration and output clock definitions leading to connected devices (clock chips, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration get_required_clock_names ( self ) Get list of strings of names of requested clocks. This list of names is for the clocks defined by get_required_clocks Returns: Type Description List[str] List[str]: List of strings of clock names in order get_required_clocks ( self ) Generate list required clocks. For AD9081 this will contain [converter clock, sysref requirement SOS] Returns: Type Description List List: List of solver variables, equations, and constants Exceptions: Type Description Exception If direct clocking is used. Not yet implemented ad9081_rx AD9081 Receive model. __init__ ( self , model = None , solver = None ) special Initialize AD9081 clocking model for RX. This is a common class used to handle RX constraints together. Parameters: Name Type Description Default model Union[NoneType, docplex.cp.model.CpoModel] Solver model None solver str Solver name (gekko or CPLEX) None ad9081_tx AD9081 Transmit model. __init__ ( self , model = None , solver = None ) special Initialize AD9081 clocking model for TX. This is a common class used to handle TX constraints together. Parameters: Name Type Description Default model Union[NoneType, docplex.cp.model.CpoModel] Solver model None solver str Solver name (gekko or CPLEX) None AD9680 high speed ADC clocking model. ad9680 AD9680 high speed ADC model. This model supports direct clock configurations Clocking: AD9680 has directly clocked ADC that have optional input dividers. The sample rate can be determined as follows: baseband_sample_rate = (input_clock / input_clock_divider) / datapath_decimation input_clock_max Clocking AD9680 has directly clocked ADCs that have optional input dividers. The sample rate can be determined as follows: baseband_sample_rate = (input_clock / input_clock_divider) / datapath_decimation __init__ ( self , * args : Any , ** kwargs : Any ) -> None special Initialize AD9680 class. Objects will default to mode 0x88 with 1e9 sample_clock. Parameters: Name Type Description Default *args Any Pass through arguments () **kwargs Any Pass through keyword arguments {} get_config ( self , solution : CpoSolveResult = None ) -> Dict Extract configurations from solver results. Collect internal converter configuration and output clock definitions leading to connected devices (clock chips, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration get_required_clock_names ( self ) -> List [ str ] Get list of strings of names of requested clocks. This list of names is for the clocks defined by get_required_clocks Returns: Type Description List[str] List[str]: List of strings of clock names in order get_required_clocks ( self ) -> List Generate list required clocks. For AD9680 this will contain [converter clock, sysref requirement SOS] Returns: Type Description List List: List of solver variables, equations, and constants AD9144 high speed DAC clocking model. ad9144 AD9144 high speed DAC model. This model supports both direct clock configurations and on-board generation Clocking: AD9144 has directly clocked DAC that have optional input dividers. The sample rate can be determined as follows: baseband_sample_rate = (input_clock / input_clock_divider) / datapath_decimation get_config ( self , solution = None ) Extract configurations from solver results. Collect internal converter configuration and output clock definitions leading to connected devices (clock chips, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration get_required_clock_names ( self ) Get list of strings of names of requested clocks. This list of names is for the clocks defined by get_required_clocks Returns: Type Description List[str] List[str]: List of strings of clock names in order get_required_clocks ( self ) Generate list required clocks. For AD9144 this will contain [converter clock, sysref requirement SOS] Returns: Type Description List List: List of dictionaries of solver components ADRV9009 transceiver clocking model. adrv9009 ADRV9009 combined transmit and receive model. __init__ ( self , model = None , solver = None ) special Initialize ADRV9009 clocking model for TX and RX. This is a common class used to handle TX and RX constraints together. Parameters: Name Type Description Default model Union[NoneType, docplex.cp.model.CpoModel] Solver model None solver str Solver name (gekko or CPLEX) None get_required_clocks ( self ) Generate list of required clocks. For ADRV9009 this will contain: [device clock requirement SOS, sysref requirement SOS] Returns: Type Description List[Dict] list[dict]: List of dictionaries of solver variables, equations, and constants Exceptions: Type Description Exception Invalid relation of rates between RX and TX AssertionError Gekko called adrv9009_clock_common ADRV9009 class managing common singleton (Rx,Tx) methods. get_config ( self , solution = None ) Extract configurations from solver results. Collect internal converter configuration and output clock definitions leading to connected devices (clock chips, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration get_required_clock_names ( self ) Get list of strings of names of requested clocks. This list of names is for the clocks defined by get_required_clocks Returns: Type Description List[str] List[str]: List of strings of clock names mapped by get_required_clocks get_required_clocks ( self ) Generate list of required clocks. For ADRV9009 this will contain: [device clock requirement SOS, sysref requirement SOS] Returns: Type Description List[Dict] list[dict]: List of dictionaries of solver variables, equations, and constants adrv9009_core ADRV9009 transceiver clocking model. This model manage the JESD configuration and input clock constraints. External LO constraints are not modeled. Clocking: ADRV9009 uses onboard PLLs to generate the JESD clocks Lane Rate = I/Q Sample Rate * M * Np * (10 / 8) / L Lane Rate = sample_clock * M * Np * (10 / 8) / L adrv9009_rx ADRV9009 Receive model. adrv9009_tx ADRV9009 Transmit model.","title":"Data Converters"},{"location":"devs/converters/#reference","text":"","title":"Reference"},{"location":"devs/converters/#adijif.converters.ad9081","text":"AD9081 high speed MxFE clocking model.","title":"adijif.converters.ad9081"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081","text":"AD9081 combined transmit and receive model.","title":"ad9081"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081.__init__","text":"Initialize AD9081 clocking model for TX and RX. This is a common class used to handle TX and RX constraints together. Parameters: Name Type Description Default model Union[NoneType, docplex.cp.model.CpoModel] Solver model None solver str Solver name (gekko or CPLEX) None","title":"__init__()"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081.get_required_clock_names","text":"Get list of strings of names of requested clocks. This list of names is for the clocks defined by get_required_clocks Returns: Type Description List[str] List[str]: List of strings of clock names in order","title":"get_required_clock_names()"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081.get_required_clocks","text":"Generate list required clocks. For AD9081 this will contain [converter clock, sysref requirement SOS] Returns: Type Description List List: List of solver variables, equations, and constants Exceptions: Type Description Exception If direct clocking is used. Not yet implemented","title":"get_required_clocks()"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081.validate_config","text":"Validate device configurations including JESD and clocks of both ADC and DAC. This check only is for static configuration that does not include variables which are solved.","title":"validate_config()"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_core","text":"AD9081 high speed MxFE model. This model supports both direct clock configurations and on-board generation Clocking: AD9081 can internally generate or leverage external clocks. The high speed clock within the system is referred to as the DAC clock and the ADC clock will be a divided down version of the clock: adc_clock == dac_clock / L, where L = 1,2,3,4 For internal generation, the DAC clock is generated through an integer PLL through the following relation: dac_clock == ((m_vco * n_vco) / R * ref_clock) / D For external clocks, the clock must be provided at the DAC clock rate Once we have the DAC clock the data rates can be directly evaluated into each JESD framer: rx_baseband_sample_rate = (dac_clock / L) / datapath_decimation tx_baseband_sample_rate = dac_clock / datapath_interpolation","title":"ad9081_core"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_core.get_config","text":"Extract configurations from solver results. Collect internal converter configuration and output clock definitions leading to connected devices (clock chips, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration","title":"get_config()"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_core.get_required_clock_names","text":"Get list of strings of names of requested clocks. This list of names is for the clocks defined by get_required_clocks Returns: Type Description List[str] List[str]: List of strings of clock names in order","title":"get_required_clock_names()"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_core.get_required_clocks","text":"Generate list required clocks. For AD9081 this will contain [converter clock, sysref requirement SOS] Returns: Type Description List List: List of solver variables, equations, and constants Exceptions: Type Description Exception If direct clocking is used. Not yet implemented","title":"get_required_clocks()"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_rx","text":"AD9081 Receive model.","title":"ad9081_rx"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_rx.__init__","text":"Initialize AD9081 clocking model for RX. This is a common class used to handle RX constraints together. Parameters: Name Type Description Default model Union[NoneType, docplex.cp.model.CpoModel] Solver model None solver str Solver name (gekko or CPLEX) None","title":"__init__()"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_tx","text":"AD9081 Transmit model.","title":"ad9081_tx"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_tx.__init__","text":"Initialize AD9081 clocking model for TX. This is a common class used to handle TX constraints together. Parameters: Name Type Description Default model Union[NoneType, docplex.cp.model.CpoModel] Solver model None solver str Solver name (gekko or CPLEX) None","title":"__init__()"},{"location":"devs/converters/#adijif.converters.ad9680","text":"AD9680 high speed ADC clocking model.","title":"adijif.converters.ad9680"},{"location":"devs/converters/#adijif.converters.ad9680.ad9680","text":"AD9680 high speed ADC model. This model supports direct clock configurations Clocking: AD9680 has directly clocked ADC that have optional input dividers. The sample rate can be determined as follows: baseband_sample_rate = (input_clock / input_clock_divider) / datapath_decimation","title":"ad9680"},{"location":"devs/converters/#adijif.converters.ad9680.ad9680.input_clock_max","text":"Clocking AD9680 has directly clocked ADCs that have optional input dividers. The sample rate can be determined as follows: baseband_sample_rate = (input_clock / input_clock_divider) / datapath_decimation","title":"input_clock_max"},{"location":"devs/converters/#adijif.converters.ad9680.ad9680.__init__","text":"Initialize AD9680 class. Objects will default to mode 0x88 with 1e9 sample_clock. Parameters: Name Type Description Default *args Any Pass through arguments () **kwargs Any Pass through keyword arguments {}","title":"__init__()"},{"location":"devs/converters/#adijif.converters.ad9680.ad9680.get_config","text":"Extract configurations from solver results. Collect internal converter configuration and output clock definitions leading to connected devices (clock chips, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration","title":"get_config()"},{"location":"devs/converters/#adijif.converters.ad9680.ad9680.get_required_clock_names","text":"Get list of strings of names of requested clocks. This list of names is for the clocks defined by get_required_clocks Returns: Type Description List[str] List[str]: List of strings of clock names in order","title":"get_required_clock_names()"},{"location":"devs/converters/#adijif.converters.ad9680.ad9680.get_required_clocks","text":"Generate list required clocks. For AD9680 this will contain [converter clock, sysref requirement SOS] Returns: Type Description List List: List of solver variables, equations, and constants","title":"get_required_clocks()"},{"location":"devs/converters/#adijif.converters.ad9144","text":"AD9144 high speed DAC clocking model.","title":"adijif.converters.ad9144"},{"location":"devs/converters/#adijif.converters.ad9144.ad9144","text":"AD9144 high speed DAC model. This model supports both direct clock configurations and on-board generation Clocking: AD9144 has directly clocked DAC that have optional input dividers. The sample rate can be determined as follows: baseband_sample_rate = (input_clock / input_clock_divider) / datapath_decimation","title":"ad9144"},{"location":"devs/converters/#adijif.converters.ad9144.ad9144.get_config","text":"Extract configurations from solver results. Collect internal converter configuration and output clock definitions leading to connected devices (clock chips, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration","title":"get_config()"},{"location":"devs/converters/#adijif.converters.ad9144.ad9144.get_required_clock_names","text":"Get list of strings of names of requested clocks. This list of names is for the clocks defined by get_required_clocks Returns: Type Description List[str] List[str]: List of strings of clock names in order","title":"get_required_clock_names()"},{"location":"devs/converters/#adijif.converters.ad9144.ad9144.get_required_clocks","text":"Generate list required clocks. For AD9144 this will contain [converter clock, sysref requirement SOS] Returns: Type Description List List: List of dictionaries of solver components","title":"get_required_clocks()"},{"location":"devs/converters/#adijif.converters.adrv9009","text":"ADRV9009 transceiver clocking model.","title":"adijif.converters.adrv9009"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009","text":"ADRV9009 combined transmit and receive model.","title":"adrv9009"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009.__init__","text":"Initialize ADRV9009 clocking model for TX and RX. This is a common class used to handle TX and RX constraints together. Parameters: Name Type Description Default model Union[NoneType, docplex.cp.model.CpoModel] Solver model None solver str Solver name (gekko or CPLEX) None","title":"__init__()"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009.get_required_clocks","text":"Generate list of required clocks. For ADRV9009 this will contain: [device clock requirement SOS, sysref requirement SOS] Returns: Type Description List[Dict] list[dict]: List of dictionaries of solver variables, equations, and constants Exceptions: Type Description Exception Invalid relation of rates between RX and TX AssertionError Gekko called","title":"get_required_clocks()"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_clock_common","text":"ADRV9009 class managing common singleton (Rx,Tx) methods.","title":"adrv9009_clock_common"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_clock_common.get_config","text":"Extract configurations from solver results. Collect internal converter configuration and output clock definitions leading to connected devices (clock chips, FPGAs) Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of clocking rates and dividers for configuration","title":"get_config()"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_clock_common.get_required_clock_names","text":"Get list of strings of names of requested clocks. This list of names is for the clocks defined by get_required_clocks Returns: Type Description List[str] List[str]: List of strings of clock names mapped by get_required_clocks","title":"get_required_clock_names()"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_clock_common.get_required_clocks","text":"Generate list of required clocks. For ADRV9009 this will contain: [device clock requirement SOS, sysref requirement SOS] Returns: Type Description List[Dict] list[dict]: List of dictionaries of solver variables, equations, and constants","title":"get_required_clocks()"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_core","text":"ADRV9009 transceiver clocking model. This model manage the JESD configuration and input clock constraints. External LO constraints are not modeled. Clocking: ADRV9009 uses onboard PLLs to generate the JESD clocks Lane Rate = I/Q Sample Rate * M * Np * (10 / 8) / L Lane Rate = sample_clock * M * Np * (10 / 8) / L","title":"adrv9009_core"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_rx","text":"ADRV9009 Receive model.","title":"adrv9009_rx"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_tx","text":"ADRV9009 Transmit model.","title":"adrv9009_tx"},{"location":"devs/jesd/","text":"Reference JESD parameterization definitions and helper functions. jesd JESD interface class to manage JESD notations and definitions. available_jesd_modes : List [ str ] property readonly Available JESD modes supported by device. Must be a list of strings Exceptions: Type Description NotImplementedError If child classes do not implement method/property bit_clock : Union [ int , float ] property writable bit_clock: aka line rate aka lane rate. bit_clock == (M * S * Np * encoding_d/encoding_n * frame_clock) / L Returns: Type Description Union[int, float] int: Bits per second aka lane rate bit_clock_max : Union [ int , float ] property readonly Get bit clock (lane rate) maximum based on JESD mode. Returns: Type Description Union[int, float] int: bit clock in bits per second bit_clock_min : Union [ int , float ] property readonly Get bit clock (lane rate) minimum based on JESD mode. Returns: Type Description Union[int, float] int: bit clock in bits per second CF : Union [ int , float ] property writable Get Control words per frame clock period per link. Returns: Type Description Union[int, float] int: Control words per frame clock period per link CS : Union [ int , float ] property writable Get Control bits per conversion sample. Returns: Type Description Union[int, float] int: Control bits per conversion sample D : Union [ int , float ] property readonly FIXME. data_path_width : Union [ int , float ] property writable Get JESD data path width in bits. Current options are: 32 (204B) and 64 (204C) Returns: Type Description Union[int, float] int: Numerator of link encoding. device_clock : Union [ int , float ] property readonly device_clock is the lane rate over D. device_clock == bit_clock / D Returns: Type Description Union[int, float] int: bits per second per device encoding : str property writable Get JESD FEC encoding. Current options are: \"8b10b\", \"64b66b\" Returns: Type Description str str: String of supported encodings. encoding_d : Union [ int , float ] property readonly Get JESD FEC encoding denominator. Current options are: 10 or 66 Returns: Type Description Union[int, float] int: Denominator of link encoding. encoding_n : Union [ int , float ] property readonly Get JESD FEC encoding numerator. Current options are: 8 or 64 Returns: Type Description Union[int, float] int: Numerator of link encoding. F : Union [ int , float ] property writable Get octets per frame per link. Generally a power of 2 Returns: Type Description Union[int, float] int: Number of octets per frame per link F_available : List [ int ] property readonly Allowable F settings for device. Must be a list ints Exceptions: Type Description NotImplementedError If child classes do not implement method/property frame_clock : Union [ int , float ] property readonly frame_clock in frames per second. frame_clock == sample_clock / S Returns: Type Description Union[int, float] int: Data rate in samples per second HD : Union [ int , float ] property writable Get High density mode. Returns: Type Description Union[int, float] int: High density mode jesd_class : Union [ str , List [ str ]] property writable Get JESD selected mode. Wil be either jesd204b or jesd204c. K : Union [ int , float ] property writable Get Frames per multiframe. 17/F <= K <= 32, is generally a multiple of 2 Returns: Type Description Union[int, float] int: Number of frames per multiframe K_available : List [ int ] property readonly Allowable K settings for device. Must be a list ints Exceptions: Type Description NotImplementedError If child classes do not implement method/property L : Union [ int , float ] property writable Get lanes per link. Generally a multiple of 2 Returns: Type Description Union[int, float] int: Number of frames per multiframe L_available : List [ int ] property readonly Allowable L settings for device. Must be a list ints Exceptions: Type Description NotImplementedError If child classes do not implement method/property M : Union [ int , float ] property writable Get number of virtual converters. Generally a power of 2 Returns: Type Description Union[int, float] int: Number of frames per multiframe M_available : List [ int ] property readonly Allowable M settings for device. Must be a list ints Exceptions: Type Description NotImplementedError If child classes do not implement method/property multiframe_clock : Union [ int , float ] property readonly multiframe_clock: aka LMFC in frames per multiframe. multiframe_clock == frame_clock / K Returns: Type Description Union[int, float] int: Frames per multiframe N : Union [ int , float ] property writable Get number of non-dummy bits per sample. Generally a multiple of 2 Returns: Type Description Union[int, float] int: Number of non-dummy bits per sample N_available : List [ int ] property readonly Allowable N settings for device. Must be a list ints Exceptions: Type Description NotImplementedError If child classes do not implement method/property Np : Union [ int , float ] property writable Get number of bits per sample. Generally a multiple of 2 Returns: Type Description Union[int, float] int: Number of bits per sample Np_available : List [ int ] property readonly Allowable Np settings for device. Must be a list ints Exceptions: Type Description NotImplementedError If child classes do not implement method/property S : Union [ int , float ] property writable Get Samples per converter per frame. S == F/(M*Np) * encoding_p * L Returns: Type Description Union[int, float] int: Samples per converter per frame sample_clock : Union [ int , float ] property writable Data rate after decimation stages in Samples/second. Returns: Type Description Union[int, float] int: Data rate in samples per second __init__ ( self , sample_clock : int , M : int , L : int , Np : int , K : int ) -> None special Initialize JESD device through link parameterization. Parameters: Name Type Description Default sample_clock int Human readable string describing the exception. required M int Number of virtual converters required L int Number of lanes required Np int Number of bits per sample required K int Frames per multiframe required get_jesd_config ( self , solution : CpoSolveResult = None ) -> Dict Extract configurations from solver results. Collect JESD related parameters, includes modes and clocks. Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of JESD parameters validate_clocks ( self ) -> None Validate all clocks clock settings are within range.","title":"JESD"},{"location":"devs/jesd/#reference","text":"","title":"Reference"},{"location":"devs/jesd/#adijif.jesd","text":"JESD parameterization definitions and helper functions.","title":"adijif.jesd"},{"location":"devs/jesd/#adijif.jesd.jesd","text":"JESD interface class to manage JESD notations and definitions.","title":"jesd"},{"location":"devs/jesd/#adijif.jesd.jesd.available_jesd_modes","text":"Available JESD modes supported by device. Must be a list of strings Exceptions: Type Description NotImplementedError If child classes do not implement method/property","title":"available_jesd_modes"},{"location":"devs/jesd/#adijif.jesd.jesd.bit_clock","text":"bit_clock: aka line rate aka lane rate. bit_clock == (M * S * Np * encoding_d/encoding_n * frame_clock) / L Returns: Type Description Union[int, float] int: Bits per second aka lane rate","title":"bit_clock"},{"location":"devs/jesd/#adijif.jesd.jesd.bit_clock_max","text":"Get bit clock (lane rate) maximum based on JESD mode. Returns: Type Description Union[int, float] int: bit clock in bits per second","title":"bit_clock_max"},{"location":"devs/jesd/#adijif.jesd.jesd.bit_clock_min","text":"Get bit clock (lane rate) minimum based on JESD mode. Returns: Type Description Union[int, float] int: bit clock in bits per second","title":"bit_clock_min"},{"location":"devs/jesd/#adijif.jesd.jesd.CF","text":"Get Control words per frame clock period per link. Returns: Type Description Union[int, float] int: Control words per frame clock period per link","title":"CF"},{"location":"devs/jesd/#adijif.jesd.jesd.CS","text":"Get Control bits per conversion sample. Returns: Type Description Union[int, float] int: Control bits per conversion sample","title":"CS"},{"location":"devs/jesd/#adijif.jesd.jesd.D","text":"FIXME.","title":"D"},{"location":"devs/jesd/#adijif.jesd.jesd.data_path_width","text":"Get JESD data path width in bits. Current options are: 32 (204B) and 64 (204C) Returns: Type Description Union[int, float] int: Numerator of link encoding.","title":"data_path_width"},{"location":"devs/jesd/#adijif.jesd.jesd.device_clock","text":"device_clock is the lane rate over D. device_clock == bit_clock / D Returns: Type Description Union[int, float] int: bits per second per device","title":"device_clock"},{"location":"devs/jesd/#adijif.jesd.jesd.encoding","text":"Get JESD FEC encoding. Current options are: \"8b10b\", \"64b66b\" Returns: Type Description str str: String of supported encodings.","title":"encoding"},{"location":"devs/jesd/#adijif.jesd.jesd.encoding_d","text":"Get JESD FEC encoding denominator. Current options are: 10 or 66 Returns: Type Description Union[int, float] int: Denominator of link encoding.","title":"encoding_d"},{"location":"devs/jesd/#adijif.jesd.jesd.encoding_n","text":"Get JESD FEC encoding numerator. Current options are: 8 or 64 Returns: Type Description Union[int, float] int: Numerator of link encoding.","title":"encoding_n"},{"location":"devs/jesd/#adijif.jesd.jesd.F","text":"Get octets per frame per link. Generally a power of 2 Returns: Type Description Union[int, float] int: Number of octets per frame per link","title":"F"},{"location":"devs/jesd/#adijif.jesd.jesd.F_available","text":"Allowable F settings for device. Must be a list ints Exceptions: Type Description NotImplementedError If child classes do not implement method/property","title":"F_available"},{"location":"devs/jesd/#adijif.jesd.jesd.frame_clock","text":"frame_clock in frames per second. frame_clock == sample_clock / S Returns: Type Description Union[int, float] int: Data rate in samples per second","title":"frame_clock"},{"location":"devs/jesd/#adijif.jesd.jesd.HD","text":"Get High density mode. Returns: Type Description Union[int, float] int: High density mode","title":"HD"},{"location":"devs/jesd/#adijif.jesd.jesd.jesd_class","text":"Get JESD selected mode. Wil be either jesd204b or jesd204c.","title":"jesd_class"},{"location":"devs/jesd/#adijif.jesd.jesd.K","text":"Get Frames per multiframe. 17/F <= K <= 32, is generally a multiple of 2 Returns: Type Description Union[int, float] int: Number of frames per multiframe","title":"K"},{"location":"devs/jesd/#adijif.jesd.jesd.K_available","text":"Allowable K settings for device. Must be a list ints Exceptions: Type Description NotImplementedError If child classes do not implement method/property","title":"K_available"},{"location":"devs/jesd/#adijif.jesd.jesd.L","text":"Get lanes per link. Generally a multiple of 2 Returns: Type Description Union[int, float] int: Number of frames per multiframe","title":"L"},{"location":"devs/jesd/#adijif.jesd.jesd.L_available","text":"Allowable L settings for device. Must be a list ints Exceptions: Type Description NotImplementedError If child classes do not implement method/property","title":"L_available"},{"location":"devs/jesd/#adijif.jesd.jesd.M","text":"Get number of virtual converters. Generally a power of 2 Returns: Type Description Union[int, float] int: Number of frames per multiframe","title":"M"},{"location":"devs/jesd/#adijif.jesd.jesd.M_available","text":"Allowable M settings for device. Must be a list ints Exceptions: Type Description NotImplementedError If child classes do not implement method/property","title":"M_available"},{"location":"devs/jesd/#adijif.jesd.jesd.multiframe_clock","text":"multiframe_clock: aka LMFC in frames per multiframe. multiframe_clock == frame_clock / K Returns: Type Description Union[int, float] int: Frames per multiframe","title":"multiframe_clock"},{"location":"devs/jesd/#adijif.jesd.jesd.N","text":"Get number of non-dummy bits per sample. Generally a multiple of 2 Returns: Type Description Union[int, float] int: Number of non-dummy bits per sample","title":"N"},{"location":"devs/jesd/#adijif.jesd.jesd.N_available","text":"Allowable N settings for device. Must be a list ints Exceptions: Type Description NotImplementedError If child classes do not implement method/property","title":"N_available"},{"location":"devs/jesd/#adijif.jesd.jesd.Np","text":"Get number of bits per sample. Generally a multiple of 2 Returns: Type Description Union[int, float] int: Number of bits per sample","title":"Np"},{"location":"devs/jesd/#adijif.jesd.jesd.Np_available","text":"Allowable Np settings for device. Must be a list ints Exceptions: Type Description NotImplementedError If child classes do not implement method/property","title":"Np_available"},{"location":"devs/jesd/#adijif.jesd.jesd.S","text":"Get Samples per converter per frame. S == F/(M*Np) * encoding_p * L Returns: Type Description Union[int, float] int: Samples per converter per frame","title":"S"},{"location":"devs/jesd/#adijif.jesd.jesd.sample_clock","text":"Data rate after decimation stages in Samples/second. Returns: Type Description Union[int, float] int: Data rate in samples per second","title":"sample_clock"},{"location":"devs/jesd/#adijif.jesd.jesd.__init__","text":"Initialize JESD device through link parameterization. Parameters: Name Type Description Default sample_clock int Human readable string describing the exception. required M int Number of virtual converters required L int Number of lanes required Np int Number of bits per sample required K int Frames per multiframe required","title":"__init__()"},{"location":"devs/jesd/#adijif.jesd.jesd.get_jesd_config","text":"Extract configurations from solver results. Collect JESD related parameters, includes modes and clocks. Parameters: Name Type Description Default solution CpoSolveResult CPlex solution. Only needed for CPlex solver None Returns: Type Description Dict Dict: Dictionary of JESD parameters","title":"get_jesd_config()"},{"location":"devs/jesd/#adijif.jesd.jesd.validate_clocks","text":"Validate all clocks clock settings are within range.","title":"validate_clocks()"}]}