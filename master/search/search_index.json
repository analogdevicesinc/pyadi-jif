{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyadi-jif: Python interface for the ADI JESD Interface Framework","text":"<p>This project tries to simplify JESD204 configuration exploration and validation for ADI JESD based converters and clock chips with different FPGA vendors.</p> <p> </p> <p> </p> <p>Now supporting the AD9081 MxFE</p> <p> </p>"},{"location":"clocks/","title":"Clock chips","text":"<p>Clock chip models are the central components of the pyadi-jif library and govern the majority of most configuration limitations. Since clock chips are responsible for providing all the necessary clocks for the different components they must understand all component clock requirements.</p>"},{"location":"clocks/#theory-of-operation","title":"Theory of operation","text":"<p>In traditional systems clock chips work as frequency generation systems with multiple PLLs. One PLL, typically called PLL1, is used for synchronization and jitter cleanup. The second PLL, typically called PLL2, is used for frequency generation from a VCXO or PLL1 and will be divided down to provide different output frequencies. The current clock chip models only model PLL2 with a VCXO source.</p> <p> </p>"},{"location":"clocks/#standalone-usage","title":"Standalone usage","text":"<p>Clock chip models can be used standalone if the required clocks are known. This requires them to be directly provided. Below is an example of a configuration of a clock chip where the three desired output clocks and VCXO are supplied but the internal dividers need to be determined. The input divider n2 is also constrained to 24 as well. Without applying this constraint, the solver could set n2 to values between 12 and 255.</p> <pre><code># Create instance of AD9523-1 clocking model\nclk = adijif.ad9523_1()\n# Constrain feedback divider n2 to only 24\nclk.n2 = 24\n# Define clock sources and output clocks\nvcxo = 125000000\noutput_clocks = [1e9, 500e6, 7.8125e6]\nclock_names = [\"ADC\", \"FPGA\", \"SYSREF\"]\nclk.set_requested_clocks(vcxo, output_clocks, clock_names)\n# Call solver and collect configuration\nclk.solve()\no = clk.get_config()\npprint.pprint(o)\n</code></pre> <p>Sample Output</p> <pre><code>{'m1': 3.0,\n 'n2': 24,\n 'out_dividers': [1.0, 2.0, 128.0],\n 'output_clocks': {'ADC': {'divider': 1.0, 'rate': 1000000000.0},\n                   'FPGA': {'divider': 2.0, 'rate': 500000000.0},\n                   'SYSREF': {'divider': 128.0, 'rate': 7812500.0}},\n 'r2': 1.0,\n 'vcxo': 125000000.0}\n</code></pre> <p>When using clock chip models standalone the method set_requested_clocks must be called before solve. When using the system class this is automatically handled internally based on the components set at initialization.</p>"},{"location":"converters/","title":"Data converters","text":"<p>Four types of data converters are supported: ADCs, DACs, transceivers, and ADC/DAC combinations. However, fundamentally from a clocking perspective, it does not matter if a component is a DAC or ADC, and integrated parts like transceivers only have more constraints. It is also possible to connect multiple converters into the same system and jointly present these requirements to clock chips and FPGAs also in the system.</p>"},{"location":"converters/#clocking-architectures","title":"Clocking architectures","text":"<p>pyadi-jif supports both direct clocking and on-board PLL generation for different converters. Assuming the desired parts support those features. Usually, an external clock generation source, like a PLL, is used to have better phase noise performance. However, routing faster clocks can be challenging above 10 GHz. If a part does support both options (like the AD9081) the internal solver does not look across both options. One mode must be selected before the solver is called. If both options are available the internal PLL is used by default. This is set through the property use_direct_clocking.</p> <pre><code>sys = adijif.system(\"ad9081_rx\", \"hmc7044\", \"xilinx\", vcxo)\n# Enable internal PLL\nsys.converter.use_direct_clocking = False\n</code></pre> <p>Below is a diagram of the AD9081 internal clock generation PLL. pyadi-jif determines the necessary input clock (CLOCK RECEIVER) and dividers (D,M,N,R,L) for a given data rate specification.</p> <p></p>"},{"location":"converters/#configuring-converters","title":"Configuring converters","text":"<p>Currently converter objects cannot be used outside of the system class when leveraging solvers. Standalone they could be used to evaluate basic JESD parameters and clocks, but you cannot solve for internal dividers standalone. Here is an example below of examining different effective rates based on the JESD configuration:</p> <pre><code>cnv = adijif.ad9680()\ncnv.sample_clock = 1e9\ncnv.decimation = 1\ncnv.L = 4\ncnv.M = 2\ncnv.N = 14\ncnv.Np = 16\ncnv.K = 32\ncnv.F = 1\n\nprint(cnv.bit_clock, cnv.multiframe_clock, cnv.device_clock)\n</code></pre> <pre><code>10000000000.0 31250000.0 250000000.0\n</code></pre>"},{"location":"converters/#nested-converters","title":"Nested converters","text":"<p>For devices with both ADCs and DACs like transceivers or mixed-signal front-ends, nested models are used that model both ADC and DAC paths together. This is important since they can share a common device clock or reference clock but have different JESD link configurations. AD9081) is an example of a part that has such an implementation. AD9081 also has RX or TX only models.</p> <p>When using a nested converter model there are sub-properties adc and dac which handle the individual configurations. When the solver is called the cross configurations are validated first then possible clocking configurations are explored. Below is an example of this type of converter model in use:</p> <pre><code># Set up system model with nested AD9081 model\nsys = adijif.system(\"ad9081\", \"hmc7044\", \"xilinx\", 125000000)\nsys.fpga.setup_by_dev_kit_name(\"zc706\")\n# Use built in PLLs\nsys.converter.dac.use_direct_clocking = False\nsys.converter.adc.use_direct_clocking = False\n# Set DAC clocking requirements\nsys.converter.dac.sample_clock = 250e6\nsys.converter.dac.datapath.cduc_interpolation = 4\nsys.converter.dac.L = 4\nsys.converter.dac.M = 8\nsys.converter.dac.N = 16\nsys.converter.dac.Np = 16\nsys.converter.dac.K = 32\nsys.converter.dac.F = 4\n# Set ADC clocking requirements\nsys.converter.adc.sample_clock = 250e6\nsys.converter.adc.datapath.cddc_decimations = [4]*4\nsys.converter.adc.datapath.fddc_decimations = [4]*8\nsys.converter.adc.datapath.fddc_enabled = [False]*8\nsys.converter.adc.L = 4\nsys.converter.adc.M = 8\nsys.converter.adc.N = 16\nsys.converter.adc.Np = 16\nsys.converter.adc.K = 32\nsys.converter.adc.F = 4\n</code></pre>"},{"location":"converters/#external-pll-clocking","title":"External PLL Clocking","text":"<p>Sometimes it is necessary to use an external PLL to clock a converter which may not necessarily come directly from a clock chip. This is done be inserting a PLL between the clock chip and the converter. The API do insert an external PLL is done through the system class's add_pll_inline method. Below is a basic example with the ADF4371:</p> <pre><code>vcxo = 100e6\nsys = adijif.system(\"ad9081\", \"hmc7044\", \"xilinx\", vcxo, solver=\"CPLEX\")\nsys.fpga.setup_by_dev_kit_name(\"zcu102\")\nsys.converter.clocking_option = \"direct\"\n\nsys.add_pll_inline(\"adf4371\", sys.clock, sys.converter)\n</code></pre> <p>The add_pll_inline method requires a name of a desired PLL, the object of the clock chip, and the object of the target converter you wish to drive with the PLL.</p>"},{"location":"defs/","title":"JESD204 Definitions","text":"<p>To better understand the system as a whole common definitions must be used between converters, clock chips, and FPGAs used within the system. This page will outline the different clocks and standard configuration parameters for JESD204B and JESD204C.</p>"},{"location":"defs/#link-parameters","title":"Link parameters","text":"<p>E : Number of multiblocks in an extended multiblock</p> <p>F : Octets per frame per link</p> <p>HD : High Density User Data Format</p> <p>K : Frames per multiframe</p> <p>L : Number of lanes</p> <p>M : Number of virtual converters</p> <p>N : Number of non-dummy bits per sample. Usually converter resolution.</p> <p>Np : Number of bits per sample</p> <p>S : Samples per converter per frame</p>"},{"location":"defs/#clocks","title":"Clocks","text":"<p>frame_clock : Frames per second $$ \\text{frame clock} = \\frac{\\text{sample clock}}{S} $$. Clock rate at which samples are generated/processed. Has the same rate as the conversion clock, except for interpolating DACs or decimating DACs, where it is slower by the interpolation/decimation factor.</p> <p>sample clock : Data rate in samples per second after decimation stages for ADCs or before interpolation stages for DACs. This is usually referred to as device clock</p> <p>local multi-frame clock (LMFC) : Clock which is equivalent to the link clock counts $$ LMFC = (F \\times K/4) $$</p> <p>system reference (SYSREF) clock : Clock used for synchronization in subclass 1 and subclass 2 configurations for deterministic latency. It is assumed to be aligned with the sample clock from the clock chip but with periods at integer multiples of the device clock.</p> <p>character clock : Clock with which 8b10b characters and octets are generated.</p> <p>conversion clock : Clock used by a converter device to perform the A2D or D2A conversion.</p> <p>device clock : Master clock supplied to the JESD204B device from which all other clock signals must be derived.</p> <p>line clock : Clock for the high-speed serial interface.</p> <p>local clock : A clock generated inside a JESD204B device.</p> <p>All clocks inside a JESD204B system must have a integer relationship</p>"},{"location":"defs/#control-characters","title":"Control characters","text":"<p>/R/ K28.0 : Initial lane alignment sequence multi-frame start.</p> <p>/A/ K28.3 : Lane alignment</p> <p>/Q/ K28.4 : Initial lane alignment sequence configuration marker.</p> <p>/K/ K28.5 : Code group synchronization.</p> <p>/F/ K28.7 : Frame synchronization.</p>"},{"location":"defs/#abbreviations","title":"Abbreviations","text":"<p>CGS : Code Group Synchronization</p> <p>ILAS : Initial Lane Alignment Sequence</p> <p>LMFC : Local Multi Frame Clock</p> <p>LEMC : Local Extended Multiblock Clock</p> <p>MCDA : Multiple Converter Device Alignment</p> <p>NMCDA : No Multiple Converter Device Alignment</p> <p>RBD : RX Buffer Delay</p> <p>EMB : Extended Multiblock</p> <p>EoMB : End-of-multiblock sequence (00001)</p> <p>EoEMB : End of extended multiblock identifier bit</p>"},{"location":"developers/","title":"Developer documentation","text":"<p>pyadi-jif uses a modern python flow based around Nox. This is done to keep development isolated from the rest of developer's system and have consistent testing.</p>"},{"location":"developers/#set-up-python","title":"Set up python","text":"<p>Python 3.8 is required for development as it is considered the target release. Nox tests other variants when available as well but 3.8 is required. If you do not have 3.8 installed the recommended option is to use pyenv</p> <p>Alternatively, using plane older virtualenvs is good option as well. Run the following commands to set up a virtualenv:</p> <pre><code>python3 -m venv venv\n# Linux/macOS\nsource venv/bin/activate\n# Windows\nvenv\\Scripts\\activate.bat\n</code></pre>"},{"location":"developers/#install-pyenv","title":"Install pyenv","text":"<p>pyenv is a handy tool for installing different and isolated versions of python on your system. Since distributions can ship with rather random versions of python, pyenv can help install exactly the versions required. The quick way to install pyenv is with their bash script:</p> <pre><code> curl https://pyenv.run | bash\n</code></pre> <p>Add to your path and shell startup script (like .bashrc or .zshrc)</p> <pre><code> export PATH=\"/home/&lt;username&gt;/.pyenv/bin:$PATH\n eval \"$(pyenv init -)\"\n eval \"$(pyenv virtualenv-init -)\"\n</code></pre> <p>Install the desired python version</p> <pre><code>  pyenv install 3.8.7\n</code></pre>"},{"location":"developers/#set-up-nox","title":"Set up Nox","text":"<p>Nox is a python automation tool that allows you to define reusable tasks in a <code>noxfile.py</code>. It is used to run tests, linters, and other tasks. To install nox:</p> <pre><code>pip install nox\n</code></pre>"},{"location":"developers/#using-make","title":"Using make","text":"<p>Make is muscle memory for most developers so it is a driver of pyadi-jif development if you want to use it. Running <code>make help</code> provides the possible operations. Note that the Makefile wraps most commands in poetry calls so you do not necessarily need to enable the poetry shell.</p> <pre><code>make help\n\nmake[1]: Entering directory '/tmp/pyadi-jif'\nclean                remove all build, test, coverage and Python artifacts\nclean-build          remove build artifacts\nclean-pyc            remove Python file artifacts\nclean-test           remove test and coverage artifacts\ntest                 run tests\ntestp                run tests parallel\ncoverage             run test with coverage enabled\nlint                 format and lint code\ndocs                 build documentation\ninstall              install module\n</code></pre>"},{"location":"developers/#when-committing-code","title":"When committing code","text":"<p>Before committing code and creating pull-requests make sure all tests are passing. CI verifies commits but any assigned reviewers ignore any PRs that have not passed CI checks.</p> <p>Please run the linters:</p> <pre><code>make lint\n</code></pre> <p>and the tests:</p> <pre><code>make test\n</code></pre>"},{"location":"flow/","title":"Usage Flows","text":"<p>pyadi-jif at its core is a modeling tool for configuration and can be used to determine configurations at the component and system levels.</p> <ul> <li>Component level: Certain components can be isolated or used standalone like clock chip models. This is useful when compartmentalizing a problem or checking an existing configuration.</li> <li>System level: When all or most of the top-level constraints need to be modeled together leveraging the system classes provides the most consistent connection between the constraints across the components that must work together.</li> </ul>"},{"location":"flow/#component-level","title":"Component Level","text":"<p>When working at the component level each component's settings can be constrained or left unconstrained. Since each class's implementation will model possible settings as well as their limitations, any user-applied constraints are checked for validity. By default, all settings are left unconstrained. Constraints for divider settings and clocks can be scalars, lists, or even ranges. This applies to dividers and clock rates.</p> <p>Below is an example of a configuration of a clock chip where the three desired output clocks and VCXO are supplied but the internal dividers need to be determined. The input divider n2 is also constrained to 24 as well. Without applying this constraint, the solver could set n2 to values between 12 and 255.</p>"},{"location":"flow/#ad9523-1-component-example","title":"AD9523-1 Component Example","text":"<pre><code># Create instance of AD9523-1 clocking model\nclk = adijif.ad9523_1()\n# Constrain feedback divider n2 to only 24\nclk.n2 = 24\n# Define clock sources and output clocks\nvcxo = 125000000\noutput_clocks = [1e9, 500e6, 7.8125e6]\nclock_names = [\"ADC\", \"FPGA\", \"SYSREF\"]\nclk.set_requested_clocks(vcxo, output_clocks, clock_names)\n# Call solver and collect configuration\nclk.solve()\no = clk.get_config()\npprint.pprint(o)\n</code></pre> <p>Sample Output</p> <pre><code>{'m1': 3.0,\n 'n2': 24,\n 'out_dividers': [1.0, 2.0, 128.0],\n 'output_clocks': {'ADC': {'divider': 1.0, 'rate': 1000000000.0},\n                   'FPGA': {'divider': 2.0, 'rate': 500000000.0},\n                   'SYSREF': {'divider': 128.0, 'rate': 7812500.0}},\n 'r2': 1.0,\n 'vcxo': 125000000.0}\n</code></pre> <p>After the solver runs successfully, all the internal dividers and clocks are provided in a single dictionary.</p> <p>Alternatively a range for the VCXO could be provided using the types classes as:</p> <pre><code>vcxo = adijif.types.range(100000000, 251000000, 1000000, \"vcxo\")\n</code></pre> <p>In this case, any VCXO could be used in the range 100 MHz to 250 MHz in 1 MHz steps.</p>"},{"location":"flow/#system-level","title":"System Level","text":"<p>When component constraints need to be mixed together the system class is used and is designed to support an FPGA, clock chip, and multiple data converters. Below is an example of the system class usage for a board similar to AD-FMCDAQ2-EBZ, but just looking at the ADC side alone.</p>"},{"location":"flow/#ad-fmcdaq2-ebz-adc-side-system-example","title":"AD-FMCDAQ2-EBZ ADC Side System Example","text":"<pre><code>vcxo = 125000000\n# Create instance of system class with desired parts\nsys = adijif.system(\"ad9680\", \"ad9523_1\", \"xilinx\", vcxo)\n# Set Converter clocking requirements\nsys.converter.sample_clock = 1e9\nsys.converter.decimation = 1\nsys.converter.L = 4\nsys.converter.M = 2\nsys.converter.N = 14\nsys.converter.Np = 16\nsys.converter.K = 32\nsys.converter.F = 1\n# Set FPGA clocking requirements\nsys.fpga.setup_by_dev_kit_name(\"zc706\")\n# Call solver and collect configuration\nconfig = sys.solve()\npprint.pprint(config)\n</code></pre> <p>Sample Output</p> <pre><code>{'clock': {'m1': 3.0,\n           'n2': 24.0,\n           'out_dividers': [1.0, 32.0, 10.0],\n           'output_clocks': {'ad9680_adc_clock': {'divider': 1.0,\n                                                  'rate': 1000000000.0},\n                             'ad9680_sysref': {'divider': 32.0,\n                                               'rate': 31250000.0},\n                             'fpga_ref': {'divider': 10.0,\n                                          'rate': 100000000.0}},\n           'r2': 1.0,\n           'vcxo': 125000000},\n 'converter': ['AD9680'],\n 'fpga': {'band': 1.0,\n          'd': 1.0,\n          'm': 1.0,\n          'n': 100.0,\n          'qty4_full_rate_enabled': 0.0,\n          'type': 'qpll',\n          'vco': 10000000000.0}}\n</code></pre> <p>The output in this case contains information for all three components. Listing divider settings, certain enabled modes, and clock rates. The ADC is directly clocked so it requires no configuration.</p> <p>Alternatively, the output dividers d could be limited to power of two:</p> <pre><code>sys.clock.d = [2**n for n in range(0,7)]\nconfig = sys.solve()\npprint.pprint(config['clock'])\n</code></pre> <p>Clock output</p> <pre><code>{'m1': 3.0,\n 'n2': 24.0,\n 'out_dividers': [1.0, 32.0, 8.0],\n 'output_clocks': {'ad9680_adc_clock': {'divider': 1.0, 'rate': 1000000000.0},\n                   'ad9680_sysref': {'divider': 32.0, 'rate': 31250000.0},\n                   'fpga_ref': {'divider': 8.0, 'rate': 125000000.0}},\n 'r2': 1.0,\n 'vcxo': 125000000}\n</code></pre>"},{"location":"fpga_internal/","title":"FPGA Clocking","text":"<p>JESD204 is a protocol that is made up of layers to manage the different aspects of the data link between the converters and FPGA. On the converter side this is handled for you by the ASIC designer but the FPGA side requires a lot more work. This is heavily managed by the ADI JESD204 Framework, but it still needs to be specifically configured and laid out correctly for a specific use case or set of use cases.</p> <p></p> <p>From the diagram above, we can see in the FPGA there are explicit cores within the FPGA to manager the PHY Layer, Link Layer, and Transport Layer aspects for the JESD204 protocol. These will have specific drivers and HDL IP that need to configured for a configuration. By configuration, it primarily refers to the clocking and JESD modes. In the diagram there are both TX and RX data paths but generically they can be considered identical, data will just flow in a specific direction in each case.</p>"},{"location":"fpga_internal/#clocking-layout","title":"Clocking Layout","text":"<p>Focusing on an individual chain, we can consider the diagram below where the individual clocks are detailed. These clocks can be provided externally or internally but must meet some basic requirements. Traditionally they will come from an external clocking devices, which can drastically save power and resources, and adijif takes this approach.</p> <p></p> <p>The clocks will have the following constraints:</p> <ul> <li>ref clock: This clock's primary purpose is to drive the SERDES which will typically happen by feeding the CPLL or QPLL inside the transceiver primitives of the FPGA. Therefore, it's frequency is determined base on the PLL dividers and range limitations. The constraint here is that the ref clock times the PLL multiply/divide ratio must meet the lane rate of the desired link, which is fixed.</li> <li>link clock: This clock must be lane rate /40 (204B) or lane rate /66 (204C). It most cases the ref clock and the link clock will be the same value, or the ref clock is just selected to be equal to the link clock from the start for simplicity. However, this is not always possible. Therefore, the FPGA PLL clock dividers and muxes can be used to correctly meet this requirement from an upstream clock. These dividers and muxed are detailed in the diagram below, where RXOUTCLK is itself used to drive the link layer.</li> <li>device clock: This clock is unique since it must be derived from the same source as SYSREF, since it is used to sample SYSREF and be a multiple of the sample clock. The device clock determines the output rate of the link layer, and when this rate is different than the link clock it will enable the Gearbox inside the link layer HDL core. This will occur usually when N' is not 8 or 16, or when F != 1, 2, or 4. It is also important to select this clock with respect to desired data rate constraints for downstream logic since this is the rate application logic must consume data at. This clock will be at the sample clock / N where N is some integer. However, this rate should not exceed the Fmax of the FPGA logic.</li> <li>SYSREF: This clock is simple the system reference and will be lane rate / M where M is a power of 2 and should be large. </li> </ul> <p>Technically, only the device clock is needed by the FPGA and all other clocks (except for SYSREF) could be derived from it. This assumes the necessary ratios are possible by the internal dividers. However, in most cases SYSREF is used for deterministic latency.</p> <p> </p> From Xilinx UG576"},{"location":"fpga_internal/#search-strategy","title":"Search Strategy","text":"<p>There are two main unique cases when selecting the ref clock and device clock: - N' is not 8 or 16, or when F != 1, 2, or 4 - Otherwise</p> <p>In case (1) the ref clock is unlikely to be derived from the device clock. Therefore, two separate clocks need to be provided to the FPGA. Otherwise, only a single clock (ignoring SYSREF) is required. This is the general behavior based on current analysis; however, this is not a hard definition. The internal solver is configured to favor ref clock and device clock to be the same value. When this is not possible it will automatically create a secondary clock from the clock chip to be specifically used as the device clock. The generation of a separate clock for device clock can be forced by setting force_separate_device_clock in the fpga object instantiated in the system object.</p>"},{"location":"fpga_internal/#api-controls","title":"API Controls","text":"<p>To manage the generation of these clocks, APIs are provided in the FPGA specific classes (adijif.fpga.xilinx). These are:</p> <ul> <li>out_clk_select: Control {RX/TX}CLKSEL mux. Options are XCVR_REFCLK, XCVR_REFCLK_DIV2, XCVR_PROGDIV_CLK</li> <li>force_cpll: Force use of CPLL</li> <li>force_qpll: Force use of QPLL</li> <li>force_qpll1: Force use of QPLL1 (only available on GTH and GTY transceivers)</li> <li>force_separate_device_clock: Enable generation of separate device clock. This rate is automatically determined base on Fmax of FPGA when enabled. When False the solver will automatically determine if a separate device clock is needed.</li> </ul> <p>By default adijif will try to determine valid PLL settings and necessary muxing settings to meet the link clock and ref clock requirements. If a separate device clock is needed enable requires_separate_link_layer_out_clock.</p> <p>Below is an example of an explicit request for a separate device clock and since out_clk_select is set to XCVR_REFCLK it will force the ref clock to be equal to the link clock.</p> <pre><code>import adijif\n\nvcxo = 125e6\n\nsys = adijif.system(\"ad9680\", \"ad9523_1\", \"xilinx\", vcxo)\nsys.Debug_Solver = False\n\nsys.fpga.setup_by_dev_kit_name(\"zcu102\")\nsys.fpga.force_cpll = True\nsys.fpga.out_clk_select = \"XCVR_REFCLK\"  # force reference to be core clock rate\nsys.fpga.requires_separate_link_layer_out_clock = True # Get extra clock\n\nsys.converter.use_direct_clocking = True\nsys.converter.set_quick_configuration_mode(0x88)\nassert sys.converter.S == 1\n\n# Limit upper dividers to powers of 2\nsys.clock.d = [int(2 ** i) for i in range(8)]\n\n# Current configuration\nsys.converter.sample_clock = 1e9 / 2\n\ncfg = sys.solve()\n</code></pre> <p>In the output the lines specific to the link layer and mux configuration have been highlighted:</p> <pre><code>{'clock': {'m1': 3,\n           'n2': 24,\n           'out_dividers': [2, 64, 8, 4],\n           'output_clocks': {'AD9680_fpga_link_out_clk': {'divider': 4,\n                                                          'rate': 250000000.0},\n                             'ADC_CLK': {'divider': 2, 'rate': 500000000.0},\n                             'ADC_CLK_FMC': {'divider': 8, 'rate': 125000000.0},\n                             'ADC_SYSREF': {'divider': 64, 'rate': 15625000.0},\n                             'CLKD_ADC_SYSREF': {'divider': 64,\n                                                 'rate': 15625000.0}},\n           'part': 'AD9523-1',\n           'r2': 1,\n           'vco': 1000000000.0,\n           'vcxo': 125000000.0},\n 'converter': [],\n 'converter_AD9680': {'clocking_option': 'direct', 'decimation': 1},\n 'fpga_AD9680': {'d': 1,\n                 'm': 1,\n                 'n1': 4,\n                 'n2': 5,\n                 'out_clk_select': 'XCVR_REF_CLK',\n                 'sys_clk_select': 'XCVR_QPLL1',\n                 'transport_samples_per_clock': 2,\n                 'type': 'cpll',\n                 'vco': 2500000000.0},\n 'jesd_AD9680': {'CS': 0,\n                 'F': 1,\n                 'HD': 1,\n                 'K': 32,\n                 'L': 4,\n                 'M': 2,\n                 'Np': 16,\n                 'S': 1,\n                 'bit_clock': 5000000000.0,\n                 'converter_clock': 500000000.0,\n                 'jesd_class': 'jesd204b',\n                 'jesd_mode': '136',\n                 'multiframe_clock': 15625000.0,\n                 'sample_clock': 500000000.0}}\n</code></pre>"},{"location":"fpga_internal/#per-part-configuration","title":"Per Part Configuration","text":"<p>By default individual FPGA properties will be applies to all signal chains. However, if a specific only wants to be applied to the ADC or DAC side, or ADC1 but not ADC2, this configuration is possible. This is done through dictionary parameterization as following:</p> <pre><code>sys = adijif.system([\"ad9680\", \"ad9144\"], \"ad9523_1\", \"xilinx\", 125e6)\n\nsys.fpga.setup_by_dev_kit_name(\"zcu102\")\nsys.fpga.force_cpll = True\n\nsys.fpga.out_clk_select = {\n    sys.converter[0]: \"XCVR_REFCLK\",\n    sys.converter[1]: \"XCVR_REFCLK_DIV2\",\n}\n\nsys.fpga.requires_separate_link_layer_out_clock = {\n    sys.converter[0]: True,\n    sys.converter[1]: False,\n}\n...\n</code></pre>"},{"location":"fpga_ref/","title":"FPGA Reference APIs","text":"<p>Xilinx FPGA clocking model.</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx","title":"<code>xilinx</code>","text":"<p>               Bases: <code>xilinx_bf</code></p> <p>Xilinx FPGA clocking model.</p> <p>This model captures different limitations of the Xilinx PLLs and interfaces used for JESD.</p> <p>Currently only Zynq 7000 devices have been fully tested.</p> Source code in <code>adijif/fpgas/xilinx.py</code> <pre><code>class xilinx(xilinx_bf):\n    \"\"\"Xilinx FPGA clocking model.\n\n    This model captures different limitations of the Xilinx\n    PLLs and interfaces used for JESD.\n\n    Currently only Zynq 7000 devices have been fully tested.\n    \"\"\"\n\n    favor_cpll_over_qpll = False\n    minimize_fpga_ref_clock = False\n\n    \"\"\"Force generation of separate device clock from the clock chip. In many\n    cases, the ref clock and device clock can be the same.\"\"\"\n    force_separate_device_clock: bool = False\n\n    \"\"\"Constrain reference clock to be specific values. Options:\n    - CORE_CLOCK: Make reference clock the same as the core clock (LR/40 or LR/66)\n    - CORE_CLOCK_DIV2: Make reference clock the same as the core clock divided by 2\n    - Unconstrained: No constraints on reference clock. Simply meet PLL constraints\n    \"\"\"\n    _ref_clock_constraint = \"CORE_CLOCK\"\n\n    max_serdes_lanes = 24\n\n    hdl_core_version = 2.1\n\n    available_speed_grades = [-1, -2, -3]\n    speed_grade = -2\n\n    transceiver_voltage = 800\n\n    ref_clock_min = -1  # Not set\n    ref_clock_max = -1  # Not set\n\n    available_fpga_packages = [\n        \"Unknown\",\n        \"RF\",\n        \"FL\",\n        \"FF\",\n        \"FB\",\n        \"HC\",\n        \"FH\",\n        \"CS\",\n        \"CP\",\n        \"FT\",\n        \"FG\",\n        \"SB\",\n        \"RB\",\n        \"RS\",\n        \"CL\",\n        \"SF\",\n        \"BA\",\n        \"FA\",\n    ]\n    fpga_package = \"FB\"\n\n    available_fpga_families = [\"Unknown\", \"Artix\", \"Kintex\", \"Virtex\", \"Zynq\"]\n    fpga_family = \"Zynq\"\n\n    available_transceiver_types = [\"GTX2\"]\n    transciever_type = \"GTX2\"\n\n    sys_clk_selections = [\n        \"XCVR_CPLL\",\n        \"XCVR_QPLL0\",\n        \"XCVR_QPLL1\",\n    ]\n    sys_clk_select = \"XCVR_QPLL1\"\n\n    _out_clk_selections = [\n        # \"XCVR_OUTCLK_PCS\",\n        # \"XCVR_OUTCLK_PMA\",\n        \"XCVR_REFCLK\",\n        \"XCVR_REFCLK_DIV2\",\n        \"XCVR_PROGDIV_CLK\",\n    ]\n    _out_clk_select = [\n        # \"XCVR_OUTCLK_PCS\",\n        # \"XCVR_OUTCLK_PMA\",\n        \"XCVR_REFCLK\",\n        \"XCVR_REFCLK_DIV2\",\n        \"XCVR_PROGDIV_CLK\",\n    ]\n\n    \"\"\" Force use of QPLL for transceiver source \"\"\"\n    force_qpll = 0\n\n    \"\"\" Force use of QPLL1 for transceiver source (GTH3,GTH4,GTY4)\"\"\"\n    force_qpll1 = 0\n\n    \"\"\" Force use of CPLL for transceiver source \"\"\"\n    force_cpll = 0\n\n    \"\"\" Force all transceiver sources to be from a single PLL quad.\n        This will try to leverage the output dividers of the PLLs\n    \"\"\"\n    force_single_quad_tile = 0\n\n    \"\"\" Request that clock chip generated device clock\n        device clock == LMFC/40\n        NOTE: THIS IS NOT FPGA REF CLOCK\n    \"\"\"\n    request_device_clock = False\n\n    _clock_names: List[str] = []\n\n    \"\"\"When PROGDIV, this will be set to the value of the divider\"\"\"\n    _used_progdiv = {}\n\n    \"\"\"FPGA target Fmax rate use to determine link layer output rate\"\"\"\n    target_Fmax = 250e6\n\n    \"\"\"Require generation of separate clock specifically for link layer\"\"\"\n    requires_separate_link_layer_out_clock = True\n\n    \"\"\"Require generation of separate core clock (LR/40 or LR/66)\"\"\"\n    requires_core_clock_from_device_clock = False\n\n    configs = []  # type: ignore\n\n    @property\n    def ref_clock_constraint(self) -&gt; str:\n        \"\"\"Get reference clock constraint.\n\n        Reference clock constraint can be set to:\n        - CORE_CLOCK: Make reference clock the same as the core clock (LR/40 or LR/66)\n        - CORE_CLOCK_DIV2: Make reference clock the same as the core clock divided by 2\n        - Unconstrained: No constraints on reference clock. Simply meet PLL constraints\n\n        Returns:\n            str: Reference clock constraint.\n        \"\"\"\n        return self._ref_clock_constraint\n\n    @ref_clock_constraint.setter\n    def ref_clock_constraint(self, value: str) -&gt; None:\n        \"\"\"Set reference clock constraint.\n\n        Reference clock constraint can be set to:\n        - CORE_CLOCK: Make reference clock the same as the core clock (LR/40 or LR/66)\n        - CORE_CLOCK_DIV2: Make reference clock the same as the core clock divided by 2\n        - Unconstrained: No constraints on reference clock. Simply meet PLL constraints\n\n        Args:\n            value (str): Reference clock constraint.\n\n        Raises:\n            Exception: Invalid ref_clock_constraint selection.\n        \"\"\"\n        if value not in [\"CORE_CLOCK\", \"CORE_CLOCK_DIV2\", \"Unconstrained\"]:\n            raise Exception(\n                f\"Invalid ref_clock_constraint {value}, \"\n                + \"options are CORE_CLOCK, CORE_CLOCK_DIV2, Unconstrained\"\n            )\n        self._ref_clock_constraint = value\n\n    @property\n    def out_clk_select(self) -&gt; Union[int, float]:\n        \"\"\"Get current PLL clock output mux options for link layer clock.\n\n        Valid options are:\n                \"XCVR_REFCLK\",\n                \"XCVR_REFCLK_DIV2\",\n                \"XCVR_PROGDIV_CLK\"\n        If a list of these is provided, the solver will determine one to use\n\n        Returns:\n            str,list(str): Mux selection for link layer clock.\n        \"\"\"\n        return self._out_clk_select\n\n    @out_clk_select.setter\n    def out_clk_select(self, value: Union[str, List[str]]) -&gt; None:\n        \"\"\"Set current PLL clock output mux options for link layer clock.\n\n        Valid options are:\n                \"XCVR_REFCLK\",\n                \"XCVR_REFCLK_DIV2\",\n                \"XCVR_PROGDIV_CLK\"\n        If a list of these is provided, the solver will determine one to use\n\n        Args:\n            value (str,List[str]): Mux selection for link layer clock.\n\n        Raises:\n            Exception: Invalid out_clk_select selection.\n        \"\"\"\n        if isinstance(value, list):\n            for item in value:\n                if item not in self._out_clk_selections:\n                    raise Exception(\n                        f\"Invalid out_clk_select {item}, \"\n                        + f\"options are {self._out_clk_selections}\"\n                    )\n        elif isinstance(value, dict):\n            for converter in value:\n                if not isinstance(converter, conv):\n                    raise Exception(\"Keys of out_clk_select but be of type converter\")\n                if value[converter] not in self._out_clk_selections:\n                    raise Exception(\n                        f\"Invalid out_clk_select {value[converter]}, \"\n                        + f\"options are {self._out_clk_selections}\"\n                    )\n        elif value not in self._out_clk_selections:  # str\n            raise Exception(\n                f\"Invalid out_clk_select {value}, \"\n                + f\"options are {self._out_clk_selections}\"\n            )\n\n        self._out_clk_select = value\n\n    @property\n    def _ref_clock_max(self) -&gt; int:\n        \"\"\"Get maximum reference clock for config.\n\n        Returns:\n            int: Rate in samples per second.\n\n        Raises:\n            Exception: Unsupported transceiver type configured.\n        \"\"\"\n        # https://www.xilinx.com/support/documentation/data_sheets/ds191-XC7Z030-XC7Z045-data-sheet.pdf # noqa: B950\n        if self.transciever_type == \"GTX2\":\n            if self.speed_grade == \"-3E\":\n                return 700000000\n            else:\n                return 670000000\n        else:\n            raise Exception(\n                f\"Unknown ref_clock_max for transceiver type {self.transciever_type}\"\n            )\n            # raise Exception(f\"Unknown transceiver type {self.transciever_type}\")\n\n    @property\n    def _ref_clock_min(self) -&gt; int:\n        \"\"\"Get minimum reference clock for config.\n\n        Returns:\n            int: Rate in samples per second.\n\n        Raises:\n            Exception: Unsupported transceiver type configured.\n        \"\"\"\n        # https://www.xilinx.com/support/documentation/data_sheets/ds191-XC7Z030-XC7Z045-data-sheet.pdf # noqa: B950\n        if self.transciever_type == \"GTX2\":\n            return 60000000\n        else:\n            raise Exception(\n                f\"Unknown ref_clock_min for transceiver type {self.transciever_type}\"\n            )\n            # raise Exception(f\"Unknown transceiver type {self.transciever_type}\")\n\n    # CPLL\n    @property\n    def vco_min(self) -&gt; int:\n        \"\"\"Get minimum CPLL VCO rate for config.\n\n        Returns:\n            int: Rate in samples per second.\n\n        Raises:\n            Exception: Unsupported transceiver type configured.\n        \"\"\"\n        if self.transciever_type == \"GTX2\":\n            return 1600000000\n        elif self.transciever_type in [\"GTH3\", \"GTH4\", \"GTY4\"]:\n            return 2000000000\n        else:\n            raise Exception(\n                f\"Unknown vco_min for transceiver type {self.transciever_type}\"\n            )\n\n    @property\n    def vco_max(self) -&gt; int:\n        \"\"\"Get maximum CPLL VCO rate for config.\n\n        Returns:\n            int: Rate in samples per second.\n\n        Raises:\n            Exception: Unsupported transceiver type configured.\n        \"\"\"\n        if self.transciever_type == \"GTX2\":\n            return 3300000000\n        elif self.transciever_type in [\"GTH3\", \"GTH4\", \"GTY4\"]:\n            if self.hdl_core_version &gt; 2:\n                if self.transciever_type in [\"GTH3\", \"GTH4\"]:\n                    if self.transceiver_voltage &lt; 850 or self.speed_grade == -1:\n                        return 4250000000\n                elif self.transciever_type == \"GTY4\" and self.speed_grade == -1:\n                    return 4250000000\n            return 6250000000\n        else:\n            raise Exception(\n                f\"Unknown vco_max for transceiver type {self.transciever_type}\"\n            )\n\n    # QPLL\n    @property\n    def vco0_min(self) -&gt; int:\n        \"\"\"Get minimum QPLL VCO0 rate for config.\n\n        This is applicable for QPLLs only.\n\n        Returns:\n            int: Rate in samples per second.\n\n        Raises:\n            Exception: Unsupported transceiver type configured.\n        \"\"\"\n        if self.transciever_type == \"GTX2\":\n            return 5930000000\n        elif self.transciever_type in [\"GTH3\", \"GTH4\", \"GTY4\"]:\n            if self.sys_clk_select == \"XCVR_QPLL1\" and self.transciever_type in [\n                \"GTH3\",\n                \"GTH4\",\n            ]:\n                return 8000000000\n            else:\n                return 9800000000\n        else:\n            raise Exception(\n                f\"Unknown vco0_min for transceiver type {self.transciever_type}\"\n            )\n\n    @property\n    def vco0_max(self) -&gt; int:\n        \"\"\"Get maximum QPLL VCO0 rate for config.\n\n        This is applicable for QPLLs only.\n\n        Returns:\n            int: Rate in samples per second.\n\n        Raises:\n            Exception: Unsupported transceiver type configured.\n        \"\"\"\n        if self.transciever_type == \"GTX2\":\n            if (\n                self.hdl_core_version &gt; 2\n                and self.fpga_family == \"Kintex\"\n                and self.fpga_package in [\"FB\", \"RF\", \"FF\"]\n            ):\n                return 6600000000\n            return 8000000000\n        elif self.transciever_type in [\"GTH3\", \"GTH4\", \"GTY4\"]:\n            if self.sys_clk_select == \"XCVR_QPLL1\" and self.transciever_type in [\n                \"GTH3\",\n                \"GTH4\",\n            ]:\n                return 13000000000\n            else:\n                return 16375000000\n        else:\n            raise Exception(\n                f\"Unknown vco0_max for transceiver type {self.transciever_type}\"\n            )\n\n    @property\n    def vco1_min(self) -&gt; int:\n        \"\"\"Get minimum QPLL VCO1 rate for config.\n\n        This is applicable for QPLLs only.\n\n        Returns:\n            int: Rate in samples per second.\n\n        Raises:\n            Exception: Unsupported transceiver type configured.\n        \"\"\"\n        if self.transciever_type == \"GTX2\":\n            return 9800000000\n        elif self.transciever_type in [\"GTH3\", \"GTH4\", \"GTY4\"]:\n            return self.vco0_min\n        else:\n            raise Exception(\n                f\"Unknown vco1_min for transceiver type {self.transciever_type}\"\n            )\n\n    @property\n    def vco1_max(self) -&gt; int:\n        \"\"\"Get maximum QPLL VCO1 rate for config.\n\n        This is applicable for QPLLs only.\n\n        Returns:\n            int: Rate in samples per second.\n\n        Raises:\n            Exception: Unsupported transceiver type configured.\n        \"\"\"\n        if self.transciever_type == \"GTX2\":\n            if self.hdl_core_version &gt; 2 and self.speed_grade == -2:\n                return 10312500000\n            return 12500000000\n        elif self.transciever_type in [\"GTH3\", \"GTH4\", \"GTY4\"]:\n            return self.vco0_max\n        else:\n            raise Exception(\n                f\"Unknown vco1_max for transceiver type {self.transciever_type}\"\n            )\n\n    @property\n    def N(self) -&gt; List[int]:\n        \"\"\"Get available feedback divider settings.\n\n        This is applicable for QPLLs only.\n\n        Returns:\n            list[int]: List of divider integers.\n\n        Raises:\n            Exception: Unsupported transceiver type configured.\n        \"\"\"\n        if self.transciever_type == \"GTX2\":\n            return [16, 20, 32, 40, 64, 66, 80, 100]\n        elif self.transciever_type in [\"GTH3\", \"GTH4\", \"GTY4\"]:\n            return [16, 20, 32, 40, 64, 66, 75, 80, 100, 112, 120, 125, 150, 160]\n        else:\n            raise Exception(\n                \"Unknown N (feedback dividers) for transceiver type\"\n                \" {}\".format(self.transciever_type)\n            )\n\n    def setup_by_dev_kit_name(self, name: str) -&gt; None:\n        \"\"\"Configure object based on board name. Ex: zc706, zcu102.\n\n        Args:\n            name (str): Name of dev kit. Ex: zc706, zcu102\n\n        Raises:\n            Exception: Unsupported board requested.\n\n        \"\"\"\n        if name.lower() == \"zc706\":\n            self.transciever_type = \"GTX2\"\n            self.fpga_family = \"Zynq\"\n            self.fpga_package = \"FF\"\n            self.speed_grade = -2\n            self.ref_clock_min = 60000000\n            self.ref_clock_max = 670000000\n            self.max_serdes_lanes = 8\n            # default PROGDIV not available\n            o = self._out_clk_selections.copy()\n            del o[o.index(\"XCVR_PROGDIV_CLK\")]\n            self._out_clk_selections = o\n            self._out_clk_select = o\n        elif name.lower() == \"zcu102\":\n            self.transciever_type = \"GTH4\"\n            self.fpga_family = \"Zynq\"\n            self.fpga_package = \"FF\"\n            self.speed_grade = -2\n            self.ref_clock_min = 60000000\n            self.ref_clock_max = 820000000\n            self.max_serdes_lanes = 8\n        elif name.lower() == \"vcu118\":\n            # XCVU9P-L2FLGA2104\n            self.transciever_type = \"GTY4\"\n            self.fpga_family = \"Virtex\"\n            self.fpga_package = \"FL\"\n            self.speed_grade = -2\n            self.ref_clock_min = 60000000\n            self.ref_clock_max = 820000000\n            self.max_serdes_lanes = 24\n        else:\n            raise Exception(f\"No boardname found in library for {name}\")\n\n    def determine_pll(self, bit_clock: int, fpga_ref_clock: int) -&gt; Dict:\n        \"\"\"Determine if configuration is possible with CPLL or QPLL.\n\n        CPLL is checked first and will check QPLL if that case is\n        invalid.\n\n        This is only used for brute-force implementations.\n\n        Args:\n            bit_clock (int): Equivalent to lane rate in bits/second\n            fpga_ref_clock (int): System reference clock\n\n        Returns:\n            Dict: Dictionary of PLL configuration\n        \"\"\"\n        try:\n            info = self.determine_cpll(bit_clock, fpga_ref_clock)\n        except:  # noqa: B001\n            info = self.determine_qpll(bit_clock, fpga_ref_clock)\n        return info\n\n    def get_required_clock_names(self) -&gt; List[str]:\n        \"\"\"Get list of strings of names of requested clocks.\n\n        This list of names is for the clocks defined by get_required_clocks\n\n        Returns:\n            List[str]: List of strings of clock names in order\n\n        Raises:\n            Exception: Clock have not been enumerated aka get_required_clocks not\n                not called yet.\n        \"\"\"\n        if not self._clock_names:\n            raise Exception(\n                \"get_required_clocks must be run to generated\"\n                + \" dependent clocks before names are available\"\n            )\n        return self._clock_names\n\n    def get_config(\n        self,\n        converter: conv,\n        fpga_ref: Union[float, int],\n        solution: Optional[CpoSolveResult] = None,\n    ) -&gt; Union[List[Dict], Dict]:\n        \"\"\"Extract configurations from solver results.\n\n        Collect internal FPGA configuration and output clock definitions.\n\n        Args:\n            converter (conv): Converter object connected to FPGA who config is\n                collected\n            fpga_ref (int or float): Reference clock generated for FPGA for specific\n                converter\n            solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n        Raises:\n            Exception: Invalid PLL configuration.\n\n        Returns:\n            Dict: Dictionary of clocking rates and dividers for configuration\n        \"\"\"\n        out = []\n        if solution:\n            self.solution = solution\n\n        for config in self.configs:\n            pll_config: Dict[str, Union[str, int, float]] = {}\n\n            # Filter out other converters\n            if converter.name + \"_use_cpll\" not in config.keys():\n                continue\n            # pll = self._get_val(config[converter.name + \"qpll_0_cpll_1\"])\n            cpll = self._get_val(config[converter.name + \"_use_cpll\"]) &gt; 0\n            qpll = self._get_val(config[converter.name + \"_use_qpll\"]) &gt; 0\n            qpll1 = self._get_val(config[converter.name + \"_use_qpll1\"]) &gt; 0\n\n            if sum([cpll, qpll, qpll1]) != 1:\n                raise Exception(\n                    \"More than one PLL selected\"\n                    + \" can only be one of CPLL, QPLL, or QPLL1\"\n                )\n\n            if cpll &gt; 0:  # type: ignore\n                pll_config[\"type\"] = \"cpll\"\n                for k in [\"m\", \"d\", \"n1\", \"n2\"]:\n                    pll_config[k] = self._get_val(config[converter.name + k + \"_cpll\"])\n\n                pll_config[\"vco\"] = (\n                    fpga_ref * pll_config[\"n1\"] * pll_config[\"n2\"] / pll_config[\"m\"]  # type: ignore # noqa: B950\n                )\n                # Check\n                assert (\n                    pll_config[\"vco\"] * 2 / pll_config[\"d\"] == converter.bit_clock  # type: ignore # noqa: B950\n                ), \"Invalid CPLL lane rate\"\n            else:\n                pll_name = \"qpll\" if qpll else \"qpll1\"\n                pll_config[\"type\"] = pll_name\n                pll_name = \"_\" + pll_name\n                if self.transciever_type in [\"GTY4\"]:\n                    args = [\"m\", \"d\", \"band\"]\n                else:\n                    args = [\"m\", \"d\", \"n\", \"band\"]\n\n                for k in args:\n                    pll_config[k] = self._get_val(config[converter.name + k + pll_name])  # type: ignore # noqa: B950\n                pll_config[\"qty4_full_rate_enabled\"] = 1 - pll_config[\"band\"]  # type: ignore # noqa: B950\n\n                if self.transciever_type in [\"GTY4\"]:\n                    pll_config[\"frac_mode\"] = not self._get_val(\n                        config[converter.name + \"qpll_frac_bypass\"]\n                    )\n                    pll_config[\"qpll_clkoutrate\"] = self._get_val(\n                        config[converter.name + \"qpll_clkoutrate\"]\n                    )\n                    pll_config[\"qpll_sdmdata\"] = self._get_val(\n                        config[converter.name + \"qpll_sdmdata\"]\n                    )\n                    pll_config[\"qpll_sdmwidth\"] = self._get_val(\n                        config[converter.name + \"qpll_sdmwidth\"]\n                    )\n\n                    pll_config[\"qpll_N_dot_frac\"] = self.solution.get_kpis()[\n                        converter.name + \"qpll_N_dot_frac\"\n                    ]\n\n                    config[\"vco\"] = self._add_intermediate(\n                        fpga_ref\n                        * pll_config[\"qpll_N_dot_frac\"]\n                        / (pll_config[\"m\"] * pll_config[\"qpll_clkoutrate\"])\n                    )\n\n                else:\n                    pll_config[\"vco\"] = fpga_ref * pll_config[\"n\"] / pll_config[\"m\"]  # type: ignore # noqa: B950\n\n            # SERDES output mux\n            if pll_config[\"type\"] == \"cpll\":\n                pll_config[\"sys_clk_select\"] = \"XCVR_CPLL\"\n            elif pll_config[\"type\"] == \"qpll\":\n                pll_config[\"sys_clk_select\"] = \"XCVR_QPLL0\"\n            elif pll_config[\"type\"] == \"qpll1\":\n                pll_config[\"sys_clk_select\"] = \"XCVR_QPLL1\"\n            else:\n                raise Exception(\"Invalid PLL type\")\n\n            if self._used_progdiv[converter.name]:\n                pll_config[\"progdiv\"] = self._used_progdiv[converter.name]\n                pll_config[\"out_clk_select\"] = \"XCVR_PROGDIV_CLK\"\n            else:\n                div = self._get_val(config[converter.name + \"_refclk_div\"])\n                pll_config[\"out_clk_select\"] = \"XCVR_REF_CLK\" if div == 1 else \"XCVR_REFCLK_DIV2\"  # type: ignore # noqa: B950\n\n            # if converter.Np == 12 or converter.F not in [\n            #     1,\n            #     2,\n            #     4,\n            # ]:  # self.requires_separate_link_layer_out_clock:\n\n            if self.requires_core_clock_from_device_clock:\n                pll_config[\"separate_device_clock_required\"] = True\n\n            else:\n                pll_config[\"separate_device_clock_required\"] = self._get_val(\n                    config[converter.name + \"two_clks\"]\n                )\n\n                assert self._get_val(\n                    config[converter.name + \"two_clks\"]\n                ) != self._get_val(\n                    config[converter.name + \"single_clk\"]\n                ), \"Solver failed when trying to determine if two clocks are required\"\n                pll_config[\"transport_samples_per_clock\"] = self._get_val(\n                    config[converter.name + \"_link_out_div\"]\n                )\n\n            if qpll or qpll1:\n                if self.transciever_type in [\"GTY4\"]:\n                    pll_clk_out = (\n                        fpga_ref\n                        * pll_config[\"qpll_N_dot_frac\"]\n                        / (pll_config[\"m\"] * pll_config[\"qpll_clkoutrate\"])\n                    )\n                    lr = pll_clk_out * 2 / pll_config[\"d\"]\n                    assert (\n                        lr == converter.bit_clock\n                    ), f\"Invalid QPLL1 lane rate {lr} != {converter.bit_clock}\"  # type: ignore # noqa: B950\n\n                else:\n                    div = self._get_val(\n                        config[converter.name + \"qty4_full_rate_divisor\"]\n                    )\n                    lr = (\n                        fpga_ref\n                        * div\n                        * pll_config[\"n\"]\n                        / (pll_config[\"m\"] * 1)\n                        * 1\n                        / pll_config[\"d\"]\n                    )\n                    assert (\n                        lr == converter.bit_clock\n                    ), f\"Invalid QPLL1 lane rate {lr} != {converter.bit_clock}\"  # type: ignore # noqa: B950\n\n            # Check\n            if pll_config[\"out_clk_select\"] == \"XCVR_REF_CLK\" and not cpll:\n                assert (\n                    pll_config[\"vco\"] == converter.bit_clock * pll_config[\"d\"]  # type: ignore # noqa: B950\n                ), \"Invalid QPLL lane rate {} != {}\".format(\n                    pll_config[\"vco\"] / pll_config[\"d\"], converter.bit_clock  # type: ignore # noqa: B950\n                )\n\n            out.append(pll_config)\n\n        if len(out) == 1:\n            out = out[0]  # type: ignore\n        return out\n\n    def _get_conv_prop(\n        self, conv: conv, prop: Union[str, dict]\n    ) -&gt; Union[int, float, str]:\n        \"\"\"Helper to extract nested properties if present.\n\n        Args:\n            conv (conv): Converter object\n            prop (str,dict): Property to extract\n\n        Raises:\n            Exception: Converter does not have property\n\n        Returns:\n            Union[int,float,str]: Value of property\n        \"\"\"\n        if isinstance(prop, dict):\n            if conv not in prop:\n                raise Exception(f\"Converter {conv.name} not found in config\")\n            return prop[conv]\n        return prop\n\n    def _get_progdiv(self) -&gt; Union[List[int], List[float]]:\n        \"\"\"Get programmable SERDES dividers for FPGA.\n\n        Raises:\n            Exception: PRODIV is not available for transceiver type.\n\n        Returns:\n            List[int,float]: Programmable dividers for FPGA\n        \"\"\"\n        if self.transciever_type in [\"GTY3\", \"GTH3\"]:\n            return [1, 4, 5, 8, 10, 16, 16.5, 20, 32, 33, 40, 64, 66, 80, 100]\n        elif self.transciever_type in [\"GTY4\", \"GTH4\"]:\n            return [1, 4, 5, 8, 10, 16, 16.5, 20, 32, 33, 40, 64, 66, 80, 100, 128, 132]\n        else:\n            raise Exception(\n                \"PROGDIV is not available for FPGA transciever type \"\n                + str(self.transciever_type)\n            )\n\n    def _set_link_layer_requirements(\n        self,\n        converter: conv,\n        fpga_ref: Union[int, GKVariable, GK_Intermediate, GK_Operators, CpoIntVar],\n        config: Dict,\n        link_out_ref: Union[\n            int, GKVariable, GK_Intermediate, GK_Operators, CpoIntVar\n        ] = None,\n    ) -&gt; Dict:\n        \"\"\"Set link layer constraints for downstream FPGA logic.\n\n        The link layer is driven from the XCVR core which can route the\n        following signals to the link layer input:\n        - External Ref\n        - External Ref / 2\n        - {CPLL,QPLL0,QPLL1} / PROGDIV\n\n        The link layer input has a hard requirement that is must be at:\n        - JESD204B: lane rate (bit clock) / 40 or lane rate (bit clock) / 80\n        - JESD204C: lane rate (bit clock) / 66\n\n        The link layer output rate will be equivalent to sample clock / N, where\n        N is an integer. Note the smaller N, the more channeling it can be to\n        synthesize the design. This output clock can be separate or be the same\n        as the XCVR reference.\n\n        Based on this info, we set up the problem where we define N (sample per\n        clock increase), and set the lane rate based on the current converter\n        JESD config.\n\n        Args:\n            converter (conv): Converter object connected to FPGA\n            fpga_ref (int or GKVariable): Reference clock generated for FPGA\n            config (Dict): Dictionary of clocking rates and dividers for link\n                layer\n            link_out_ref (int or GKVariable): Reference clock generated for FPGA\n                link layer output\n\n        Returns:\n            Dict: Dictionary of clocking rates extended with dividers for link\n                layer\n\n        Raises:\n            Exception: Link layer output clock select invalid\n        \"\"\"\n        if converter.jesd_class == \"jesd204b\":\n            link_layer_input_rate = converter.bit_clock / 40\n        elif converter.jesd_class == \"jesd204c\":\n            link_layer_input_rate = converter.bit_clock / 66\n\n        if isinstance(self.out_clk_select, dict):\n            if converter not in self.out_clk_select.keys():\n                raise Exception(\n                    \"Link layer out_clk_select invalid for converter \" + converter.name\n                )\n            if isinstance(self.out_clk_select[converter], dict):\n                out_clk_select = self.out_clk_select[converter].copy()\n            else:\n                out_clk_select = self.out_clk_select[converter]\n        else:\n            out_clk_select = self.out_clk_select\n\n        # Try PROGDIV first since it doesn't require the solver\n        ocs_found = False\n        self._used_progdiv[converter.name] = False\n        if (\n            isinstance(out_clk_select, str)\n            and out_clk_select == \"XCVR_PROGDIV_CLK\"\n            or isinstance(out_clk_select, list)\n            and \"XCVR_PROGDIV_CLK\" in out_clk_select\n        ):\n            progdiv = self._get_progdiv()\n            div = converter.bit_clock / link_layer_input_rate\n            if div in progdiv:\n                ocs_found = True\n                self._used_progdiv[converter.name] = div\n            elif isinstance(out_clk_select, str):\n                raise Exception(\n                    f\"Cannot use PROGDIV since required divider {div},\"\n                    + f\" only available {progdiv}\"\n                )\n            else:\n                del out_clk_select[out_clk_select.index(\"XCVR_PROGDIV_CLK\")]\n\n        # REFCLK\n        if not ocs_found and (\n            (isinstance(out_clk_select, str) and out_clk_select == \"XCVR_REFCLK\")\n            or (isinstance(out_clk_select, list) and out_clk_select == [\"XCVR_REFCLK\"])\n        ):\n            ocs_found = True\n            config[converter.name + \"_refclk_div\"] = 1\n            self._add_equation([fpga_ref == link_layer_input_rate])\n\n        # REFCLK / 2\n        if not ocs_found and (\n            (isinstance(out_clk_select, str) and out_clk_select == \"XCVR_REFCLK_DIV2\")\n            or (\n                isinstance(out_clk_select, list)\n                and out_clk_select == [\"XCVR_REFCLK_DIV2\"]\n            )\n        ):\n            ocs_found = True\n            config[converter.name + \"_refclk_div\"] = 2\n            self._add_equation([fpga_ref == link_layer_input_rate * 2])\n\n        # Ref clk will use solver to determine if we need REFCLK or REFCLK / 2\n        if not ocs_found and (\n            isinstance(out_clk_select, list)\n            and out_clk_select == [\"XCVR_REFCLK\", \"XCVR_REFCLK_DIV2\"]\n        ):\n            ocs_found = True\n            config[converter.name + \"_refclk_div\"] = self._convert_input(\n                [1, 2], converter.name + \"_refclk_div\"\n            )\n            self._add_equation(\n                [\n                    fpga_ref\n                    == link_layer_input_rate * config[converter.name + \"_refclk_div\"]\n                ]\n            )\n\n        if not ocs_found:\n            raise Exception(\n                \"Invalid (or unsupported) link layer output clock selection \"\n                + str(out_clk_select)\n            )\n\n        return config\n\n    def _setup_quad_tile(\n        self,\n        converter: conv,\n        fpga_ref: Union[int, GKVariable, GK_Intermediate, GK_Operators, CpoIntVar],\n        link_out_ref: Union[\n            None, int, GKVariable, GK_Intermediate, GK_Operators, CpoIntVar\n        ] = None,\n    ) -&gt; Dict:\n        \"\"\"Configure FPGA {Q/C}PLL tile.\n\n        Args:\n            converter (conv): Converter object(s) connected to FPGA\n            fpga_ref (int,GKVariable, GK_Intermediate, GK_Operators, CpoIntVar):\n                Reference clock for FPGA\n            link_out_ref (None, int,GKVariable, GK_Intermediate, GK_Operators,\n                CpoIntVar): Link layer output reference clock\n\n        Returns:\n            Dict: Dictionary of clocking rates and dividers for configuration\n\n        Raises:\n            Exception: Unsupported solver\n        \"\"\"\n        # Add reference clock constraints\n        self._add_equation(\n            [fpga_ref &gt;= self.ref_clock_min, fpga_ref &lt;= self.ref_clock_max]\n        )\n\n        if converter.jesd_class == \"jesd204b\":\n            core_clock = converter.bit_clock / 40\n        else:\n            core_clock = converter.bit_clock / 66\n\n        if self.ref_clock_constraint == \"CORE_CLOCK\":\n            self._add_equation([fpga_ref == core_clock])\n        elif self.ref_clock_constraint == \"CORE_CLOCK_DIV2\":\n            self._add_equation([fpga_ref == core_clock / 2])\n\n        # CPLL -&gt; VCO = FPGA_REF * N1*N2/M\n        #         PLLOUT = VCO\n        #         LR  = PLLOUT * 2/D\n        #         LR  = FPGA_REF * N1*N2*2/(M*D)\n        #\n        # QPLL -&gt; VCO = FPGA_REF * N/(M*2)\n        #         PLLOUT = VCO/2\n        #         LR  = PLLOUT * 2/D\n        #         LR  = FPGA_REF * N/(M*D)\n        config = {}\n        # Save PLL settings\n        ref_sys_clk_select = self.sys_clk_select\n\n        # Extract permutations\n        self.sys_clk_select = \"XCVR_QPLL0\"\n        vco0_min_qpll = self.vco0_min\n        vco0_max_qpll = self.vco0_max\n        vco1_min_qpll = self.vco1_min\n        vco1_max_qpll = self.vco1_max\n        self.sys_clk_select = \"XCVR_QPLL1\"\n        vco0_min_qpll1 = self.vco0_min\n        vco0_max_qpll1 = self.vco0_max\n        vco1_min_qpll1 = self.vco1_min\n        vco1_max_qpll1 = self.vco1_max\n\n        self.sys_clk_select = ref_sys_clk_select  # Restore PLL settings\n\n        # GTHE3, GTHE4, GTYE4\n        qpll1_allowed = self.transciever_type in [\"GTH3\", \"GTH4\", \"GTY4\"]\n\n        if self.transciever_type in [\"GTY4\"]:\n            dqpll = [1, 2, 4, 8, 16, 32]\n        else:\n            dqpll = [1, 2, 4, 8, 16]\n        # QPLL\n        config[converter.name + \"m_qpll\"] = self._convert_input(\n            [1, 2, 3, 4], converter.name + \"m_qpll\"\n        )\n        config[converter.name + \"d_qpll\"] = self._convert_input(\n            dqpll, converter.name + \"d_qpll\"\n        )\n        config[converter.name + \"n_qpll\"] = self._convert_input(\n            self.N, converter.name + \"n_qpll\"\n        )\n\n        # QPLL1\n        config[converter.name + \"m_qpll1\"] = self._convert_input(\n            [1, 2, 3, 4], converter.name + \"m_qpll1\"\n        )\n        config[converter.name + \"d_qpll1\"] = self._convert_input(\n            dqpll, converter.name + \"d_qpll1\"\n        )\n        config[converter.name + \"n_qpll1\"] = self._convert_input(\n            self.N, converter.name + \"n_qpll1\"\n        )\n\n        if self.transciever_type in [\"GTY4\"]:\n            # GTY fractional PLL\n            config[converter.name + \"qpll_clkoutrate\"] = self._convert_input(\n                [1, 2], converter.name + \"qpll_clkoutrate\"\n            )\n            config[converter.name + \"qpll_sdmdata\"] = integer_var(\n                min=0, max=(2**24 - 1), name=converter.name + \"qpll_sdmdata\"\n            )\n            config[converter.name + \"qpll_sdmwidth\"] = self._convert_input(\n                [16, 20, 24], converter.name + \"qpll_sdmwidth\"\n            )\n            config[converter.name + \"qpll_frac\"] = self._add_intermediate(\n                config[converter.name + \"qpll_sdmdata\"]\n                / (\n                    2 ** config[converter.name + \"qpll_sdmwidth\"]\n                )  # FIXME: REMOVE POWER OF 2\n            )\n            self._add_equation(\n                [\n                    config[converter.name + \"qpll_frac\"] &lt; 1,\n                ]\n            )\n            config[converter.name + \"qpll_N_dot_frac\"] = self._add_intermediate(\n                config[converter.name + \"n_qpll\"] + config[converter.name + \"qpll_frac\"]\n            )\n            self.model.add_kpi(\n                config[converter.name + \"qpll_N_dot_frac\"],\n                converter.name + \"qpll_N_dot_frac\",\n            )\n\n            config[converter.name + \"vco_qpll\"] = self._add_intermediate(\n                fpga_ref\n                * config[converter.name + \"qpll_N_dot_frac\"]\n                / (\n                    config[converter.name + \"m_qpll\"]\n                    * config[converter.name + \"qpll_clkoutrate\"]\n                )\n            )\n            config[converter.name + \"vco_qpll1\"] = self._add_intermediate(\n                fpga_ref\n                * config[converter.name + \"qpll_N_dot_frac\"]\n                / (\n                    config[converter.name + \"m_qpll1\"]\n                    * config[converter.name + \"qpll_clkoutrate\"]\n                )\n            )\n\n            # When lane rate &gt; 28.1 Gbps, qpll_frac must be set to 0\n            config[converter.name + \"qpll_frac_bypass\"] = self._convert_input(\n                [0, 1], converter.name + \"qpll_frac_bypass\"\n            )\n            self._add_equation(\n                [\n                    (1 - config[converter.name + \"qpll_frac_bypass\"])\n                    * converter.bit_clock\n                    &lt;= int(28.1e9),\n                    config[converter.name + \"qpll_frac_bypass\"]\n                    * config[converter.name + \"qpll_frac\"]\n                    == 0,\n                ]\n            )\n\n        else:\n            config[converter.name + \"vco_qpll\"] = self._add_intermediate(\n                fpga_ref\n                * config[converter.name + \"n_qpll\"]\n                / (config[converter.name + \"m_qpll\"])\n            )\n            config[converter.name + \"vco_qpll1\"] = self._add_intermediate(\n                fpga_ref\n                * config[converter.name + \"n_qpll1\"]\n                / (config[converter.name + \"m_qpll1\"])\n            )\n\n        # Define QPLL band requirements\n        config[converter.name + \"band_qpll\"] = self._convert_input(\n            [0, 1], converter.name + \"band_qpll\"\n        )\n\n        config[converter.name + \"vco_max_qpll\"] = self._add_intermediate(\n            config[converter.name + \"band_qpll\"] * vco1_max_qpll\n            + (1 - config[converter.name + \"band_qpll\"]) * vco0_max_qpll\n        )\n        config[converter.name + \"vco_min_qpll\"] = self._add_intermediate(\n            config[converter.name + \"band_qpll\"] * vco1_min_qpll\n            + (1 - config[converter.name + \"band_qpll\"]) * vco0_min_qpll\n        )\n\n        # Define QPLL1 band requirements\n        # if qpll1_allowed:\n        config[converter.name + \"band_qpll1\"] = self._convert_input(\n            [0, 1], converter.name + \"band_qpll1\"\n        )\n\n        config[converter.name + \"vco_max_qpll1\"] = self._add_intermediate(\n            config[converter.name + \"band_qpll1\"] * vco1_max_qpll1\n            + (1 - config[converter.name + \"band_qpll1\"]) * vco0_max_qpll1\n        )\n        config[converter.name + \"vco_min_qpll1\"] = self._add_intermediate(\n            config[converter.name + \"band_qpll1\"] * vco1_min_qpll1\n            + (1 - config[converter.name + \"band_qpll1\"]) * vco0_min_qpll1\n        )\n\n        # Define if we can use GTY (is available) at full rate\n        if self.transciever_type != \"GTY4\":\n            # QPLL1 does not exist for GTY4 so we cannot bypass the extra dec 2\n            config[converter.name + \"qty4_full_rate_divisor\"] = self._convert_input(\n                1, name=converter.name + \"qty4_full_rate_divisor\"\n            )\n        else:\n            config[converter.name + \"qty4_full_rate_divisor\"] = self._convert_input(\n                [1, 2], name=converter.name + \"qty4_full_rate_divisor\"\n            )\n\n        # config[converter.name + \"qty4_full_rate_enabled\"] = self._add_intermediate(\n        #     1 - config[converter.name + \"qty4_full_rate_divisor\"]\n        # )\n\n        #######################\n        # CPLL\n        # CPLL -&gt; VCO = FPGA_REF * N1*N2/M\n        #         LR  = VCO * 2/D\n        #         LR  = FPGA_REF * N1*N2*2/(M*D)\n        config[converter.name + \"m_cpll\"] = self._convert_input(\n            [1, 2], converter.name + \"m_cpll\"\n        )\n        # We do not allow D=16 or D=32 since they do not allow TX/RXOUT DIV\n        config[converter.name + \"d_cpll\"] = self._convert_input(\n            [1, 2, 4, 8], converter.name + \"d_cpll\"\n        )\n        config[converter.name + \"n1_cpll\"] = self._convert_input(\n            [4, 5], converter.name + \"n1_cpll\"\n        )\n        config[converter.name + \"n2_cpll\"] = self._convert_input(\n            [1, 2, 3, 4, 5], converter.name + \"n2_cpll\"\n        )\n\n        config[converter.name + \"vco_cpll\"] = self._add_intermediate(\n            fpga_ref\n            * config[converter.name + \"n1_cpll\"]\n            * config[converter.name + \"n2_cpll\"]\n            / config[converter.name + \"m_cpll\"]\n        )\n\n        # Merge\n        # if sum([self.force_qpll, self.force_qpll1, self.force_cpll]) &gt; 1:\n        #     raise Exception(\"Cannot force multiple PLLs QPLL0, QPLL1, CPLL\")\n        if (\n            sum(\n                [\n                    self._get_conv_prop(converter, self.force_qpll),\n                    self._get_conv_prop(converter, self.force_qpll1),\n                    self._get_conv_prop(converter, self.force_cpll),\n                ]\n            )\n            &gt; 1\n        ):\n            raise Exception(\"Cannot force multiple PLLs QPLL0, QPLL1, CPLL\")\n\n        if self._get_conv_prop(converter, self.force_qpll1) and not qpll1_allowed:\n            raise Exception(\n                \"QPLL1 is not available for transceiver \" + self.transciever_type\n            )\n\n        if self._get_conv_prop(converter, self.force_qpll):\n            qpll = 1\n            qpll1 = 0\n            cpll = 0\n        elif self._get_conv_prop(converter, self.force_qpll1):\n            qpll = 0\n            qpll1 = 1\n            cpll = 0\n        elif self._get_conv_prop(converter, self.force_cpll):\n            qpll = 0\n            qpll1 = 0\n            cpll = 1\n        else:\n            qpll = [0, 1]\n            if qpll1_allowed:\n                qpll1 = [0, 1]\n            else:\n                qpll1 = 0\n            cpll = [0, 1]\n\n        config[converter.name + \"_use_cpll\"] = self._convert_input(\n            cpll, converter.name + \"_use_cpll\"\n        )\n        config[converter.name + \"_use_qpll\"] = self._convert_input(\n            qpll, converter.name + \"_use_qpll\"\n        )\n        config[converter.name + \"_use_qpll1\"] = self._convert_input(\n            qpll1, converter.name + \"_use_qpll1\"\n        )\n\n        # Select only one PLL\n        if (\n            not self._get_conv_prop(converter, self.force_cpll)\n            and not self._get_conv_prop(converter, self.force_qpll)\n            and not self._get_conv_prop(converter, self.force_qpll1)\n        ):\n            self._add_equation(\n                1\n                == config[converter.name + \"_use_cpll\"]\n                + config[converter.name + \"_use_qpll\"]\n                + config[converter.name + \"_use_qpll1\"]\n            )\n\n        # VCO\n        config[converter.name + \"vco_select\"] = self._add_intermediate(\n            config[converter.name + \"_use_cpll\"] * config[converter.name + \"vco_cpll\"]\n            + config[converter.name + \"_use_qpll\"] * config[converter.name + \"vco_qpll\"]\n            + config[converter.name + \"_use_qpll1\"]\n            * config[converter.name + \"vco_qpll1\"]\n        )\n\n        config[converter.name + \"vco_min_select\"] = self._add_intermediate(\n            config[converter.name + \"_use_cpll\"] * self.vco_min\n            + config[converter.name + \"_use_qpll\"]\n            * config[converter.name + \"vco_min_qpll\"]\n            + config[converter.name + \"_use_qpll1\"]\n            * config[converter.name + \"vco_min_qpll1\"]\n        )\n\n        config[converter.name + \"vco_max_select\"] = self._add_intermediate(\n            config[converter.name + \"_use_cpll\"] * self.vco_max\n            + config[converter.name + \"_use_qpll\"]\n            * config[converter.name + \"vco_max_qpll\"]\n            + config[converter.name + \"_use_qpll1\"]\n            * config[converter.name + \"vco_max_qpll1\"]\n        )\n\n        config[converter.name + \"d_select\"] = self._add_intermediate(\n            config[converter.name + \"_use_cpll\"] * config[converter.name + \"d_cpll\"]\n            + config[converter.name + \"_use_qpll\"] * config[converter.name + \"d_qpll\"]\n            + config[converter.name + \"_use_qpll1\"] * config[converter.name + \"d_qpll1\"]\n        )\n\n        # Note: QPLL has extra /2 after VCO so:\n        #       QPLL: lanerate == vco/d\n        #       CPLL: lanerate == vco*2/d\n\n        config[converter.name + \"rate_divisor_select\"] = self._add_intermediate(\n            config[converter.name + \"_use_cpll\"] * 2\n            + config[converter.name + \"_use_qpll\"]\n            * config[converter.name + \"qty4_full_rate_divisor\"]\n            + config[converter.name + \"_use_qpll1\"]\n            * config[converter.name + \"qty4_full_rate_divisor\"]\n        )\n\n        #######################\n\n        # Set all relations\n        # QPLL+CPLL\n        #\n        # CPLL -&gt; VCO = FPGA_REF * N1*N2/M\n        #         PLLOUT = VCO\n        #         LR  = PLLOUT * 2/D\n        #         LR  = FPGA_REF * N1*N2*2/(M*D)\n        #\n        # QPLL -&gt; VCO = FPGA_REF * N/(M)\n        #         PLLOUT = VCO/2\n        #         LR  = PLLOUT * 2/D\n        #         LR  = FPGA_REF * N/(M*D)\n        #\n        #  LR = FPGA_REF*(A*N1*N2*2/(M*D) + (A-1)*N/(M*D))\n        #    A = 0,1\n        #  LR*D*M = FPGA_REF*(A*N1*N2*2 + (A-1)*N)\n\n        self._add_equation(\n            [\n                config[converter.name + \"vco_select\"]\n                &gt;= config[converter.name + \"vco_min_select\"],\n                config[converter.name + \"vco_select\"]\n                &lt;= config[converter.name + \"vco_max_select\"],\n                # CPLL\n                # converter.bit_clock == vco * 2 / d\n                # QPLL\n                # converter.bit_clock == vco / d\n                config[converter.name + \"vco_select\"]\n                * config[converter.name + \"rate_divisor_select\"]\n                == converter.bit_clock * config[converter.name + \"d_select\"],\n            ]\n        )\n\n        # Add constraints for link clock\n        #  - Must be lanerate/40 204B or lanerate/66 204C\n        config = self._set_link_layer_requirements(converter, fpga_ref, config, None)\n\n        # Add optimization to favor a single reference clock vs unique ref+device clocks\n        config[converter.name + \"single_clk\"] = self._convert_input(\n            [0, 1], converter.name + \"single_clk\"\n        )\n        if self.force_separate_device_clock:\n            sdc = [1]\n        else:\n            sdc = [0, 1]\n        config[converter.name + \"two_clks\"] = self._convert_input(\n            sdc, converter.name + \"two_clks\"\n        )\n        self._add_equation(\n            [\n                config[converter.name + \"single_clk\"]\n                + config[converter.name + \"two_clks\"]\n                == 1,\n            ]\n        )\n        # Favor single clock, this equation will be minimized\n        v = (\n            config[converter.name + \"single_clk\"]\n            + 1000 * config[converter.name + \"two_clks\"]\n        )\n        self._add_objective(v)\n\n        # Add constraints to meet sample clock\n        if self.requires_core_clock_from_device_clock:\n            if converter.jesd_class == \"jesd204b\":\n                core_clock = converter.bit_clock / 40\n            else:\n                core_clock = converter.bit_clock / 66\n\n            self._add_equation([core_clock == link_out_ref])\n\n        else:\n            possible_divs = []\n            for samples_per_clock in [1, 2, 4, 8, 16]:\n                if converter.sample_clock / samples_per_clock &lt;= self.target_Fmax:\n                    possible_divs.append(samples_per_clock)\n\n            if len(possible_divs) == 0:\n                raise Exception(\"Link layer output clock rate too high\")\n\n            config[converter.name + \"_link_out_div\"] = self._convert_input(\n                possible_divs, converter.name + \"_samples_per_clock\"\n            )\n\n            self._add_equation(\n                [\n                    (\n                        config[converter.name + \"single_clk\"] * fpga_ref\n                        + config[converter.name + \"two_clks\"]\n                        * link_out_ref\n                        * config[converter.name + \"_link_out_div\"]\n                    )\n                    == converter.sample_clock\n                ]\n            )\n\n        return config\n\n    def get_required_clocks(\n        self,\n        converter: conv,\n        fpga_ref: Union[int, GKVariable, GK_Intermediate, GK_Operators, CpoIntVar],\n        link_out_ref: Union[\n            int, GKVariable, GK_Intermediate, GK_Operators, CpoIntVar\n        ] = None,\n    ) -&gt; List:\n        \"\"\"Get necessary clocks for QPLL/CPLL configuration.\n\n        Args:\n            converter (conv): Converter object of converter connected to FPGA\n            fpga_ref (int, GKVariable, GK_Intermediate, GK_Operators, CpoIntVar):\n                Abstract or concrete reference to FPGA reference clock\n            link_out_ref (int or GKVariable): Reference clock generated for FPGA\n                link layer output, also called device clock\n\n        Returns:\n            List: List of solver variables and constraints\n\n        Raises:\n            Exception: If solver is not valid\n            Exception: Link layer out clock required\n        \"\"\"\n        if self.ref_clock_min == -1 or self.ref_clock_max == -1:\n            raise Exception(\"ref_clock_min or ref_clock_max not set\")\n        if \"_get_converters\" in dir(converter):\n            converter = (\n                converter._get_converters()  # type: ignore\n            )  # Handle nested converters\n\n        if not isinstance(converter, list):\n            converter = [converter]  # type: ignore\n\n        # if self.solver == \"gekko\":\n        #     self.config = {\n        #         \"fpga_ref\": self.model.Var(\n        #             # integer=True,\n        #             lb=self.ref_clock_min,\n        #             ub=self.ref_clock_max,\n        #             value=self.ref_clock_min,\n        #         )\n        #     }\n        # elif self.solver == \"CPLEX\":\n        #     # self.config = {\n        #     #     \"fpga_ref\": integer_var(\n        #     #         self.ref_clock_min, self.ref_clock_max, \"fpga_ref\"\n        #     #     )\n        #     # }\n        #     pass\n        # else:\n        #     raise Exception(f\"Unknown solver {self.solver}\")\n\n        # https://www.xilinx.com/support/documentation/user_guides/ug476_7Series_Transceivers.pdf # noqa: B950\n\n        # clock_names = [\"fpga_ref\"]\n        clock_names = []\n        self.config = {}\n        if self.force_single_quad_tile:\n            raise Exception(\"force_single_quad_tile==1 not implemented\")\n        else:\n            #######################\n            # self.configs = []\n            self.dev_clocks = []\n            self.ref_clocks = []\n            # obs = []\n            for cnv in converter:  # type: ignore\n                # rsl = self._get_conv_prop(\n                #     cnv, self.requires_separate_link_layer_out_clock\n                # )\n                # if link_out_ref is None and rsl:\n                #     raise Exception(\"Link layer out clock required\")\n\n                clock_names.append(cnv.name + \"fpga_ref\")\n                # self.config[cnv.name+\"fpga_ref\"] = interval_var(\n                #     self.ref_clock_min, self.ref_clock_max, name=cnv.name+\"fpga_ref\"\n                # )\n                self.config[cnv.name + \"fpga_ref\"] = fpga_ref\n                self.ref_clocks.append(self.config[cnv.name + \"fpga_ref\"])\n                if (\n                    link_out_ref is not None\n                ):  # self.requires_separate_link_layer_out_clock:\n                    self.config[cnv.name + \"link_out_ref\"] = link_out_ref\n                    self.ref_clocks.append(self.config[cnv.name + \"link_out_ref\"])\n                    config = self._setup_quad_tile(\n                        cnv,\n                        self.config[cnv.name + \"fpga_ref\"],\n                        self.config[cnv.name + \"link_out_ref\"],\n                    )\n                else:\n                    config = self._setup_quad_tile(\n                        cnv, self.config[cnv.name + \"fpga_ref\"]\n                    )\n                # Set optimizations\n                # self.model.Obj(self.config[converter.name+\"d\"])\n                # self.model.Obj(self.config[converter.name+\"d_cpll\"])\n                # self.model.Obj(config[converter.name+\"d_select\"])\n                if self.favor_cpll_over_qpll:\n                    if self.solver == \"gekko\":\n                        self.model.Obj(\n                            -1 * config[cnv.name + \"qpll_0_cpll_1\"]\n                        )  # Favor CPLL over QPLL\n                    elif self.solver == \"CPLEX\":\n                        self.model.maximize(config[cnv.name + \"qpll_0_cpll_1\"])\n                        # obs.append(-1 * config[cnv.name + \"qpll_0_cpll_1\"])\n                    else:\n                        raise Exception(f\"Unknown solver {self.solver}\")\n\n                self.configs.append(config)\n                # FPGA also requires clock at device clock rate\n                if self.request_device_clock:\n                    self.dev_clocks.append(cnv.device_clock)\n                    clock_names.append(cnv.name + \"_fpga_device_clock\")\n\n        if self.minimize_fpga_ref_clock:\n            if self.solver == \"gekko\":\n                self.model.Obj(self.config[cnv.name + \"fpga_ref\"])\n            elif self.solver == \"CPLEX\":\n                # self.model.minimize_static_lex(obs + [self.config[converter.name+\"fpga_ref\"]]) # noqa: B950\n                self.model.minimize(self.config[cnv.name + \"fpga_ref\"])  # noqa: B950\n                # self.model.maximize(obs + self.config[converter.name+\"fpga_ref\"])\n            else:\n                raise Exception(f\"Unknown solver {self.solver}\")\n\n        self._clock_names = clock_names\n\n        # return [self.config[\"fpga_ref\"]] + self.dev_clocks\n        return self.ref_clocks + self.dev_clocks\n</code></pre>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.N","title":"<code>N: List[int]</code>  <code>property</code>","text":"<p>Get available feedback divider settings.</p> <p>This is applicable for QPLLs only.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>list[int]: List of divider integers.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Unsupported transceiver type configured.</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.force_cpll","title":"<code>force_cpll = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Force all transceiver sources to be from a single PLL quad. This will try to leverage the output dividers of the PLLs</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.force_qpll","title":"<code>force_qpll = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Force use of QPLL1 for transceiver source (GTH3,GTH4,GTY4)</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.force_qpll1","title":"<code>force_qpll1 = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Force use of CPLL for transceiver source</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.force_separate_device_clock","title":"<code>force_separate_device_clock: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constrain reference clock to be specific values. Options: - CORE_CLOCK: Make reference clock the same as the core clock (LR/40 or LR/66) - CORE_CLOCK_DIV2: Make reference clock the same as the core clock divided by 2 - Unconstrained: No constraints on reference clock. Simply meet PLL constraints</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.force_single_quad_tile","title":"<code>force_single_quad_tile = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Request that clock chip generated device clock device clock == LMFC/40 NOTE: THIS IS NOT FPGA REF CLOCK</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.minimize_fpga_ref_clock","title":"<code>minimize_fpga_ref_clock = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Force generation of separate device clock from the clock chip. In many cases, the ref clock and device clock can be the same.</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.out_clk_select","title":"<code>out_clk_select: Union[int, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Get current PLL clock output mux options for link layer clock.</p> Valid options are <p>\"XCVR_REFCLK\", \"XCVR_REFCLK_DIV2\", \"XCVR_PROGDIV_CLK\"</p> <p>If a list of these is provided, the solver will determine one to use</p> <p>Returns:</p> Type Description <code>Union[int, float]</code> <p>str,list(str): Mux selection for link layer clock.</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.ref_clock_constraint","title":"<code>ref_clock_constraint: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get reference clock constraint.</p> <p>Reference clock constraint can be set to: - CORE_CLOCK: Make reference clock the same as the core clock (LR/40 or LR/66) - CORE_CLOCK_DIV2: Make reference clock the same as the core clock divided by 2 - Unconstrained: No constraints on reference clock. Simply meet PLL constraints</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Reference clock constraint.</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.requires_separate_link_layer_out_clock","title":"<code>requires_separate_link_layer_out_clock = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Require generation of separate core clock (LR/40 or LR/66)</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.target_Fmax","title":"<code>target_Fmax = 250000000.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Require generation of separate clock specifically for link layer</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.vco0_max","title":"<code>vco0_max: int</code>  <code>property</code>","text":"<p>Get maximum QPLL VCO0 rate for config.</p> <p>This is applicable for QPLLs only.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Rate in samples per second.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Unsupported transceiver type configured.</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.vco0_min","title":"<code>vco0_min: int</code>  <code>property</code>","text":"<p>Get minimum QPLL VCO0 rate for config.</p> <p>This is applicable for QPLLs only.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Rate in samples per second.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Unsupported transceiver type configured.</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.vco1_max","title":"<code>vco1_max: int</code>  <code>property</code>","text":"<p>Get maximum QPLL VCO1 rate for config.</p> <p>This is applicable for QPLLs only.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Rate in samples per second.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Unsupported transceiver type configured.</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.vco1_min","title":"<code>vco1_min: int</code>  <code>property</code>","text":"<p>Get minimum QPLL VCO1 rate for config.</p> <p>This is applicable for QPLLs only.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Rate in samples per second.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Unsupported transceiver type configured.</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.vco_max","title":"<code>vco_max: int</code>  <code>property</code>","text":"<p>Get maximum CPLL VCO rate for config.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Rate in samples per second.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Unsupported transceiver type configured.</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.vco_min","title":"<code>vco_min: int</code>  <code>property</code>","text":"<p>Get minimum CPLL VCO rate for config.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Rate in samples per second.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Unsupported transceiver type configured.</p>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.determine_pll","title":"<code>determine_pll(bit_clock, fpga_ref_clock)</code>","text":"<p>Determine if configuration is possible with CPLL or QPLL.</p> <p>CPLL is checked first and will check QPLL if that case is invalid.</p> <p>This is only used for brute-force implementations.</p> <p>Parameters:</p> Name Type Description Default <code>bit_clock</code> <code>int</code> <p>Equivalent to lane rate in bits/second</p> required <code>fpga_ref_clock</code> <code>int</code> <p>System reference clock</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>Dictionary of PLL configuration</p> Source code in <code>adijif/fpgas/xilinx.py</code> <pre><code>def determine_pll(self, bit_clock: int, fpga_ref_clock: int) -&gt; Dict:\n    \"\"\"Determine if configuration is possible with CPLL or QPLL.\n\n    CPLL is checked first and will check QPLL if that case is\n    invalid.\n\n    This is only used for brute-force implementations.\n\n    Args:\n        bit_clock (int): Equivalent to lane rate in bits/second\n        fpga_ref_clock (int): System reference clock\n\n    Returns:\n        Dict: Dictionary of PLL configuration\n    \"\"\"\n    try:\n        info = self.determine_cpll(bit_clock, fpga_ref_clock)\n    except:  # noqa: B001\n        info = self.determine_qpll(bit_clock, fpga_ref_clock)\n    return info\n</code></pre>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.get_config","title":"<code>get_config(converter, fpga_ref, solution=None)</code>","text":"<p>Extract configurations from solver results.</p> <p>Collect internal FPGA configuration and output clock definitions.</p> <p>Parameters:</p> Name Type Description Default <code>converter</code> <code>converter</code> <p>Converter object connected to FPGA who config is collected</p> required <code>fpga_ref</code> <code>int or float</code> <p>Reference clock generated for FPGA for specific converter</p> required <code>solution</code> <code>CpoSolveResult</code> <p>CPlex solution. Only needed for CPlex solver</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>Invalid PLL configuration.</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Union[List[Dict], Dict]</code> <p>Dictionary of clocking rates and dividers for configuration</p> Source code in <code>adijif/fpgas/xilinx.py</code> <pre><code>def get_config(\n    self,\n    converter: conv,\n    fpga_ref: Union[float, int],\n    solution: Optional[CpoSolveResult] = None,\n) -&gt; Union[List[Dict], Dict]:\n    \"\"\"Extract configurations from solver results.\n\n    Collect internal FPGA configuration and output clock definitions.\n\n    Args:\n        converter (conv): Converter object connected to FPGA who config is\n            collected\n        fpga_ref (int or float): Reference clock generated for FPGA for specific\n            converter\n        solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n    Raises:\n        Exception: Invalid PLL configuration.\n\n    Returns:\n        Dict: Dictionary of clocking rates and dividers for configuration\n    \"\"\"\n    out = []\n    if solution:\n        self.solution = solution\n\n    for config in self.configs:\n        pll_config: Dict[str, Union[str, int, float]] = {}\n\n        # Filter out other converters\n        if converter.name + \"_use_cpll\" not in config.keys():\n            continue\n        # pll = self._get_val(config[converter.name + \"qpll_0_cpll_1\"])\n        cpll = self._get_val(config[converter.name + \"_use_cpll\"]) &gt; 0\n        qpll = self._get_val(config[converter.name + \"_use_qpll\"]) &gt; 0\n        qpll1 = self._get_val(config[converter.name + \"_use_qpll1\"]) &gt; 0\n\n        if sum([cpll, qpll, qpll1]) != 1:\n            raise Exception(\n                \"More than one PLL selected\"\n                + \" can only be one of CPLL, QPLL, or QPLL1\"\n            )\n\n        if cpll &gt; 0:  # type: ignore\n            pll_config[\"type\"] = \"cpll\"\n            for k in [\"m\", \"d\", \"n1\", \"n2\"]:\n                pll_config[k] = self._get_val(config[converter.name + k + \"_cpll\"])\n\n            pll_config[\"vco\"] = (\n                fpga_ref * pll_config[\"n1\"] * pll_config[\"n2\"] / pll_config[\"m\"]  # type: ignore # noqa: B950\n            )\n            # Check\n            assert (\n                pll_config[\"vco\"] * 2 / pll_config[\"d\"] == converter.bit_clock  # type: ignore # noqa: B950\n            ), \"Invalid CPLL lane rate\"\n        else:\n            pll_name = \"qpll\" if qpll else \"qpll1\"\n            pll_config[\"type\"] = pll_name\n            pll_name = \"_\" + pll_name\n            if self.transciever_type in [\"GTY4\"]:\n                args = [\"m\", \"d\", \"band\"]\n            else:\n                args = [\"m\", \"d\", \"n\", \"band\"]\n\n            for k in args:\n                pll_config[k] = self._get_val(config[converter.name + k + pll_name])  # type: ignore # noqa: B950\n            pll_config[\"qty4_full_rate_enabled\"] = 1 - pll_config[\"band\"]  # type: ignore # noqa: B950\n\n            if self.transciever_type in [\"GTY4\"]:\n                pll_config[\"frac_mode\"] = not self._get_val(\n                    config[converter.name + \"qpll_frac_bypass\"]\n                )\n                pll_config[\"qpll_clkoutrate\"] = self._get_val(\n                    config[converter.name + \"qpll_clkoutrate\"]\n                )\n                pll_config[\"qpll_sdmdata\"] = self._get_val(\n                    config[converter.name + \"qpll_sdmdata\"]\n                )\n                pll_config[\"qpll_sdmwidth\"] = self._get_val(\n                    config[converter.name + \"qpll_sdmwidth\"]\n                )\n\n                pll_config[\"qpll_N_dot_frac\"] = self.solution.get_kpis()[\n                    converter.name + \"qpll_N_dot_frac\"\n                ]\n\n                config[\"vco\"] = self._add_intermediate(\n                    fpga_ref\n                    * pll_config[\"qpll_N_dot_frac\"]\n                    / (pll_config[\"m\"] * pll_config[\"qpll_clkoutrate\"])\n                )\n\n            else:\n                pll_config[\"vco\"] = fpga_ref * pll_config[\"n\"] / pll_config[\"m\"]  # type: ignore # noqa: B950\n\n        # SERDES output mux\n        if pll_config[\"type\"] == \"cpll\":\n            pll_config[\"sys_clk_select\"] = \"XCVR_CPLL\"\n        elif pll_config[\"type\"] == \"qpll\":\n            pll_config[\"sys_clk_select\"] = \"XCVR_QPLL0\"\n        elif pll_config[\"type\"] == \"qpll1\":\n            pll_config[\"sys_clk_select\"] = \"XCVR_QPLL1\"\n        else:\n            raise Exception(\"Invalid PLL type\")\n\n        if self._used_progdiv[converter.name]:\n            pll_config[\"progdiv\"] = self._used_progdiv[converter.name]\n            pll_config[\"out_clk_select\"] = \"XCVR_PROGDIV_CLK\"\n        else:\n            div = self._get_val(config[converter.name + \"_refclk_div\"])\n            pll_config[\"out_clk_select\"] = \"XCVR_REF_CLK\" if div == 1 else \"XCVR_REFCLK_DIV2\"  # type: ignore # noqa: B950\n\n        # if converter.Np == 12 or converter.F not in [\n        #     1,\n        #     2,\n        #     4,\n        # ]:  # self.requires_separate_link_layer_out_clock:\n\n        if self.requires_core_clock_from_device_clock:\n            pll_config[\"separate_device_clock_required\"] = True\n\n        else:\n            pll_config[\"separate_device_clock_required\"] = self._get_val(\n                config[converter.name + \"two_clks\"]\n            )\n\n            assert self._get_val(\n                config[converter.name + \"two_clks\"]\n            ) != self._get_val(\n                config[converter.name + \"single_clk\"]\n            ), \"Solver failed when trying to determine if two clocks are required\"\n            pll_config[\"transport_samples_per_clock\"] = self._get_val(\n                config[converter.name + \"_link_out_div\"]\n            )\n\n        if qpll or qpll1:\n            if self.transciever_type in [\"GTY4\"]:\n                pll_clk_out = (\n                    fpga_ref\n                    * pll_config[\"qpll_N_dot_frac\"]\n                    / (pll_config[\"m\"] * pll_config[\"qpll_clkoutrate\"])\n                )\n                lr = pll_clk_out * 2 / pll_config[\"d\"]\n                assert (\n                    lr == converter.bit_clock\n                ), f\"Invalid QPLL1 lane rate {lr} != {converter.bit_clock}\"  # type: ignore # noqa: B950\n\n            else:\n                div = self._get_val(\n                    config[converter.name + \"qty4_full_rate_divisor\"]\n                )\n                lr = (\n                    fpga_ref\n                    * div\n                    * pll_config[\"n\"]\n                    / (pll_config[\"m\"] * 1)\n                    * 1\n                    / pll_config[\"d\"]\n                )\n                assert (\n                    lr == converter.bit_clock\n                ), f\"Invalid QPLL1 lane rate {lr} != {converter.bit_clock}\"  # type: ignore # noqa: B950\n\n        # Check\n        if pll_config[\"out_clk_select\"] == \"XCVR_REF_CLK\" and not cpll:\n            assert (\n                pll_config[\"vco\"] == converter.bit_clock * pll_config[\"d\"]  # type: ignore # noqa: B950\n            ), \"Invalid QPLL lane rate {} != {}\".format(\n                pll_config[\"vco\"] / pll_config[\"d\"], converter.bit_clock  # type: ignore # noqa: B950\n            )\n\n        out.append(pll_config)\n\n    if len(out) == 1:\n        out = out[0]  # type: ignore\n    return out\n</code></pre>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.get_required_clock_names","title":"<code>get_required_clock_names()</code>","text":"<p>Get list of strings of names of requested clocks.</p> <p>This list of names is for the clocks defined by get_required_clocks</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of strings of clock names in order</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Clock have not been enumerated aka get_required_clocks not not called yet.</p> Source code in <code>adijif/fpgas/xilinx.py</code> <pre><code>def get_required_clock_names(self) -&gt; List[str]:\n    \"\"\"Get list of strings of names of requested clocks.\n\n    This list of names is for the clocks defined by get_required_clocks\n\n    Returns:\n        List[str]: List of strings of clock names in order\n\n    Raises:\n        Exception: Clock have not been enumerated aka get_required_clocks not\n            not called yet.\n    \"\"\"\n    if not self._clock_names:\n        raise Exception(\n            \"get_required_clocks must be run to generated\"\n            + \" dependent clocks before names are available\"\n        )\n    return self._clock_names\n</code></pre>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.get_required_clocks","title":"<code>get_required_clocks(converter, fpga_ref, link_out_ref=None)</code>","text":"<p>Get necessary clocks for QPLL/CPLL configuration.</p> <p>Parameters:</p> Name Type Description Default <code>converter</code> <code>converter</code> <p>Converter object of converter connected to FPGA</p> required <code>fpga_ref</code> <code>(int, GKVariable, GK_Intermediate, GK_Operators, CpoIntVar)</code> <p>Abstract or concrete reference to FPGA reference clock</p> required <code>link_out_ref</code> <code>int or GKVariable</code> <p>Reference clock generated for FPGA link layer output, also called device clock</p> <code>None</code> <p>Returns:</p> Name Type Description <code>List</code> <code>List</code> <p>List of solver variables and constraints</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If solver is not valid</p> <code>Exception</code> <p>Link layer out clock required</p> Source code in <code>adijif/fpgas/xilinx.py</code> <pre><code>def get_required_clocks(\n    self,\n    converter: conv,\n    fpga_ref: Union[int, GKVariable, GK_Intermediate, GK_Operators, CpoIntVar],\n    link_out_ref: Union[\n        int, GKVariable, GK_Intermediate, GK_Operators, CpoIntVar\n    ] = None,\n) -&gt; List:\n    \"\"\"Get necessary clocks for QPLL/CPLL configuration.\n\n    Args:\n        converter (conv): Converter object of converter connected to FPGA\n        fpga_ref (int, GKVariable, GK_Intermediate, GK_Operators, CpoIntVar):\n            Abstract or concrete reference to FPGA reference clock\n        link_out_ref (int or GKVariable): Reference clock generated for FPGA\n            link layer output, also called device clock\n\n    Returns:\n        List: List of solver variables and constraints\n\n    Raises:\n        Exception: If solver is not valid\n        Exception: Link layer out clock required\n    \"\"\"\n    if self.ref_clock_min == -1 or self.ref_clock_max == -1:\n        raise Exception(\"ref_clock_min or ref_clock_max not set\")\n    if \"_get_converters\" in dir(converter):\n        converter = (\n            converter._get_converters()  # type: ignore\n        )  # Handle nested converters\n\n    if not isinstance(converter, list):\n        converter = [converter]  # type: ignore\n\n    # if self.solver == \"gekko\":\n    #     self.config = {\n    #         \"fpga_ref\": self.model.Var(\n    #             # integer=True,\n    #             lb=self.ref_clock_min,\n    #             ub=self.ref_clock_max,\n    #             value=self.ref_clock_min,\n    #         )\n    #     }\n    # elif self.solver == \"CPLEX\":\n    #     # self.config = {\n    #     #     \"fpga_ref\": integer_var(\n    #     #         self.ref_clock_min, self.ref_clock_max, \"fpga_ref\"\n    #     #     )\n    #     # }\n    #     pass\n    # else:\n    #     raise Exception(f\"Unknown solver {self.solver}\")\n\n    # https://www.xilinx.com/support/documentation/user_guides/ug476_7Series_Transceivers.pdf # noqa: B950\n\n    # clock_names = [\"fpga_ref\"]\n    clock_names = []\n    self.config = {}\n    if self.force_single_quad_tile:\n        raise Exception(\"force_single_quad_tile==1 not implemented\")\n    else:\n        #######################\n        # self.configs = []\n        self.dev_clocks = []\n        self.ref_clocks = []\n        # obs = []\n        for cnv in converter:  # type: ignore\n            # rsl = self._get_conv_prop(\n            #     cnv, self.requires_separate_link_layer_out_clock\n            # )\n            # if link_out_ref is None and rsl:\n            #     raise Exception(\"Link layer out clock required\")\n\n            clock_names.append(cnv.name + \"fpga_ref\")\n            # self.config[cnv.name+\"fpga_ref\"] = interval_var(\n            #     self.ref_clock_min, self.ref_clock_max, name=cnv.name+\"fpga_ref\"\n            # )\n            self.config[cnv.name + \"fpga_ref\"] = fpga_ref\n            self.ref_clocks.append(self.config[cnv.name + \"fpga_ref\"])\n            if (\n                link_out_ref is not None\n            ):  # self.requires_separate_link_layer_out_clock:\n                self.config[cnv.name + \"link_out_ref\"] = link_out_ref\n                self.ref_clocks.append(self.config[cnv.name + \"link_out_ref\"])\n                config = self._setup_quad_tile(\n                    cnv,\n                    self.config[cnv.name + \"fpga_ref\"],\n                    self.config[cnv.name + \"link_out_ref\"],\n                )\n            else:\n                config = self._setup_quad_tile(\n                    cnv, self.config[cnv.name + \"fpga_ref\"]\n                )\n            # Set optimizations\n            # self.model.Obj(self.config[converter.name+\"d\"])\n            # self.model.Obj(self.config[converter.name+\"d_cpll\"])\n            # self.model.Obj(config[converter.name+\"d_select\"])\n            if self.favor_cpll_over_qpll:\n                if self.solver == \"gekko\":\n                    self.model.Obj(\n                        -1 * config[cnv.name + \"qpll_0_cpll_1\"]\n                    )  # Favor CPLL over QPLL\n                elif self.solver == \"CPLEX\":\n                    self.model.maximize(config[cnv.name + \"qpll_0_cpll_1\"])\n                    # obs.append(-1 * config[cnv.name + \"qpll_0_cpll_1\"])\n                else:\n                    raise Exception(f\"Unknown solver {self.solver}\")\n\n            self.configs.append(config)\n            # FPGA also requires clock at device clock rate\n            if self.request_device_clock:\n                self.dev_clocks.append(cnv.device_clock)\n                clock_names.append(cnv.name + \"_fpga_device_clock\")\n\n    if self.minimize_fpga_ref_clock:\n        if self.solver == \"gekko\":\n            self.model.Obj(self.config[cnv.name + \"fpga_ref\"])\n        elif self.solver == \"CPLEX\":\n            # self.model.minimize_static_lex(obs + [self.config[converter.name+\"fpga_ref\"]]) # noqa: B950\n            self.model.minimize(self.config[cnv.name + \"fpga_ref\"])  # noqa: B950\n            # self.model.maximize(obs + self.config[converter.name+\"fpga_ref\"])\n        else:\n            raise Exception(f\"Unknown solver {self.solver}\")\n\n    self._clock_names = clock_names\n\n    # return [self.config[\"fpga_ref\"]] + self.dev_clocks\n    return self.ref_clocks + self.dev_clocks\n</code></pre>"},{"location":"fpga_ref/#adijif.fpgas.xilinx.xilinx.setup_by_dev_kit_name","title":"<code>setup_by_dev_kit_name(name)</code>","text":"<p>Configure object based on board name. Ex: zc706, zcu102.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of dev kit. Ex: zc706, zcu102</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>Unsupported board requested.</p> Source code in <code>adijif/fpgas/xilinx.py</code> <pre><code>def setup_by_dev_kit_name(self, name: str) -&gt; None:\n    \"\"\"Configure object based on board name. Ex: zc706, zcu102.\n\n    Args:\n        name (str): Name of dev kit. Ex: zc706, zcu102\n\n    Raises:\n        Exception: Unsupported board requested.\n\n    \"\"\"\n    if name.lower() == \"zc706\":\n        self.transciever_type = \"GTX2\"\n        self.fpga_family = \"Zynq\"\n        self.fpga_package = \"FF\"\n        self.speed_grade = -2\n        self.ref_clock_min = 60000000\n        self.ref_clock_max = 670000000\n        self.max_serdes_lanes = 8\n        # default PROGDIV not available\n        o = self._out_clk_selections.copy()\n        del o[o.index(\"XCVR_PROGDIV_CLK\")]\n        self._out_clk_selections = o\n        self._out_clk_select = o\n    elif name.lower() == \"zcu102\":\n        self.transciever_type = \"GTH4\"\n        self.fpga_family = \"Zynq\"\n        self.fpga_package = \"FF\"\n        self.speed_grade = -2\n        self.ref_clock_min = 60000000\n        self.ref_clock_max = 820000000\n        self.max_serdes_lanes = 8\n    elif name.lower() == \"vcu118\":\n        # XCVU9P-L2FLGA2104\n        self.transciever_type = \"GTY4\"\n        self.fpga_family = \"Virtex\"\n        self.fpga_package = \"FL\"\n        self.speed_grade = -2\n        self.ref_clock_min = 60000000\n        self.ref_clock_max = 820000000\n        self.max_serdes_lanes = 24\n    else:\n        raise Exception(f\"No boardname found in library for {name}\")\n</code></pre>"},{"location":"fpgas/","title":"FPGA Configuration","text":"<p>FPGA clock models focus upon the PLLs inside different FPGA variants that drive different transceivers which connect to data converters. Currently, only specific Xilinx FPGA models are supported, but more are planned. However, the configurations determined by pyadi-jif are in the context of the ADI JESD Interface Framework and their related HDL cores. This is important since IP from different vendors have different supported modes.</p> <p>The FPGA models are similar to converter models but they require converter objects to be passed to them for configuration. From the converter objects the FPGA classes can derive the dependent clocks and JESD configuration. Due to this limitation, FPGA classes cannot be used standalone like data converter or clock chip classes.</p> <p>The second primary limitation is that the FPGA hardware model must be known and set beforehand. The FPGA hardware model determines clock ranges, internal PLL limits, and transceiver constraints. Since these can vary widely, making the internal solvers directly determine supported FPGAs would be a very burdensome task. However, pyadi-jif could be called in a loop to validate against different FPGA hardware models.</p> <p>pyadi-jif is not endorsed or verified by Xilinx or Intel</p>"},{"location":"fpgas/#xilinx-fpgas","title":"Xilinx FPGAs","text":"<p>For Xilinx FPGAs both 7000 and Ultrascale device types can be parameterized. However, since specifications can vary widely depending on chip model or board, extensive configuration needs to be provided. A pre-existing table of boards can be leveraged through the <code>setup_by_dev_kit_name</code> method. This includes support for:</p> <ul> <li>ZC706</li> <li>ZCU102</li> <li>VCU118</li> </ul> <p>Otherwise to manually configure an FPGA object requires setting the following:</p> <pre><code>fpga.transceiver_voltage = 800\nfpga.transciever_type = \"GTX2\"\nfpga.fpga_family = \"Zynq\"\nfpga.fpga_package = \"FF\"\nfpga.speed_grade = -2\nfpga.ref_clock_min = 60000000\nfpga.ref_clock_max = 670000000\nfpga.max_serdes_lanes = 8\n</code></pre>"},{"location":"fpgas/#selecting-qpll-or-cpll","title":"Selecting QPLL or CPLL","text":"<p>Both CPLL and QPLL types are supported and can either be automatically determined or forced to use either. This is done through two class properties:</p> <pre><code>sys = adijif.system(\"ad9680\", \"ad9523_1\", \"xilinx\", vcxo)\n...\nsys.fpga.force_cpll = 1 # Force use of CPLL\n# or\nsys.fpga.force_qpll = 1 # Force use of QPLL\n# or (Default) let solver select\nsys.fpga.force_cpll = 0\nsys.fpga.force_qpll = 0\n</code></pre> <p>The solver tries to use the CPLL since it is more flexible architecturally. For more detail on the 7000 Series PLL architecture consult ug476.</p>"},{"location":"fpgas/#current-known-limitations","title":"Current known limitations","text":"<ul> <li>When multiple converters are connected to the same FPGA, or RX and TX from the same converter, the solver does not force the clocks to come from a single QTile.</li> </ul>"},{"location":"fpgas/#intel-fpgas","title":"Intel FPGAs","text":"<p>None supported yet.</p>"},{"location":"fpgas/#example-usage","title":"Example usage","text":"<p>As mentioned the FPGA classes can not be used standalone. Therefore, the system class must be used when interfacing with the solvers. Below is a simple example based around using the AD-FMCDAQ2-EBZ and a Xilinx ZC706.</p> <pre><code># Create instance of system class with desired parts\nsys = adijif.system(\"ad9680\", \"ad9523_1\", \"xilinx\", 125000000)\n# Set Converter clocking requirements\nsys.converter.sample_clock = 1e9\nsys.converter.decimation = 1\nsys.converter.L = 4\nsys.converter.M = 2\nsys.converter.N = 14\nsys.converter.Np = 16\nsys.converter.K = 32\nsys.converter.F = 1\n# Set FPGA clocking requirements\nsys.fpga.setup_by_dev_kit_name(\"zc706\")\n# Call solver and collect configuration\nconfig = sys.solve()\npprint.pprint(config['fpga'])\n</code></pre> <p>Sample Output</p> <pre><code>{'band': 1.0,\n 'd': 1.0,\n 'm': 1.0,\n 'n': 100.0,\n 'qty4_full_rate_enabled': 0.0,\n 'type': 'qpll',\n 'vco': 10000000000.0}\n</code></pre> <p>The output in this case shows that the QPLL is used (probably required), the upper band related to VCO1 is used, and all the necessary dividers are provided for configuration.</p>"},{"location":"install/","title":"Installing PyADI-JIF","text":"<p>Before installing the module make sure  is installed. pyadi-jif has been validated to function on Windows, Linux, and MacOS. However, not all internal solvers function across all architectures. Specifically the CPLEX solver will not function under ARM. This does not limit functionality, only solving speed.</p>"},{"location":"install/#installing-from-pip-recommended","title":"Installing from pip (Recommended)","text":"<p>pyadi-jif can be installed from pip with all its dependencies: </p> <pre><code>$  pip install --index-url https://test.pypi.org/simple/ 'pyadi-jif[cplex]'\n\n---&gt; 100%\n</code></pre>"},{"location":"install/#installing-from-source","title":"Installing from source","text":"<p>Alternatively, pyadi-jif can be installed directly from source. This will require git to be installed</p> <pre><code>$ git clone https://github.com/analogdevicesinc/pyadi-jif.git\n\nCloning into 'pyadi-jif'...\nremote: Enumerating objects: 61, done.\nremote: Counting objects: 100% (61/61), done.\nremote: Compressing objects: 100% (53/53), done.\nremote: Total 1063 (delta 16), reused 30 (delta 8), pack-reused 1002\nReceiving objects: 100% (1063/1063), 553.66 KiB | 3.24 MiB/s, done.\nResolving deltas: 100% (681/681), done.\n\n$ cd pyadi-jif\n$ pip install .\n\n---&gt; 100%\n</code></pre> <p>pyadi-jif requires a solver to be installed. We recommend using CPLEX but most features will work with GEKKO.</p> <p>CPLEX: <pre><code>pip install --index-url https://test.pypi.org/simple/ 'pyadi-jif[cplex]'\n</code></pre></p> <p>GEKKO: <pre><code>pip install --index-url https://test.pypi.org/simple/ 'pyadi-jif[gekko]'\n</code></pre></p>"},{"location":"install/#developers","title":"Developers","text":"<p>For developers check out the Developers section.</p>"},{"location":"parts/","title":"Supported Parts","text":""},{"location":"parts/#data-converters","title":"Data Converters","text":"<ul> <li>AD9081</li> <li>AD9144</li> <li>AD9680</li> <li>ADRV9009</li> </ul>"},{"location":"parts/#clock-chips","title":"Clock Chips","text":"<ul> <li>AD9523-1</li> <li>AD9528</li> <li>AD9545</li> <li>HMC7044</li> <li>LTC6952</li> <li>LTC6953</li> </ul>"},{"location":"ref/","title":"Reference","text":"<p>AD9523-1 clock chip model.</p> <p>AD9528 clock chip model.</p> <p>HMC7044 clock chip model.</p>"},{"location":"ref/#adijif.clocks.ad9523.ad9523_1","title":"<code>ad9523_1</code>","text":"<p>               Bases: <code>ad9523_1_bf</code></p> <p>AD9523-1 clock chip model.</p> <p>This model currently supports VCXO+PLL2 configurations</p> Source code in <code>adijif/clocks/ad9523.py</code> <pre><code>class ad9523_1(ad9523_1_bf):\n    \"\"\"AD9523-1 clock chip model.\n\n    This model currently supports VCXO+PLL2 configurations\n    \"\"\"\n\n    # Ranges\n    m1_available = [3, 4, 5]\n    d_available = [*range(1, 1024)]\n    n2_available = [12, 16, 17, 20, 21, 22, 24, 25, 26, *range(28, 255)]\n    a_available = [*range(0, 4)]\n    b_available = [*range(3, 64)]\n    # N = (PxB) + A, P=4, A==[0,1,2,3], B=[3..63]\n    # See table 46 of DS for limits\n    r2_available = list(range(1, 31 + 1))\n\n    # Defaults\n    _m1: Union[List[int], int] = [3, 4, 5]\n    _d: Union[List[int], int] = [*range(1, 1024)]\n    _n2: Union[List[int], int] = [12, 16, 17, 20, 21, 22, 24, 25, 26, *range(28, 255)]\n    _r2: Union[List[int], int] = list(range(1, 31 + 1))\n\n    # Limits\n    vco_min = 2.94e9\n    vco_max = 3.1e9\n    pfd_max = 259e6\n\n    # State management\n    _clk_names: List[str] = []\n\n    minimize_feedback_dividers = True\n\n    \"\"\" Enable internal VCXO/PLL1 doubler \"\"\"\n    use_vcxo_double = False\n\n    vcxo: Union[int, float, CpoIntVar] = 125e6\n\n    @property\n    def m1(self) -&gt; Union[int, List[int]]:\n        \"\"\"VCO divider path 1.\n\n        Valid dividers are 3,4,5\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._m1\n\n    @m1.setter\n    def m1(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCO divider path 1.\n\n        Valid dividers are 3,4,5\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.m1_available, \"m1\")\n        self._m1 = value\n\n    @property\n    def d(self) -&gt; Union[int, List[int]]:\n        \"\"\"Output dividers.\n\n        Valid dividers are 1-&gt;1023\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._d\n\n    @d.setter\n    def d(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"Output dividers.\n\n        Valid dividers are 1-&gt;1023\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.d_available, \"d\")\n        self._d = value\n\n    @property\n    def n2(self) -&gt; Union[int, List[int]]:\n        \"\"\"n2: VCO feedback divider.\n\n        Valid dividers are 12, 16, 17, 20, 21, 22, 24, 25, 26, 28-&gt;255\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._n2\n\n    @n2.setter\n    def n2(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCO feedback divider.\n\n        Valid dividers are 12, 16, 17, 20, 21, 22, 24, 25, 26, 28-&gt;255\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.n2_available, \"n2\")\n        self._n2 = value\n\n    @property\n    def r2(self) -&gt; Union[int, List[int]]:\n        \"\"\"VCXO input dividers.\n\n        Valid dividers are 1-&gt;31\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._r2\n\n    @r2.setter\n    def r2(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCXO input dividers.\n\n        Valid dividers are 1-&gt;31\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.r2_available, \"r2\")\n        self._r2 = value\n\n    def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n        \"\"\"Extract configurations from solver results.\n\n        Collect internal clock chip configuration and output clock definitions\n        leading to connected devices (converters, FPGAs)\n\n        Args:\n            solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n        Returns:\n            Dict: Dictionary of clocking rates and dividers for configuration\n\n        Raises:\n            Exception: If solver is not called first\n        \"\"\"\n        if not self._clk_names:\n            raise Exception(\"set_requested_clocks must be called before get_config\")\n        for k in [\"out_dividers\", \"m1\", \"n2\", \"r2\"]:\n            if k not in self.config.keys():\n                raise Exception(\"Missing key: \" + str(k))\n\n        if solution:  # type: ignore\n            self.solution = solution\n        config: Dict = {\n            \"m1\": self._get_val(self.config[\"m1\"]),\n            \"n2\": self._get_val(self.config[\"n2\"]),\n            \"r2\": self._get_val(self.config[\"r2\"]),\n            \"out_dividers\": [self._get_val(x) for x in self.config[\"out_dividers\"]],\n            \"output_clocks\": [],\n        }\n\n        config[\"vcxo\"] = self._get_val(self.vcxo)  # pytype: disable=attribute-error\n        vcxo = config[\"vcxo\"]\n\n        clk = vcxo / config[\"r2\"] * config[\"n2\"] / config[\"m1\"]\n        output_cfg = {}\n        for i, div in enumerate(self.config[\"out_dividers\"]):\n            div = self._get_val(div)\n            rate = clk / div\n            output_cfg[self._clk_names[i]] = {\"rate\": rate, \"divider\": div}\n        config[\"output_clocks\"] = output_cfg\n        config[\"vco\"] = clk\n        config[\"part\"] = \"AD9523-1\"\n\n        return config\n\n    def _setup_solver_constraints(self, vcxo: Union[float, int, CpoIntVar]) -&gt; None:\n        \"\"\"Apply constraints to solver model.\n\n        Args:\n            vcxo (int): VCXO frequency in hertz\n\n        Raises:\n            Exception: Unknown solver\n        \"\"\"\n        self.config = {\n            \"r2\": self._convert_input(self._r2, \"r2\"),\n            \"m1\": self._convert_input(self._m1, \"m1\"),\n            \"n2\": self._convert_input(self._n2, \"n2\"),\n        }\n        if not isinstance(vcxo, (int, float)):\n            self.config[\"vcxo_set\"] = vcxo(self.model)  # type: ignore\n            vcxo = self.config[\"vcxo_set\"][\"range\"]\n        self.vcxo = vcxo\n\n        # PLL2 equations\n        self._add_equation(\n            [\n                vcxo / self.config[\"r2\"] &lt;= self.pfd_max,\n                vcxo / self.config[\"r2\"] * self.config[\"n2\"] &lt;= self.vco_max,\n                vcxo / self.config[\"r2\"] * self.config[\"n2\"] &gt;= self.vco_min,\n            ]\n        )\n        # Objectives\n        if self.minimize_feedback_dividers:\n            if self.solver == \"CPLEX\":\n                ...\n                # self.model.minimize(self.config[\"n2\"])\n                # cost = self.model\n                # self.model.minimize_static_lex([self.config[\"n2\"],])\n            elif self.solver == \"gekko\":\n                self.model.Obj(self.config[\"n2\"])\n            else:\n                raise Exception(\"Unknown solver {}\".format(self.solver))\n\n    def _add_objective(self, sys_refs: List[CpoIntVar]) -&gt; None:\n        # Minimize feedback divider and sysref frequencies\n        if self.minimize_feedback_dividers:\n            self._objectives = [self.config[\"n2\"]] + sys_refs\n            # self.model.add(\n            #     self.model.minimize_static_lex([self.config[\"n2\"]] + sys_refs)\n            # )\n        else:\n            self._objectives = [sys_refs]\n            # self.model.add(self.model.minimize_static_lex(sys_refs))\n\n    def _setup(self, vcxo: int) -&gt; None:\n        # Setup clock chip internal constraints\n\n        # FIXME: ADD SPLIT m1 configuration support\n\n        if self.use_vcxo_double and not isinstance(vcxo, int):\n            raise Exception(\"VCXO doubler not supported in this mode TBD\")\n        if self.use_vcxo_double:\n            vcxo *= 2\n        self._setup_solver_constraints(vcxo)\n        self.config[\"out_dividers\"] = []\n\n    def _get_clock_constraint(\n        self, clk_name: List[str]\n    ) -&gt; Union[int, float, CpoExpr, GK_Intermediate]:\n        \"\"\"Get abstract clock output.\n\n        Args:\n            clk_name (str):  String of clock name\n\n        Returns:\n            (int or float or CpoExpr or GK_Intermediate): Abstract\n                or concrete clock reference\n        \"\"\"\n        od = self._convert_input(self._d, \"d_\" + str(clk_name))\n        self.config[\"out_dividers\"].append(od)\n        return (\n            self.vcxo / self.config[\"r2\"] * self.config[\"n2\"] / self.config[\"m1\"] / od\n        )\n\n    def set_requested_clocks(\n        self, vcxo: int, out_freqs: List, clk_names: List[str]\n    ) -&gt; None:\n        \"\"\"Define necessary clocks to be generated in model.\n\n        Args:\n            vcxo (int): VCXO frequency in hertz\n            out_freqs (List): list of required clocks to be output\n            clk_names (List[str]):  list of strings of clock names\n\n        Raises:\n            Exception: If len(out_freqs) != len(clk_names)\n        \"\"\"\n        if len(clk_names) != len(out_freqs):\n            raise Exception(\"clk_names is not the same size as out_freqs\")\n        self._clk_names = clk_names\n\n        # Setup clock chip internal constraints\n        self._setup(vcxo)\n\n        # Add requested clocks to output constraints\n        for out_freq in out_freqs:\n            # od = self.model.Var(integer=True, lb=1, ub=1023, value=1)\n            od = self._convert_input(self._d, \"d_\" + str(out_freq))\n            # od = self.model.sos1([n*n for n in range(1,9)])\n\n            self._add_equation(\n                [\n                    self.vcxo\n                    / self.config[\"r2\"]\n                    * self.config[\"n2\"]\n                    / self.config[\"m1\"]\n                    / od\n                    == out_freq\n                ]\n            )\n            self.config[\"out_dividers\"].append(od)\n</code></pre>"},{"location":"ref/#adijif.clocks.ad9523.ad9523_1.d","title":"<code>d: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>Output dividers.</p> <p>Valid dividers are 1-&gt;1023</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"ref/#adijif.clocks.ad9523.ad9523_1.m1","title":"<code>m1: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>VCO divider path 1.</p> <p>Valid dividers are 3,4,5</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"ref/#adijif.clocks.ad9523.ad9523_1.minimize_feedback_dividers","title":"<code>minimize_feedback_dividers = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enable internal VCXO/PLL1 doubler</p>"},{"location":"ref/#adijif.clocks.ad9523.ad9523_1.n2","title":"<code>n2: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>n2: VCO feedback divider.</p> <p>Valid dividers are 12, 16, 17, 20, 21, 22, 24, 25, 26, 28-&gt;255</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"ref/#adijif.clocks.ad9523.ad9523_1.r2","title":"<code>r2: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>VCXO input dividers.</p> <p>Valid dividers are 1-&gt;31</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"ref/#adijif.clocks.ad9523.ad9523_1.get_config","title":"<code>get_config(solution=None)</code>","text":"<p>Extract configurations from solver results.</p> <p>Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs)</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>CpoSolveResult</code> <p>CPlex solution. Only needed for CPlex solver</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>Dictionary of clocking rates and dividers for configuration</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If solver is not called first</p> Source code in <code>adijif/clocks/ad9523.py</code> <pre><code>def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n    \"\"\"Extract configurations from solver results.\n\n    Collect internal clock chip configuration and output clock definitions\n    leading to connected devices (converters, FPGAs)\n\n    Args:\n        solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n    Returns:\n        Dict: Dictionary of clocking rates and dividers for configuration\n\n    Raises:\n        Exception: If solver is not called first\n    \"\"\"\n    if not self._clk_names:\n        raise Exception(\"set_requested_clocks must be called before get_config\")\n    for k in [\"out_dividers\", \"m1\", \"n2\", \"r2\"]:\n        if k not in self.config.keys():\n            raise Exception(\"Missing key: \" + str(k))\n\n    if solution:  # type: ignore\n        self.solution = solution\n    config: Dict = {\n        \"m1\": self._get_val(self.config[\"m1\"]),\n        \"n2\": self._get_val(self.config[\"n2\"]),\n        \"r2\": self._get_val(self.config[\"r2\"]),\n        \"out_dividers\": [self._get_val(x) for x in self.config[\"out_dividers\"]],\n        \"output_clocks\": [],\n    }\n\n    config[\"vcxo\"] = self._get_val(self.vcxo)  # pytype: disable=attribute-error\n    vcxo = config[\"vcxo\"]\n\n    clk = vcxo / config[\"r2\"] * config[\"n2\"] / config[\"m1\"]\n    output_cfg = {}\n    for i, div in enumerate(self.config[\"out_dividers\"]):\n        div = self._get_val(div)\n        rate = clk / div\n        output_cfg[self._clk_names[i]] = {\"rate\": rate, \"divider\": div}\n    config[\"output_clocks\"] = output_cfg\n    config[\"vco\"] = clk\n    config[\"part\"] = \"AD9523-1\"\n\n    return config\n</code></pre>"},{"location":"ref/#adijif.clocks.ad9523.ad9523_1.set_requested_clocks","title":"<code>set_requested_clocks(vcxo, out_freqs, clk_names)</code>","text":"<p>Define necessary clocks to be generated in model.</p> <p>Parameters:</p> Name Type Description Default <code>vcxo</code> <code>int</code> <p>VCXO frequency in hertz</p> required <code>out_freqs</code> <code>List</code> <p>list of required clocks to be output</p> required <code>clk_names</code> <code>List[str]</code> <p>list of strings of clock names</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If len(out_freqs) != len(clk_names)</p> Source code in <code>adijif/clocks/ad9523.py</code> <pre><code>def set_requested_clocks(\n    self, vcxo: int, out_freqs: List, clk_names: List[str]\n) -&gt; None:\n    \"\"\"Define necessary clocks to be generated in model.\n\n    Args:\n        vcxo (int): VCXO frequency in hertz\n        out_freqs (List): list of required clocks to be output\n        clk_names (List[str]):  list of strings of clock names\n\n    Raises:\n        Exception: If len(out_freqs) != len(clk_names)\n    \"\"\"\n    if len(clk_names) != len(out_freqs):\n        raise Exception(\"clk_names is not the same size as out_freqs\")\n    self._clk_names = clk_names\n\n    # Setup clock chip internal constraints\n    self._setup(vcxo)\n\n    # Add requested clocks to output constraints\n    for out_freq in out_freqs:\n        # od = self.model.Var(integer=True, lb=1, ub=1023, value=1)\n        od = self._convert_input(self._d, \"d_\" + str(out_freq))\n        # od = self.model.sos1([n*n for n in range(1,9)])\n\n        self._add_equation(\n            [\n                self.vcxo\n                / self.config[\"r2\"]\n                * self.config[\"n2\"]\n                / self.config[\"m1\"]\n                / od\n                == out_freq\n            ]\n        )\n        self.config[\"out_dividers\"].append(od)\n</code></pre>"},{"location":"ref/#adijif.clocks.ad9528.ad9528","title":"<code>ad9528</code>","text":"<p>               Bases: <code>ad9528_bf</code></p> <p>AD9528 clock chip model.</p> <p>This model currently supports VCXO+PLL2 configurations</p> Source code in <code>adijif/clocks/ad9528.py</code> <pre><code>class ad9528(ad9528_bf):\n    \"\"\"AD9528 clock chip model.\n\n    This model currently supports VCXO+PLL2 configurations\n    \"\"\"\n\n    # Ranges\n    \"\"\" VCO divider \"\"\"\n    m1_available = [3, 4, 5]\n    \"\"\" Output dividers \"\"\"\n    d_available = [*range(1, 1024)]\n    \"\"\" sysref dividers \"\"\"\n    k_available = [*range(0, 65536)]\n    \"\"\" VCXO multiplier \"\"\"\n    n2_available = [*range(1, 256)]\n    \"\"\" VCO calibration dividers \"\"\"\n    a_available = [0, 1, 2, 3]\n    b_availble = [*range(3, 64)]\n    # N = (PxB) + A, P=4, A==[0,1,2,3], B=[3..63]\n    # See table 46 of DS for limits\n    \"\"\" VCXO dividers \"\"\"\n    r1_available = [*range(1, 32)]\n\n    # State management\n    _clk_names: List[str] = []\n\n    # Defaults\n    _m1: Union[List[int], int] = [3, 4, 5]\n    _d: Union[List[int], int] = [*range(1, 1024)]\n    _k: Union[List[int], int] = k_available\n    _n2: Union[List[int], int] = n2_available\n    _r1: Union[List[int], int] = [*range(1, 32)]\n    _a: Union[List[int], int] = [*range(0, 4)]\n    _b: Union[List[int], int] = [*range(3, 64)]\n\n    # Limits\n    vco_min = 3450e6\n    vco_max = 4025e6\n    pfd_max = 275e6\n\n    minimize_feedback_dividers = True\n\n    use_vcxo_double = False\n    vcxo = 125e6\n\n    # sysref parameters\n    sysref_external = False\n    _sysref = None\n\n    @property\n    def m1(self) -&gt; Union[int, List[int]]:\n        \"\"\"VCO divider path 1.\n\n        Valid dividers are 3,4,5\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._m1\n\n    @m1.setter\n    def m1(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCO divider path 1.\n\n        Valid dividers are 3,4,5\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.m1_available, \"m1\")\n        self._m1 = value\n\n    @property\n    def d(self) -&gt; Union[int, List[int]]:\n        \"\"\"Output dividers.\n\n        Valid dividers are 1-&gt;1023\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._d\n\n    @d.setter\n    def d(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"Output dividers.\n\n        Valid dividers are 1-&gt;1023\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.d_available, \"d\")\n        self._d = value\n\n    @property\n    def k(self) -&gt; Union[int, List[int]]:\n        \"\"\"Sysref dividers.\n\n        Valid dividers are 0-&gt;65535\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._k\n\n    @k.setter\n    def k(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"Sysref dividers.\n\n        Valid dividers are 0-&gt;65535\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.d_available, \"k\")\n        self._k = value\n\n    @property\n    def n2(self) -&gt; Union[int, List[int]]:\n        \"\"\"n2: VCO feedback divider.\n\n        Valid dividers are 1-&gt;255\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._n2\n\n    @n2.setter\n    def n2(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCO feedback divider.\n\n        Valid dividers are 1-&gt;255\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.n2_available, \"n2\")\n        self._n2 = value\n\n    @property\n    def r1(self) -&gt; Union[int, List[int]]:\n        \"\"\"VCXO input dividers.\n\n        Valid dividers are 1-&gt;31\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._r1\n\n    @r1.setter\n    def r1(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCXO input dividers.\n\n        Valid dividers are 1-&gt;31\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.r1_available, \"r1\")\n        self._r1 = value\n\n    @property\n    def a(self) -&gt; Union[int, List[int]]:\n        \"\"\"VCO calibration divider 1.\n\n        Valid dividers are 0-&gt;3\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._a\n\n    @a.setter\n    def a(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCO calibration divider 1.\n\n        Valid dividers are 0-&gt;3\n\n        Args:\n            value (int, list[int]): Allowable values for counter\n\n        \"\"\"\n        self._check_in_range(value, self.a_available, \"a\")\n        self._a = value\n\n    @property\n    def b(self) -&gt; Union[int, List[int]]:\n        \"\"\"VCO calibration divider 2.\n\n        Valid dividers are 3-&gt;63\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._b\n\n    @b.setter\n    def b(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCO calibration divider 2.\n\n        Valid dividers are 3-&gt;63\n\n        Args:\n            value (int, list[int]): Allowable values for counter\n\n        \"\"\"\n        self._check_in_range(value, self.b_available, \"b\")\n        self._b = value\n\n    @property\n    def vco(self) -&gt; float:\n        \"\"\"VCO Frequency in Hz.\n\n        Returns:\n            float: computed VCO frequency\n        \"\"\"\n        r1 = self._get_val(self.config[\"r1\"])\n        m1 = self._get_val(self.config[\"m1\"])\n        n2 = self._get_val(self.config[\"n2\"])\n\n        return self.vcxo / r1 * m1 * n2\n\n    @property\n    def sysref(self) -&gt; int:\n        \"\"\"SYSREF Frequency in Hz.\n\n        Returns:\n            int: computed sysref frequency\n        \"\"\"\n        r1 = self._get_val(self.config[\"r1\"])\n        k = self._get_val(self.config[\"k\"])\n\n        if self.sysref_external:\n            sysref_src = self.vcxo\n        else:\n            sysref_src = self.vcxo / r1\n\n        return sysref_src / (2 * k)\n\n    @sysref.setter\n    def sysref(self, value: Union[int, float]) -&gt; None:\n        \"\"\"Set sysref frequency.\n\n        Args:\n            value (int, float): Frequency\n        \"\"\"\n        self._sysref = int(value)\n\n    def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n        \"\"\"Extract configurations from solver results.\n\n        Collect internal clock chip configuration and output clock definitions\n        leading to connected devices (converters, FPGAs)\n\n        Args:\n            solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n        Returns:\n            Dict: Dictionary of clocking rates and dividers for configuration\n\n        Raises:\n            Exception: If solver is not called first\n        \"\"\"\n        if not self._clk_names:\n            raise Exception(\"set_requested_clocks must be called before get_config\")\n\n        if solution:\n            self.solution = solution\n\n        # out_dividers = [solution.get_value(x) for x in self.config[\"out_dividers\"]]\n        out_dividers = [self._get_val(x) for x in self.config[\"out_dividers\"]]\n\n        config: Dict = {\n            \"vcxo\": self.vcxo / 2 if self.use_vcxo_double else self.vcxo,\n            \"vco\": self.vco,\n            \"r1\": self._get_val(self.config[\"r1\"]),\n            \"n2\": self._get_val(self.config[\"n2\"]),\n            \"m1\": self._get_val(self.config[\"m1\"]),\n            \"a\": self._get_val(self.config[\"a\"]),\n            \"b\": self._get_val(self.config[\"b\"]),\n            \"out_dividers\": out_dividers,\n            \"output_clocks\": [],\n        }\n\n        if self._sysref:\n            config[\"k\"] = self._get_val(self.config[\"k\"])\n            config[\"sysref\"] = self.sysref\n\n        clk = self.vcxo * config[\"n2\"] / config[\"r1\"]\n\n        output_cfg = {}\n        for i, div in enumerate(out_dividers):\n            rate = clk / div\n            output_cfg[self._clk_names[i]] = {\n                \"rate\": rate,\n                \"divider\": div,\n            }\n\n        config[\"output_clocks\"] = output_cfg\n        return config\n\n    def _setup_solver_constraints(self, vcxo: int) -&gt; None:\n        \"\"\"Apply constraints to solver model.\n\n        Args:\n            vcxo (int): VCXO frequency in hertz\n\n        Raises:\n            Exception: Unknown solver\n        \"\"\"\n        if not isinstance(vcxo, (float, int)):\n            vcxo = vcxo(self.model)\n            self.vcxo = vcxo[\"range\"]\n        else:\n            self.vcxo = vcxo\n\n        self.config = {\n            \"r1\": self._convert_input(self._r1, \"r1\"),\n            \"m1\": self._convert_input(self._m1, \"m1\"),\n            \"k\": self._convert_input(self._k, \"k\"),\n            \"n2\": self._convert_input(self._n2, \"n2\"),\n            \"a\": self._convert_input(self._a, \"a\"),\n            \"b\": self._convert_input(self._b, \"b\"),\n        }\n        # self.config = {\"r1\": self.model.Var(integer=True, lb=1, ub=31, value=1)}\n        # self.config[\"m1\"] = self.model.Var(integer=True, lb=3, ub=5, value=3)\n        # self.config[\"n2\"] = self.model.Var(integer=True, lb=12, ub=255, value=12)\n\n        # PLL2 equations\n        self._add_equation(\n            [\n                self.vcxo / self.config[\"r1\"] &lt;= self.pfd_max,\n                self.vcxo / self.config[\"r1\"] * self.config[\"m1\"] * self.config[\"n2\"]\n                &lt;= self.vco_max,\n                self.vcxo / self.config[\"r1\"] * self.config[\"m1\"] * self.config[\"n2\"]\n                &gt;= self.vco_min,\n                4 * self.config[\"b\"] + self.config[\"a\"] &gt;= 16,\n                4 * self.config[\"b\"] + self.config[\"a\"]\n                == self.config[\"m1\"] * self.config[\"n2\"],\n            ]\n        )\n        # Objectives\n        if self.minimize_feedback_dividers:\n            if self.solver == \"CPLEX\":\n                self._add_objective(self.config[\"n2\"])\n                # self.model.minimize(self.config[\"n2\"])\n            elif self.solver == \"gekko\":\n                self.model.Obj(self.config[\"n2\"])\n            else:\n                raise Exception(\"Unknown solver {}\".format(self.solver))\n        # self.model.Obj(self.config[\"n2\"] * self.config[\"m1\"])\n\n    def _setup(self, vcxo: int) -&gt; None:\n        # Setup clock chip internal constraints\n\n        # FIXME: ADD SPLIT m1 configuration support\n\n        # Setup clock chip internal constraints\n        if self.use_vcxo_double:\n            vcxo *= 2\n        self._setup_solver_constraints(vcxo)\n\n        # Add requested clocks to output constraints\n        self.config[\"out_dividers\"] = []\n\n    def _get_clock_constraint(\n        self, clk_name: str\n    ) -&gt; Union[int, float, CpoExpr, GK_Intermediate]:\n        \"\"\"Get abstract clock output.\n\n        Args:\n            clk_name (str):  String of clock name\n\n        Returns:\n            (int or float or CpoExpr or GK_Intermediate): Abstract\n                or concrete clock reference\n        \"\"\"\n        od = self._convert_input(self._d, \"d_\" + str(clk_name))\n        self.config[\"out_dividers\"].append(od)\n        return self.vcxo / self.config[\"r1\"] * self.config[\"n2\"] / od\n\n    def set_requested_clocks(\n        self,\n        vcxo: int,\n        out_freqs: List,\n        clk_names: List[str],\n    ) -&gt; None:\n        \"\"\"Define necessary clocks to be generated in model.\n\n        Args:\n            vcxo (int): VCXO frequency in hertz\n            out_freqs (List): list of required clocks to be output\n            clk_names (List[str]):  list of strings of clock names\n\n        Raises:\n            Exception: If len(out_freqs) != len(clk_names)\n        \"\"\"\n        if len(clk_names) != len(out_freqs):\n            raise Exception(\"clk_names is not the same size as out_freqs\")\n        self._clk_names = clk_names\n\n        # Setup clock chip internal constraints\n        self._setup(vcxo)\n\n        if self._sysref:\n            if self.sysref_external:\n                sysref_src = self.vcxo\n            else:\n                sysref_src = self.vcxo / self.config[\"r1\"]\n\n            self._add_equation([sysref_src / (2 * self.config[\"k\"]) == self._sysref])\n\n        # Add requested clocks to output constraints\n        for out_freq, name in zip(out_freqs, clk_names):  # noqa: B905\n            # od = self.model.Var(integer=True, lb=1, ub=256, value=1)\n            od = self._convert_input(self._d, f\"d_{name}_{out_freq}\")\n            # od = self.model.sos1([n*n for n in range(1,9)])\n            self._add_equation(\n                [self.vcxo / self.config[\"r1\"] * self.config[\"n2\"] / od == out_freq]\n            )\n            self.config[\"out_dividers\"].append(od)\n</code></pre>"},{"location":"ref/#adijif.clocks.ad9528.ad9528.a","title":"<code>a: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>VCO calibration divider 1.</p> <p>Valid dividers are 0-&gt;3</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"ref/#adijif.clocks.ad9528.ad9528.b","title":"<code>b: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>VCO calibration divider 2.</p> <p>Valid dividers are 3-&gt;63</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"ref/#adijif.clocks.ad9528.ad9528.b_availble","title":"<code>b_availble = [*range(3, 64)]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VCXO dividers</p>"},{"location":"ref/#adijif.clocks.ad9528.ad9528.d","title":"<code>d: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>Output dividers.</p> <p>Valid dividers are 1-&gt;1023</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"ref/#adijif.clocks.ad9528.ad9528.d_available","title":"<code>d_available = [*range(1, 1024)]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>sysref dividers</p>"},{"location":"ref/#adijif.clocks.ad9528.ad9528.k","title":"<code>k: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>Sysref dividers.</p> <p>Valid dividers are 0-&gt;65535</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"ref/#adijif.clocks.ad9528.ad9528.k_available","title":"<code>k_available = [*range(0, 65536)]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VCXO multiplier</p>"},{"location":"ref/#adijif.clocks.ad9528.ad9528.m1","title":"<code>m1: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>VCO divider path 1.</p> <p>Valid dividers are 3,4,5</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"ref/#adijif.clocks.ad9528.ad9528.m1_available","title":"<code>m1_available = [3, 4, 5]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Output dividers</p>"},{"location":"ref/#adijif.clocks.ad9528.ad9528.n2","title":"<code>n2: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>n2: VCO feedback divider.</p> <p>Valid dividers are 1-&gt;255</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"ref/#adijif.clocks.ad9528.ad9528.n2_available","title":"<code>n2_available = [*range(1, 256)]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VCO calibration dividers</p>"},{"location":"ref/#adijif.clocks.ad9528.ad9528.r1","title":"<code>r1: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>VCXO input dividers.</p> <p>Valid dividers are 1-&gt;31</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"ref/#adijif.clocks.ad9528.ad9528.sysref","title":"<code>sysref: int</code>  <code>property</code> <code>writable</code>","text":"<p>SYSREF Frequency in Hz.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>computed sysref frequency</p>"},{"location":"ref/#adijif.clocks.ad9528.ad9528.vco","title":"<code>vco: float</code>  <code>property</code>","text":"<p>VCO Frequency in Hz.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>computed VCO frequency</p>"},{"location":"ref/#adijif.clocks.ad9528.ad9528.get_config","title":"<code>get_config(solution=None)</code>","text":"<p>Extract configurations from solver results.</p> <p>Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs)</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>CpoSolveResult</code> <p>CPlex solution. Only needed for CPlex solver</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>Dictionary of clocking rates and dividers for configuration</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If solver is not called first</p> Source code in <code>adijif/clocks/ad9528.py</code> <pre><code>def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n    \"\"\"Extract configurations from solver results.\n\n    Collect internal clock chip configuration and output clock definitions\n    leading to connected devices (converters, FPGAs)\n\n    Args:\n        solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n    Returns:\n        Dict: Dictionary of clocking rates and dividers for configuration\n\n    Raises:\n        Exception: If solver is not called first\n    \"\"\"\n    if not self._clk_names:\n        raise Exception(\"set_requested_clocks must be called before get_config\")\n\n    if solution:\n        self.solution = solution\n\n    # out_dividers = [solution.get_value(x) for x in self.config[\"out_dividers\"]]\n    out_dividers = [self._get_val(x) for x in self.config[\"out_dividers\"]]\n\n    config: Dict = {\n        \"vcxo\": self.vcxo / 2 if self.use_vcxo_double else self.vcxo,\n        \"vco\": self.vco,\n        \"r1\": self._get_val(self.config[\"r1\"]),\n        \"n2\": self._get_val(self.config[\"n2\"]),\n        \"m1\": self._get_val(self.config[\"m1\"]),\n        \"a\": self._get_val(self.config[\"a\"]),\n        \"b\": self._get_val(self.config[\"b\"]),\n        \"out_dividers\": out_dividers,\n        \"output_clocks\": [],\n    }\n\n    if self._sysref:\n        config[\"k\"] = self._get_val(self.config[\"k\"])\n        config[\"sysref\"] = self.sysref\n\n    clk = self.vcxo * config[\"n2\"] / config[\"r1\"]\n\n    output_cfg = {}\n    for i, div in enumerate(out_dividers):\n        rate = clk / div\n        output_cfg[self._clk_names[i]] = {\n            \"rate\": rate,\n            \"divider\": div,\n        }\n\n    config[\"output_clocks\"] = output_cfg\n    return config\n</code></pre>"},{"location":"ref/#adijif.clocks.ad9528.ad9528.set_requested_clocks","title":"<code>set_requested_clocks(vcxo, out_freqs, clk_names)</code>","text":"<p>Define necessary clocks to be generated in model.</p> <p>Parameters:</p> Name Type Description Default <code>vcxo</code> <code>int</code> <p>VCXO frequency in hertz</p> required <code>out_freqs</code> <code>List</code> <p>list of required clocks to be output</p> required <code>clk_names</code> <code>List[str]</code> <p>list of strings of clock names</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If len(out_freqs) != len(clk_names)</p> Source code in <code>adijif/clocks/ad9528.py</code> <pre><code>def set_requested_clocks(\n    self,\n    vcxo: int,\n    out_freqs: List,\n    clk_names: List[str],\n) -&gt; None:\n    \"\"\"Define necessary clocks to be generated in model.\n\n    Args:\n        vcxo (int): VCXO frequency in hertz\n        out_freqs (List): list of required clocks to be output\n        clk_names (List[str]):  list of strings of clock names\n\n    Raises:\n        Exception: If len(out_freqs) != len(clk_names)\n    \"\"\"\n    if len(clk_names) != len(out_freqs):\n        raise Exception(\"clk_names is not the same size as out_freqs\")\n    self._clk_names = clk_names\n\n    # Setup clock chip internal constraints\n    self._setup(vcxo)\n\n    if self._sysref:\n        if self.sysref_external:\n            sysref_src = self.vcxo\n        else:\n            sysref_src = self.vcxo / self.config[\"r1\"]\n\n        self._add_equation([sysref_src / (2 * self.config[\"k\"]) == self._sysref])\n\n    # Add requested clocks to output constraints\n    for out_freq, name in zip(out_freqs, clk_names):  # noqa: B905\n        # od = self.model.Var(integer=True, lb=1, ub=256, value=1)\n        od = self._convert_input(self._d, f\"d_{name}_{out_freq}\")\n        # od = self.model.sos1([n*n for n in range(1,9)])\n        self._add_equation(\n            [self.vcxo / self.config[\"r1\"] * self.config[\"n2\"] / od == out_freq]\n        )\n        self.config[\"out_dividers\"].append(od)\n</code></pre>"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044","title":"<code>hmc7044</code>","text":"<p>               Bases: <code>hmc7044_bf</code></p> <p>HMC7044 clock chip model.</p> <p>This model currently supports VCXO+PLL2 configurations</p> Source code in <code>adijif/clocks/hmc7044.py</code> <pre><code>class hmc7044(hmc7044_bf):\n    \"\"\"HMC7044 clock chip model.\n\n    This model currently supports VCXO+PLL2 configurations\n    \"\"\"\n\n    # Ranges\n    # r2_divider_min = 1\n    # r2_divider_max = 4095\n    r2_available = [*range(1, 4095 + 1)]\n\n    \"\"\" Output dividers \"\"\"\n    d_available = [1, 3, 5, *range(2, 4095, 2)]\n    # When pulse generation is required (like for sysref) divder range\n    # is limited\n    d_syspulse_available = [*range(32, 4095, 2)]\n\n    # Defaults\n    _d: Union[int, List[int]] = [1, 3, 5, *range(2, 4095, 2)]\n    _r2: Union[int, List[int]] = [*range(1, 4095 + 1)]\n\n    # Limits\n    \"\"\" Internal limits \"\"\"\n    vco_min = 2400e6\n    vco_max = 3200e6\n    pfd_max = 250e6\n    vcxo_min = 10e6\n    vcxo_max = 500e6\n\n    use_vcxo_double = True\n    vxco_doubler_available = [1, 2]\n    _vxco_doubler = [1, 2]\n\n    minimize_feedback_dividers = True\n\n    # State management\n    _clk_names: List[str] = []\n\n    def __init__(\n        self, model: Union[GEKKO, CpoModel] = None, solver: str = \"CPLEX\"\n    ) -&gt; None:\n        \"\"\"Initialize HMC7044 clock chip model.\n\n        Args:\n            model (Model): Model to add constraints to\n            solver (str): Solver to use. Should be one of \"CPLEX\" or \"gekko\"\n\n        Raises:\n            Exception: Invalid solver\n        \"\"\"\n        super(hmc7044, self).__init__(model, solver)\n        if solver == \"gekko\":\n            self.n2_available = [*range(8, 65535 + 1)]\n            self._n2 = [*range(8, 65535 + 1)]\n        elif solver == \"CPLEX\":\n            self.n2_available = [*range(8, 65535 + 1)]\n            self._n2 = [*range(8, 65535 + 1)]\n        else:\n            raise Exception(\"Unknown solver {}\".format(solver))\n\n    @property\n    def d(self) -&gt; Union[int, List[int]]:\n        \"\"\"Output dividers.\n\n        Valid dividers are 1,2,3,4,5,6-&gt;(even)-&gt;4094\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._d\n\n    @d.setter\n    def d(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"Output dividers.\n\n        Valid dividers are 1,2,3,4,5,6-&gt;(even)-&gt;4094\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n        \"\"\"\n        self._check_in_range(value, self.d_available, \"d\")\n        self._d = value\n\n    @property\n    def n2(self) -&gt; Union[int, List[int]]:\n        \"\"\"n2: VCO feedback divider.\n\n        Valid dividers are 8-&gt;65536\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._n2\n\n    @n2.setter\n    def n2(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCO feedback divider.\n\n        Valid dividers are 8-&gt;65536\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n        \"\"\"\n        self._check_in_range(value, self.n2_available, \"n2\")\n        self._n2 = value\n\n    @property\n    def r2(self) -&gt; Union[int, List[int]]:\n        \"\"\"VCXO input dividers.\n\n        Valid dividers are 1-&gt;4096\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._r2\n\n    @r2.setter\n    def r2(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCXO input dividers.\n\n        Valid dividers are 1-&gt;4096\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n        \"\"\"\n        self._check_in_range(value, self.r2_available, \"r2\")\n        self._r2 = value\n\n    @property\n    def vxco_doubler(self) -&gt; Union[int, List[int]]:\n        \"\"\"VCXO doubler.\n\n        Valid dividers are 1,2\n\n        Returns:\n            int: Current doubler value\n        \"\"\"\n        return self._vxco_doubler\n\n    @vxco_doubler.setter\n    def vxco_doubler(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCXO doubler.\n\n        Valid dividers are 1,2\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.vxco_doubler_available, \"vxco_doubler\")\n        self._vxco_doubler = value\n\n    def _init_diagram(self) -&gt; None:\n        \"\"\"Initialize diagram for HMC7044 alone.\"\"\"\n        self.ic_diagram_node = None\n        self._diagram_output_dividers = []\n\n        # lo = Layout(\"HMC7044 Example\")\n\n        self.ic_diagram_node = Node(\"HMC7044\")\n        # lo.add_node(root)\n\n        # External\n        # ref_in = Node(\"REF_IN\", ntype=\"input\")\n        # lo.add_node(ref_in)\n\n        vcxo_doubler = Node(\"VCXO Doubler\", ntype=\"shell\")\n        self.ic_diagram_node.add_child(vcxo_doubler)\n\n        # Inside the IC\n        r2_div = Node(\"R2\", ntype=\"divider\")\n        # r2_div.value = \"2\"\n        self.ic_diagram_node.add_child(r2_div)\n        pfd = Node(\"PFD\", ntype=\"phase-frequency-detector\")\n        self.ic_diagram_node.add_child(pfd)\n        lf = Node(\"LF\", ntype=\"loop-filter\")\n        self.ic_diagram_node.add_child(lf)\n        vco = Node(\"VCO\", ntype=\"voltage-controlled-oscillator\")\n        vco.shape = \"circle\"\n        self.ic_diagram_node.add_child(vco)\n        n2 = Node(\"N2\", ntype=\"divider\")\n        self.ic_diagram_node.add_child(n2)\n\n        out_dividers = Node(\"Output Dividers\", ntype=\"shell\")\n        # ds = 4\n        # out_divs = []\n        # for i in range(ds):\n        #     div = Node(f\"D{i+1}\", ntype=\"divider\")\n        #     out_dividers.add_child(div)\n        #     out_divs.append(div)\n\n        self.ic_diagram_node.add_child(out_dividers)\n\n        # Connections inside the IC\n        # lo.add_connection({\"from\": ref_in, \"to\": r2_div, 'rate': 125000000})\n        self.ic_diagram_node.add_connection({\"from\": vcxo_doubler, \"to\": r2_div})\n        self.ic_diagram_node.add_connection(\n            {\"from\": r2_div, \"to\": pfd, \"rate\": 125000000 / 2}\n        )\n        self.ic_diagram_node.add_connection({\"from\": pfd, \"to\": lf})\n        self.ic_diagram_node.add_connection({\"from\": lf, \"to\": vco})\n        self.ic_diagram_node.add_connection({\"from\": vco, \"to\": n2})\n        self.ic_diagram_node.add_connection({\"from\": n2, \"to\": pfd})\n\n        self.ic_diagram_node.add_connection(\n            {\"from\": vco, \"to\": out_dividers, \"rate\": 4000000000}\n        )\n        # for div in out_divs:\n        #     self.ic_diagram_node.add_connection({\"from\": out_dividers, \"to\": div})\n        #     # root.add_connection({\"from\": vco, \"to\": div})\n\n    def _update_diagram(self, config: Dict) -&gt; None:\n        \"\"\"Update diagram with configuration.\n\n        Args:\n            config (Dict): Configuration dictionary\n\n        Raises:\n            Exception: If key is not D followed by a number\n        \"\"\"\n        # Add output dividers\n        keys = config.keys()\n        output_dividers = self.ic_diagram_node.get_child(\"Output Dividers\")\n        for key in keys:\n            if key.startswith(\"D\"):\n                div = Node(key, ntype=\"divider\")\n                output_dividers.add_child(div)\n                self.ic_diagram_node.add_connection(\n                    {\"from\": output_dividers, \"to\": div}\n                )\n            else:\n                raise Exception(\n                    f\"Unknown key {key}. Must be of for DX where X is a number\"\n                )\n\n    def draw(self) -&gt; str:\n        \"\"\"Draw diagram in d2 language for IC alone with reference clock.\n\n        Returns:\n            str: Diagram in d2 language\n\n        Raises:\n            Exception: If no solution is saved\n        \"\"\"\n        if not self._saved_solution:\n            raise Exception(\"No solution to draw. Must call solve first.\")\n        lo = Layout(\"HMC7044 Example\")\n        lo.add_node(self.ic_diagram_node)\n\n        ref_in = Node(\"REF_IN\", ntype=\"input\")\n        lo.add_node(ref_in)\n        vcxo_double = self.ic_diagram_node.get_child(\"VCXO Doubler\")\n        lo.add_connection(\n            {\"from\": ref_in, \"to\": vcxo_double, \"rate\": self._saved_solution[\"vcxo\"]}\n        )\n\n        # Update Node values\n        node = self.ic_diagram_node.get_child(\"VCXO Doubler\")\n        node.value = str(self._saved_solution[\"vcxo_doubler\"])\n        node = self.ic_diagram_node.get_child(\"R2\")\n        node.value = str(self._saved_solution[\"r2\"])\n        node = self.ic_diagram_node.get_child(\"N2\")\n        node.value = str(self._saved_solution[\"n2\"])\n\n        # Update VCXO Doubler to R2\n        # con = self.ic_diagram_node.get_connection(\"VCXO Doubler\", \"R2\")\n        rate = self._saved_solution[\"vcxo_doubler\"] * self._saved_solution[\"vcxo\"]\n        self.ic_diagram_node.update_connection(\"VCXO Doubler\", \"R2\", rate)\n\n        # Update R2 to PFD\n        # con = self.ic_diagram_node.get_connection(\"R2\", \"PFD\")\n        rate = (\n            self._saved_solution[\"vcxo\"]\n            * self._saved_solution[\"vcxo_doubler\"]\n            / self._saved_solution[\"r2\"]\n        )\n        self.ic_diagram_node.update_connection(\"R2\", \"PFD\", rate)\n\n        # Update VCO\n        # con = self.ic_diagram_node.get_connection(\"VCO\", \"Output Dividers\")\n        self.ic_diagram_node.update_connection(\n            \"VCO\", \"Output Dividers\", self._saved_solution[\"vco\"]\n        )\n\n        # Update diagram with dividers and rates\n        d = 0\n        output_dividers = self.ic_diagram_node.get_child(\"Output Dividers\")\n\n        for key, val in self._saved_solution[\"output_clocks\"].items():\n            clk_node = Node(key, ntype=\"divider\")\n            div_value = val[\"divider\"]\n            div = output_dividers.get_child(f\"D{d}\")\n            div.value = str(div_value)\n            d += 1\n            lo.add_node(clk_node)\n            lo.add_connection({\"from\": div, \"to\": clk_node, \"rate\": val[\"rate\"]})\n\n        return lo.draw()\n\n    def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n        \"\"\"Extract configurations from solver results.\n\n        Collect internal clock chip configuration and output clock definitions\n        leading to connected devices (converters, FPGAs)\n\n        Args:\n            solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n        Returns:\n            Dict: Dictionary of clocking rates and dividers for configuration\n\n        Raises:\n            Exception: If solver is not called first\n        \"\"\"\n        if not self._clk_names:\n            raise Exception(\"set_requested_clocks must be called before get_config\")\n\n        if solution:\n            self.solution = solution\n\n        out_dividers = [self._get_val(x) for x in self.config[\"out_dividers\"]]\n\n        config: Dict = {\n            \"r2\": self._get_val(self.config[\"r2\"]),\n            \"n2\": self._get_val(self.config[\"n2\"]),\n            \"out_dividers\": out_dividers,\n            \"output_clocks\": [],\n        }\n\n        if self.vcxo_i:\n            vcxo = self._get_val(self.vcxo_i[\"range\"])\n            self.vcxo = vcxo\n\n        clk = self.vcxo / config[\"r2\"] * config[\"n2\"]\n\n        output_cfg = {}\n        vd = self._get_val(self.config[\"vcxo_doubler\"])\n        for i, div in enumerate(out_dividers):\n            rate = vd * clk / div\n            output_cfg[self._clk_names[i]] = {\"rate\": rate, \"divider\": div}\n\n        config[\"output_clocks\"] = output_cfg\n        config[\"vco\"] = clk * vd\n        config[\"vcxo\"] = self.vcxo\n        config[\"vcxo_doubler\"] = vd\n\n        self._saved_solution = config\n\n        return config\n\n    def _setup_solver_constraints(self, vcxo: int) -&gt; None:\n        \"\"\"Apply constraints to solver model.\n\n        Args:\n            vcxo (int): VCXO frequency in hertz\n\n        Raises:\n            Exception: Invalid solver\n        \"\"\"\n        self.vcxo = vcxo\n\n        if self.solver == \"gekko\":\n            self.config = {\"r2\": self.model.Var(integer=True, lb=1, ub=4095, value=1)}\n            self.config[\"n2\"] = self.model.Var(integer=True, lb=8, ub=4095)\n            if isinstance(vcxo, (int, float)):\n                vcxo_var = self.model.Const(int(vcxo))\n            else:\n                vcxo_var = vcxo\n            self.config[\"vcxo_doubler\"] = self.model.sos1([1, 2])\n            self.config[\"vcxod\"] = self.model.Intermediate(\n                self.config[\"vcxo_doubler\"] * vcxo_var\n            )\n        elif self.solver == \"CPLEX\":\n            self.config = {\n                \"r2\": self._convert_input(self._r2, \"r2\"),\n                \"n2\": self._convert_input(self._n2, \"n2\"),\n            }\n            self.config[\"vcxo_doubler\"] = self._convert_input(\n                self._vxco_doubler, \"vcxo_doubler\"\n            )\n            self.config[\"vcxod\"] = self._add_intermediate(\n                self.config[\"vcxo_doubler\"] * vcxo\n            )\n        else:\n            raise Exception(\"Unknown solver {}\".format(self.solver))\n\n        # PLL2 equations\n        self._add_equation(\n            [\n                self.config[\"vcxod\"] &lt;= self.pfd_max * self.config[\"r2\"],\n                self.config[\"vcxod\"] * self.config[\"n2\"]\n                &lt;= self.vco_max * self.config[\"r2\"],\n                self.config[\"vcxod\"] * self.config[\"n2\"]\n                &gt;= self.vco_min * self.config[\"r2\"],\n            ]\n        )\n\n        # Objectives\n        if self.minimize_feedback_dividers:\n            if self.solver == \"CPLEX\":\n                self._add_objective(self.config[\"r2\"])\n                # self.model.minimize(self.config[\"r2\"])\n            elif self.solver == \"gekko\":\n                self.model.Obj(self.config[\"r2\"])\n            else:\n                raise Exception(\"Unknown solver {}\".format(self.solver))\n\n    def _setup(self, vcxo: int) -&gt; None:\n        # Setup clock chip internal constraints\n\n        # FIXME: ADD SPLIT m1 configuration support\n\n        # Convert VCXO into intermediate in case we have range type\n        if type(vcxo) not in [int, float]:\n            self.vcxo_i = vcxo(self.model)\n            vcxo = self.vcxo_i[\"range\"]\n        else:\n            self.vcxo_i = False\n\n        self._setup_solver_constraints(vcxo)\n\n        # Add requested clocks to output constraints\n        self.config[\"out_dividers\"] = []\n\n    def _get_clock_constraint(\n        self, clk_name: List[str]\n    ) -&gt; Union[int, float, CpoExpr, GK_Intermediate]:\n        \"\"\"Get abstract clock output.\n\n        Args:\n            clk_name (str):  String of clock name\n\n        Returns:\n            (int or float or CpoExpr or GK_Intermediate): Abstract\n                or concrete clock reference\n\n        Raises:\n            Exception: Invalid solver\n        \"\"\"\n        if self.solver == \"gekko\":\n            __d = self._d if isinstance(self._d, list) else [self._d]\n\n            if __d.sort() != self.d_available.sort():\n                raise Exception(\"For solver gekko d is not configurable for HMC7044\")\n\n            even = self.model.Var(integer=True, lb=3, ub=2047)\n            odd = self.model.Intermediate(even * 2)\n            od = self.model.sos1([1, 2, 3, 4, 5, odd])\n\n        elif self.solver == \"CPLEX\":\n            od = self._convert_input(self._d, \"d_\" + str(clk_name))\n        else:\n            raise Exception(\"Unknown solver {}\".format(self.solver))\n\n        self.config[\"out_dividers\"].append(od)\n        return self.config[\"vcxod\"] / self.config[\"r2\"] * self.config[\"n2\"] / od\n\n    def set_requested_clocks(\n        self, vcxo: int, out_freqs: List, clk_names: List[str]\n    ) -&gt; None:\n        \"\"\"Define necessary clocks to be generated in model.\n\n        Args:\n            vcxo (int): VCXO frequency in hertz\n            out_freqs (List): list of required clocks to be output\n            clk_names (List[str]):  list of strings of clock names\n\n        Raises:\n            Exception: If len(out_freqs) != len(clk_names)\n        \"\"\"\n        if len(clk_names) != len(out_freqs):\n            raise Exception(\"clk_names is not the same size as out_freqs\")\n        self._clk_names = clk_names\n\n        # Setup clock chip internal constraints\n        self._setup(vcxo)\n        # if type(self.vcxo) not in [int,float]:\n        #     vcxo = self.vcxo['range']\n\n        self._saved_solution = None\n\n        # Add requested clocks to output constraints\n        for d_n, out_freq in enumerate(out_freqs):\n            if self.solver == \"gekko\":\n                __d = self._d if isinstance(self._d, list) else [self._d]\n                if __d.sort() != self.d_available.sort():\n                    raise Exception(\n                        \"For solver gekko d is not configurable for HMC7044\"\n                    )\n\n                # even = self.model.Var(integer=True, lb=3, ub=2047)\n                # odd = self.model.Intermediate(even * 2)\n                # od = self.model.sos1([1, 2, 3, 4, 5, odd])\n\n                # Since d is so disjoint it is very annoying to solve.\n                even = self.model.Var(integer=True, lb=1, ub=4094 // 2)\n\n                # odd = self.model.sos1([1, 3, 5])\n                odd_i = self.model.Var(integer=True, lb=0, ub=2)\n                odd = self.model.Intermediate(1 + odd_i * 2)\n\n                eo = self.model.Var(integer=True, lb=0, ub=1)\n                od = self.model.Intermediate(eo * odd + (1 - eo) * even * 2)\n\n            elif self.solver == \"CPLEX\":\n                od = self._convert_input(self._d, f\"d_{out_freq}_{d_n}\")\n\n            self._add_equation(\n                [\n                    self.config[\"vcxod\"] * self.config[\"n2\"]\n                    == out_freq * self.config[\"r2\"] * od\n                ]\n            )\n            self.config[\"out_dividers\"].append(od)\n\n            # Update diagram to include new divider\n            self._update_diagram({f\"D{d_n}\": od})\n</code></pre>"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.d","title":"<code>d: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>Output dividers.</p> <p>Valid dividers are 1,2,3,4,5,6-&gt;(even)-&gt;4094</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.n2","title":"<code>n2: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>n2: VCO feedback divider.</p> <p>Valid dividers are 8-&gt;65536</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.r2","title":"<code>r2: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>VCXO input dividers.</p> <p>Valid dividers are 1-&gt;4096</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.r2_available","title":"<code>r2_available = [*range(1, 4095 + 1)]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Output dividers</p>"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.vxco_doubler","title":"<code>vxco_doubler: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>VCXO doubler.</p> <p>Valid dividers are 1,2</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current doubler value</p>"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.__init__","title":"<code>__init__(model=None, solver='CPLEX')</code>","text":"<p>Initialize HMC7044 clock chip model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>Model to add constraints to</p> <code>None</code> <code>solver</code> <code>str</code> <p>Solver to use. Should be one of \"CPLEX\" or \"gekko\"</p> <code>'CPLEX'</code> <p>Raises:</p> Type Description <code>Exception</code> <p>Invalid solver</p> Source code in <code>adijif/clocks/hmc7044.py</code> <pre><code>def __init__(\n    self, model: Union[GEKKO, CpoModel] = None, solver: str = \"CPLEX\"\n) -&gt; None:\n    \"\"\"Initialize HMC7044 clock chip model.\n\n    Args:\n        model (Model): Model to add constraints to\n        solver (str): Solver to use. Should be one of \"CPLEX\" or \"gekko\"\n\n    Raises:\n        Exception: Invalid solver\n    \"\"\"\n    super(hmc7044, self).__init__(model, solver)\n    if solver == \"gekko\":\n        self.n2_available = [*range(8, 65535 + 1)]\n        self._n2 = [*range(8, 65535 + 1)]\n    elif solver == \"CPLEX\":\n        self.n2_available = [*range(8, 65535 + 1)]\n        self._n2 = [*range(8, 65535 + 1)]\n    else:\n        raise Exception(\"Unknown solver {}\".format(solver))\n</code></pre>"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.draw","title":"<code>draw()</code>","text":"<p>Draw diagram in d2 language for IC alone with reference clock.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Diagram in d2 language</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no solution is saved</p> Source code in <code>adijif/clocks/hmc7044.py</code> <pre><code>def draw(self) -&gt; str:\n    \"\"\"Draw diagram in d2 language for IC alone with reference clock.\n\n    Returns:\n        str: Diagram in d2 language\n\n    Raises:\n        Exception: If no solution is saved\n    \"\"\"\n    if not self._saved_solution:\n        raise Exception(\"No solution to draw. Must call solve first.\")\n    lo = Layout(\"HMC7044 Example\")\n    lo.add_node(self.ic_diagram_node)\n\n    ref_in = Node(\"REF_IN\", ntype=\"input\")\n    lo.add_node(ref_in)\n    vcxo_double = self.ic_diagram_node.get_child(\"VCXO Doubler\")\n    lo.add_connection(\n        {\"from\": ref_in, \"to\": vcxo_double, \"rate\": self._saved_solution[\"vcxo\"]}\n    )\n\n    # Update Node values\n    node = self.ic_diagram_node.get_child(\"VCXO Doubler\")\n    node.value = str(self._saved_solution[\"vcxo_doubler\"])\n    node = self.ic_diagram_node.get_child(\"R2\")\n    node.value = str(self._saved_solution[\"r2\"])\n    node = self.ic_diagram_node.get_child(\"N2\")\n    node.value = str(self._saved_solution[\"n2\"])\n\n    # Update VCXO Doubler to R2\n    # con = self.ic_diagram_node.get_connection(\"VCXO Doubler\", \"R2\")\n    rate = self._saved_solution[\"vcxo_doubler\"] * self._saved_solution[\"vcxo\"]\n    self.ic_diagram_node.update_connection(\"VCXO Doubler\", \"R2\", rate)\n\n    # Update R2 to PFD\n    # con = self.ic_diagram_node.get_connection(\"R2\", \"PFD\")\n    rate = (\n        self._saved_solution[\"vcxo\"]\n        * self._saved_solution[\"vcxo_doubler\"]\n        / self._saved_solution[\"r2\"]\n    )\n    self.ic_diagram_node.update_connection(\"R2\", \"PFD\", rate)\n\n    # Update VCO\n    # con = self.ic_diagram_node.get_connection(\"VCO\", \"Output Dividers\")\n    self.ic_diagram_node.update_connection(\n        \"VCO\", \"Output Dividers\", self._saved_solution[\"vco\"]\n    )\n\n    # Update diagram with dividers and rates\n    d = 0\n    output_dividers = self.ic_diagram_node.get_child(\"Output Dividers\")\n\n    for key, val in self._saved_solution[\"output_clocks\"].items():\n        clk_node = Node(key, ntype=\"divider\")\n        div_value = val[\"divider\"]\n        div = output_dividers.get_child(f\"D{d}\")\n        div.value = str(div_value)\n        d += 1\n        lo.add_node(clk_node)\n        lo.add_connection({\"from\": div, \"to\": clk_node, \"rate\": val[\"rate\"]})\n\n    return lo.draw()\n</code></pre>"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.get_config","title":"<code>get_config(solution=None)</code>","text":"<p>Extract configurations from solver results.</p> <p>Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs)</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>CpoSolveResult</code> <p>CPlex solution. Only needed for CPlex solver</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>Dictionary of clocking rates and dividers for configuration</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If solver is not called first</p> Source code in <code>adijif/clocks/hmc7044.py</code> <pre><code>def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n    \"\"\"Extract configurations from solver results.\n\n    Collect internal clock chip configuration and output clock definitions\n    leading to connected devices (converters, FPGAs)\n\n    Args:\n        solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n    Returns:\n        Dict: Dictionary of clocking rates and dividers for configuration\n\n    Raises:\n        Exception: If solver is not called first\n    \"\"\"\n    if not self._clk_names:\n        raise Exception(\"set_requested_clocks must be called before get_config\")\n\n    if solution:\n        self.solution = solution\n\n    out_dividers = [self._get_val(x) for x in self.config[\"out_dividers\"]]\n\n    config: Dict = {\n        \"r2\": self._get_val(self.config[\"r2\"]),\n        \"n2\": self._get_val(self.config[\"n2\"]),\n        \"out_dividers\": out_dividers,\n        \"output_clocks\": [],\n    }\n\n    if self.vcxo_i:\n        vcxo = self._get_val(self.vcxo_i[\"range\"])\n        self.vcxo = vcxo\n\n    clk = self.vcxo / config[\"r2\"] * config[\"n2\"]\n\n    output_cfg = {}\n    vd = self._get_val(self.config[\"vcxo_doubler\"])\n    for i, div in enumerate(out_dividers):\n        rate = vd * clk / div\n        output_cfg[self._clk_names[i]] = {\"rate\": rate, \"divider\": div}\n\n    config[\"output_clocks\"] = output_cfg\n    config[\"vco\"] = clk * vd\n    config[\"vcxo\"] = self.vcxo\n    config[\"vcxo_doubler\"] = vd\n\n    self._saved_solution = config\n\n    return config\n</code></pre>"},{"location":"ref/#adijif.clocks.hmc7044.hmc7044.set_requested_clocks","title":"<code>set_requested_clocks(vcxo, out_freqs, clk_names)</code>","text":"<p>Define necessary clocks to be generated in model.</p> <p>Parameters:</p> Name Type Description Default <code>vcxo</code> <code>int</code> <p>VCXO frequency in hertz</p> required <code>out_freqs</code> <code>List</code> <p>list of required clocks to be output</p> required <code>clk_names</code> <code>List[str]</code> <p>list of strings of clock names</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If len(out_freqs) != len(clk_names)</p> Source code in <code>adijif/clocks/hmc7044.py</code> <pre><code>def set_requested_clocks(\n    self, vcxo: int, out_freqs: List, clk_names: List[str]\n) -&gt; None:\n    \"\"\"Define necessary clocks to be generated in model.\n\n    Args:\n        vcxo (int): VCXO frequency in hertz\n        out_freqs (List): list of required clocks to be output\n        clk_names (List[str]):  list of strings of clock names\n\n    Raises:\n        Exception: If len(out_freqs) != len(clk_names)\n    \"\"\"\n    if len(clk_names) != len(out_freqs):\n        raise Exception(\"clk_names is not the same size as out_freqs\")\n    self._clk_names = clk_names\n\n    # Setup clock chip internal constraints\n    self._setup(vcxo)\n    # if type(self.vcxo) not in [int,float]:\n    #     vcxo = self.vcxo['range']\n\n    self._saved_solution = None\n\n    # Add requested clocks to output constraints\n    for d_n, out_freq in enumerate(out_freqs):\n        if self.solver == \"gekko\":\n            __d = self._d if isinstance(self._d, list) else [self._d]\n            if __d.sort() != self.d_available.sort():\n                raise Exception(\n                    \"For solver gekko d is not configurable for HMC7044\"\n                )\n\n            # even = self.model.Var(integer=True, lb=3, ub=2047)\n            # odd = self.model.Intermediate(even * 2)\n            # od = self.model.sos1([1, 2, 3, 4, 5, odd])\n\n            # Since d is so disjoint it is very annoying to solve.\n            even = self.model.Var(integer=True, lb=1, ub=4094 // 2)\n\n            # odd = self.model.sos1([1, 3, 5])\n            odd_i = self.model.Var(integer=True, lb=0, ub=2)\n            odd = self.model.Intermediate(1 + odd_i * 2)\n\n            eo = self.model.Var(integer=True, lb=0, ub=1)\n            od = self.model.Intermediate(eo * odd + (1 - eo) * even * 2)\n\n        elif self.solver == \"CPLEX\":\n            od = self._convert_input(self._d, f\"d_{out_freq}_{d_n}\")\n\n        self._add_equation(\n            [\n                self.config[\"vcxod\"] * self.config[\"n2\"]\n                == out_freq * self.config[\"r2\"] * od\n            ]\n        )\n        self.config[\"out_dividers\"].append(od)\n\n        # Update diagram to include new divider\n        self._update_diagram({f\"D{d_n}\": od})\n</code></pre>"},{"location":"devs/clocks/","title":"Reference","text":"<p>AD9523-1 clock chip model.</p> <p>AD9528 clock chip model.</p> <p>HMC7044 clock chip model.</p>"},{"location":"devs/clocks/#adijif.clocks.ad9523.ad9523_1","title":"<code>ad9523_1</code>","text":"<p>               Bases: <code>ad9523_1_bf</code></p> <p>AD9523-1 clock chip model.</p> <p>This model currently supports VCXO+PLL2 configurations</p> Source code in <code>adijif/clocks/ad9523.py</code> <pre><code>class ad9523_1(ad9523_1_bf):\n    \"\"\"AD9523-1 clock chip model.\n\n    This model currently supports VCXO+PLL2 configurations\n    \"\"\"\n\n    # Ranges\n    m1_available = [3, 4, 5]\n    d_available = [*range(1, 1024)]\n    n2_available = [12, 16, 17, 20, 21, 22, 24, 25, 26, *range(28, 255)]\n    a_available = [*range(0, 4)]\n    b_available = [*range(3, 64)]\n    # N = (PxB) + A, P=4, A==[0,1,2,3], B=[3..63]\n    # See table 46 of DS for limits\n    r2_available = list(range(1, 31 + 1))\n\n    # Defaults\n    _m1: Union[List[int], int] = [3, 4, 5]\n    _d: Union[List[int], int] = [*range(1, 1024)]\n    _n2: Union[List[int], int] = [12, 16, 17, 20, 21, 22, 24, 25, 26, *range(28, 255)]\n    _r2: Union[List[int], int] = list(range(1, 31 + 1))\n\n    # Limits\n    vco_min = 2.94e9\n    vco_max = 3.1e9\n    pfd_max = 259e6\n\n    # State management\n    _clk_names: List[str] = []\n\n    minimize_feedback_dividers = True\n\n    \"\"\" Enable internal VCXO/PLL1 doubler \"\"\"\n    use_vcxo_double = False\n\n    vcxo: Union[int, float, CpoIntVar] = 125e6\n\n    @property\n    def m1(self) -&gt; Union[int, List[int]]:\n        \"\"\"VCO divider path 1.\n\n        Valid dividers are 3,4,5\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._m1\n\n    @m1.setter\n    def m1(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCO divider path 1.\n\n        Valid dividers are 3,4,5\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.m1_available, \"m1\")\n        self._m1 = value\n\n    @property\n    def d(self) -&gt; Union[int, List[int]]:\n        \"\"\"Output dividers.\n\n        Valid dividers are 1-&gt;1023\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._d\n\n    @d.setter\n    def d(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"Output dividers.\n\n        Valid dividers are 1-&gt;1023\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.d_available, \"d\")\n        self._d = value\n\n    @property\n    def n2(self) -&gt; Union[int, List[int]]:\n        \"\"\"n2: VCO feedback divider.\n\n        Valid dividers are 12, 16, 17, 20, 21, 22, 24, 25, 26, 28-&gt;255\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._n2\n\n    @n2.setter\n    def n2(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCO feedback divider.\n\n        Valid dividers are 12, 16, 17, 20, 21, 22, 24, 25, 26, 28-&gt;255\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.n2_available, \"n2\")\n        self._n2 = value\n\n    @property\n    def r2(self) -&gt; Union[int, List[int]]:\n        \"\"\"VCXO input dividers.\n\n        Valid dividers are 1-&gt;31\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._r2\n\n    @r2.setter\n    def r2(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCXO input dividers.\n\n        Valid dividers are 1-&gt;31\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.r2_available, \"r2\")\n        self._r2 = value\n\n    def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n        \"\"\"Extract configurations from solver results.\n\n        Collect internal clock chip configuration and output clock definitions\n        leading to connected devices (converters, FPGAs)\n\n        Args:\n            solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n        Returns:\n            Dict: Dictionary of clocking rates and dividers for configuration\n\n        Raises:\n            Exception: If solver is not called first\n        \"\"\"\n        if not self._clk_names:\n            raise Exception(\"set_requested_clocks must be called before get_config\")\n        for k in [\"out_dividers\", \"m1\", \"n2\", \"r2\"]:\n            if k not in self.config.keys():\n                raise Exception(\"Missing key: \" + str(k))\n\n        if solution:  # type: ignore\n            self.solution = solution\n        config: Dict = {\n            \"m1\": self._get_val(self.config[\"m1\"]),\n            \"n2\": self._get_val(self.config[\"n2\"]),\n            \"r2\": self._get_val(self.config[\"r2\"]),\n            \"out_dividers\": [self._get_val(x) for x in self.config[\"out_dividers\"]],\n            \"output_clocks\": [],\n        }\n\n        config[\"vcxo\"] = self._get_val(self.vcxo)  # pytype: disable=attribute-error\n        vcxo = config[\"vcxo\"]\n\n        clk = vcxo / config[\"r2\"] * config[\"n2\"] / config[\"m1\"]\n        output_cfg = {}\n        for i, div in enumerate(self.config[\"out_dividers\"]):\n            div = self._get_val(div)\n            rate = clk / div\n            output_cfg[self._clk_names[i]] = {\"rate\": rate, \"divider\": div}\n        config[\"output_clocks\"] = output_cfg\n        config[\"vco\"] = clk\n        config[\"part\"] = \"AD9523-1\"\n\n        return config\n\n    def _setup_solver_constraints(self, vcxo: Union[float, int, CpoIntVar]) -&gt; None:\n        \"\"\"Apply constraints to solver model.\n\n        Args:\n            vcxo (int): VCXO frequency in hertz\n\n        Raises:\n            Exception: Unknown solver\n        \"\"\"\n        self.config = {\n            \"r2\": self._convert_input(self._r2, \"r2\"),\n            \"m1\": self._convert_input(self._m1, \"m1\"),\n            \"n2\": self._convert_input(self._n2, \"n2\"),\n        }\n        if not isinstance(vcxo, (int, float)):\n            self.config[\"vcxo_set\"] = vcxo(self.model)  # type: ignore\n            vcxo = self.config[\"vcxo_set\"][\"range\"]\n        self.vcxo = vcxo\n\n        # PLL2 equations\n        self._add_equation(\n            [\n                vcxo / self.config[\"r2\"] &lt;= self.pfd_max,\n                vcxo / self.config[\"r2\"] * self.config[\"n2\"] &lt;= self.vco_max,\n                vcxo / self.config[\"r2\"] * self.config[\"n2\"] &gt;= self.vco_min,\n            ]\n        )\n        # Objectives\n        if self.minimize_feedback_dividers:\n            if self.solver == \"CPLEX\":\n                ...\n                # self.model.minimize(self.config[\"n2\"])\n                # cost = self.model\n                # self.model.minimize_static_lex([self.config[\"n2\"],])\n            elif self.solver == \"gekko\":\n                self.model.Obj(self.config[\"n2\"])\n            else:\n                raise Exception(\"Unknown solver {}\".format(self.solver))\n\n    def _add_objective(self, sys_refs: List[CpoIntVar]) -&gt; None:\n        # Minimize feedback divider and sysref frequencies\n        if self.minimize_feedback_dividers:\n            self._objectives = [self.config[\"n2\"]] + sys_refs\n            # self.model.add(\n            #     self.model.minimize_static_lex([self.config[\"n2\"]] + sys_refs)\n            # )\n        else:\n            self._objectives = [sys_refs]\n            # self.model.add(self.model.minimize_static_lex(sys_refs))\n\n    def _setup(self, vcxo: int) -&gt; None:\n        # Setup clock chip internal constraints\n\n        # FIXME: ADD SPLIT m1 configuration support\n\n        if self.use_vcxo_double and not isinstance(vcxo, int):\n            raise Exception(\"VCXO doubler not supported in this mode TBD\")\n        if self.use_vcxo_double:\n            vcxo *= 2\n        self._setup_solver_constraints(vcxo)\n        self.config[\"out_dividers\"] = []\n\n    def _get_clock_constraint(\n        self, clk_name: List[str]\n    ) -&gt; Union[int, float, CpoExpr, GK_Intermediate]:\n        \"\"\"Get abstract clock output.\n\n        Args:\n            clk_name (str):  String of clock name\n\n        Returns:\n            (int or float or CpoExpr or GK_Intermediate): Abstract\n                or concrete clock reference\n        \"\"\"\n        od = self._convert_input(self._d, \"d_\" + str(clk_name))\n        self.config[\"out_dividers\"].append(od)\n        return (\n            self.vcxo / self.config[\"r2\"] * self.config[\"n2\"] / self.config[\"m1\"] / od\n        )\n\n    def set_requested_clocks(\n        self, vcxo: int, out_freqs: List, clk_names: List[str]\n    ) -&gt; None:\n        \"\"\"Define necessary clocks to be generated in model.\n\n        Args:\n            vcxo (int): VCXO frequency in hertz\n            out_freqs (List): list of required clocks to be output\n            clk_names (List[str]):  list of strings of clock names\n\n        Raises:\n            Exception: If len(out_freqs) != len(clk_names)\n        \"\"\"\n        if len(clk_names) != len(out_freqs):\n            raise Exception(\"clk_names is not the same size as out_freqs\")\n        self._clk_names = clk_names\n\n        # Setup clock chip internal constraints\n        self._setup(vcxo)\n\n        # Add requested clocks to output constraints\n        for out_freq in out_freqs:\n            # od = self.model.Var(integer=True, lb=1, ub=1023, value=1)\n            od = self._convert_input(self._d, \"d_\" + str(out_freq))\n            # od = self.model.sos1([n*n for n in range(1,9)])\n\n            self._add_equation(\n                [\n                    self.vcxo\n                    / self.config[\"r2\"]\n                    * self.config[\"n2\"]\n                    / self.config[\"m1\"]\n                    / od\n                    == out_freq\n                ]\n            )\n            self.config[\"out_dividers\"].append(od)\n</code></pre>"},{"location":"devs/clocks/#adijif.clocks.ad9523.ad9523_1.d","title":"<code>d: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>Output dividers.</p> <p>Valid dividers are 1-&gt;1023</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"devs/clocks/#adijif.clocks.ad9523.ad9523_1.m1","title":"<code>m1: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>VCO divider path 1.</p> <p>Valid dividers are 3,4,5</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"devs/clocks/#adijif.clocks.ad9523.ad9523_1.minimize_feedback_dividers","title":"<code>minimize_feedback_dividers = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enable internal VCXO/PLL1 doubler</p>"},{"location":"devs/clocks/#adijif.clocks.ad9523.ad9523_1.n2","title":"<code>n2: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>n2: VCO feedback divider.</p> <p>Valid dividers are 12, 16, 17, 20, 21, 22, 24, 25, 26, 28-&gt;255</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"devs/clocks/#adijif.clocks.ad9523.ad9523_1.r2","title":"<code>r2: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>VCXO input dividers.</p> <p>Valid dividers are 1-&gt;31</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"devs/clocks/#adijif.clocks.ad9523.ad9523_1.get_config","title":"<code>get_config(solution=None)</code>","text":"<p>Extract configurations from solver results.</p> <p>Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs)</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>CpoSolveResult</code> <p>CPlex solution. Only needed for CPlex solver</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>Dictionary of clocking rates and dividers for configuration</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If solver is not called first</p> Source code in <code>adijif/clocks/ad9523.py</code> <pre><code>def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n    \"\"\"Extract configurations from solver results.\n\n    Collect internal clock chip configuration and output clock definitions\n    leading to connected devices (converters, FPGAs)\n\n    Args:\n        solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n    Returns:\n        Dict: Dictionary of clocking rates and dividers for configuration\n\n    Raises:\n        Exception: If solver is not called first\n    \"\"\"\n    if not self._clk_names:\n        raise Exception(\"set_requested_clocks must be called before get_config\")\n    for k in [\"out_dividers\", \"m1\", \"n2\", \"r2\"]:\n        if k not in self.config.keys():\n            raise Exception(\"Missing key: \" + str(k))\n\n    if solution:  # type: ignore\n        self.solution = solution\n    config: Dict = {\n        \"m1\": self._get_val(self.config[\"m1\"]),\n        \"n2\": self._get_val(self.config[\"n2\"]),\n        \"r2\": self._get_val(self.config[\"r2\"]),\n        \"out_dividers\": [self._get_val(x) for x in self.config[\"out_dividers\"]],\n        \"output_clocks\": [],\n    }\n\n    config[\"vcxo\"] = self._get_val(self.vcxo)  # pytype: disable=attribute-error\n    vcxo = config[\"vcxo\"]\n\n    clk = vcxo / config[\"r2\"] * config[\"n2\"] / config[\"m1\"]\n    output_cfg = {}\n    for i, div in enumerate(self.config[\"out_dividers\"]):\n        div = self._get_val(div)\n        rate = clk / div\n        output_cfg[self._clk_names[i]] = {\"rate\": rate, \"divider\": div}\n    config[\"output_clocks\"] = output_cfg\n    config[\"vco\"] = clk\n    config[\"part\"] = \"AD9523-1\"\n\n    return config\n</code></pre>"},{"location":"devs/clocks/#adijif.clocks.ad9523.ad9523_1.set_requested_clocks","title":"<code>set_requested_clocks(vcxo, out_freqs, clk_names)</code>","text":"<p>Define necessary clocks to be generated in model.</p> <p>Parameters:</p> Name Type Description Default <code>vcxo</code> <code>int</code> <p>VCXO frequency in hertz</p> required <code>out_freqs</code> <code>List</code> <p>list of required clocks to be output</p> required <code>clk_names</code> <code>List[str]</code> <p>list of strings of clock names</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If len(out_freqs) != len(clk_names)</p> Source code in <code>adijif/clocks/ad9523.py</code> <pre><code>def set_requested_clocks(\n    self, vcxo: int, out_freqs: List, clk_names: List[str]\n) -&gt; None:\n    \"\"\"Define necessary clocks to be generated in model.\n\n    Args:\n        vcxo (int): VCXO frequency in hertz\n        out_freqs (List): list of required clocks to be output\n        clk_names (List[str]):  list of strings of clock names\n\n    Raises:\n        Exception: If len(out_freqs) != len(clk_names)\n    \"\"\"\n    if len(clk_names) != len(out_freqs):\n        raise Exception(\"clk_names is not the same size as out_freqs\")\n    self._clk_names = clk_names\n\n    # Setup clock chip internal constraints\n    self._setup(vcxo)\n\n    # Add requested clocks to output constraints\n    for out_freq in out_freqs:\n        # od = self.model.Var(integer=True, lb=1, ub=1023, value=1)\n        od = self._convert_input(self._d, \"d_\" + str(out_freq))\n        # od = self.model.sos1([n*n for n in range(1,9)])\n\n        self._add_equation(\n            [\n                self.vcxo\n                / self.config[\"r2\"]\n                * self.config[\"n2\"]\n                / self.config[\"m1\"]\n                / od\n                == out_freq\n            ]\n        )\n        self.config[\"out_dividers\"].append(od)\n</code></pre>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528","title":"<code>ad9528</code>","text":"<p>               Bases: <code>ad9528_bf</code></p> <p>AD9528 clock chip model.</p> <p>This model currently supports VCXO+PLL2 configurations</p> Source code in <code>adijif/clocks/ad9528.py</code> <pre><code>class ad9528(ad9528_bf):\n    \"\"\"AD9528 clock chip model.\n\n    This model currently supports VCXO+PLL2 configurations\n    \"\"\"\n\n    # Ranges\n    \"\"\" VCO divider \"\"\"\n    m1_available = [3, 4, 5]\n    \"\"\" Output dividers \"\"\"\n    d_available = [*range(1, 1024)]\n    \"\"\" sysref dividers \"\"\"\n    k_available = [*range(0, 65536)]\n    \"\"\" VCXO multiplier \"\"\"\n    n2_available = [*range(1, 256)]\n    \"\"\" VCO calibration dividers \"\"\"\n    a_available = [0, 1, 2, 3]\n    b_availble = [*range(3, 64)]\n    # N = (PxB) + A, P=4, A==[0,1,2,3], B=[3..63]\n    # See table 46 of DS for limits\n    \"\"\" VCXO dividers \"\"\"\n    r1_available = [*range(1, 32)]\n\n    # State management\n    _clk_names: List[str] = []\n\n    # Defaults\n    _m1: Union[List[int], int] = [3, 4, 5]\n    _d: Union[List[int], int] = [*range(1, 1024)]\n    _k: Union[List[int], int] = k_available\n    _n2: Union[List[int], int] = n2_available\n    _r1: Union[List[int], int] = [*range(1, 32)]\n    _a: Union[List[int], int] = [*range(0, 4)]\n    _b: Union[List[int], int] = [*range(3, 64)]\n\n    # Limits\n    vco_min = 3450e6\n    vco_max = 4025e6\n    pfd_max = 275e6\n\n    minimize_feedback_dividers = True\n\n    use_vcxo_double = False\n    vcxo = 125e6\n\n    # sysref parameters\n    sysref_external = False\n    _sysref = None\n\n    @property\n    def m1(self) -&gt; Union[int, List[int]]:\n        \"\"\"VCO divider path 1.\n\n        Valid dividers are 3,4,5\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._m1\n\n    @m1.setter\n    def m1(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCO divider path 1.\n\n        Valid dividers are 3,4,5\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.m1_available, \"m1\")\n        self._m1 = value\n\n    @property\n    def d(self) -&gt; Union[int, List[int]]:\n        \"\"\"Output dividers.\n\n        Valid dividers are 1-&gt;1023\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._d\n\n    @d.setter\n    def d(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"Output dividers.\n\n        Valid dividers are 1-&gt;1023\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.d_available, \"d\")\n        self._d = value\n\n    @property\n    def k(self) -&gt; Union[int, List[int]]:\n        \"\"\"Sysref dividers.\n\n        Valid dividers are 0-&gt;65535\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._k\n\n    @k.setter\n    def k(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"Sysref dividers.\n\n        Valid dividers are 0-&gt;65535\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.d_available, \"k\")\n        self._k = value\n\n    @property\n    def n2(self) -&gt; Union[int, List[int]]:\n        \"\"\"n2: VCO feedback divider.\n\n        Valid dividers are 1-&gt;255\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._n2\n\n    @n2.setter\n    def n2(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCO feedback divider.\n\n        Valid dividers are 1-&gt;255\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.n2_available, \"n2\")\n        self._n2 = value\n\n    @property\n    def r1(self) -&gt; Union[int, List[int]]:\n        \"\"\"VCXO input dividers.\n\n        Valid dividers are 1-&gt;31\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._r1\n\n    @r1.setter\n    def r1(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCXO input dividers.\n\n        Valid dividers are 1-&gt;31\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.r1_available, \"r1\")\n        self._r1 = value\n\n    @property\n    def a(self) -&gt; Union[int, List[int]]:\n        \"\"\"VCO calibration divider 1.\n\n        Valid dividers are 0-&gt;3\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._a\n\n    @a.setter\n    def a(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCO calibration divider 1.\n\n        Valid dividers are 0-&gt;3\n\n        Args:\n            value (int, list[int]): Allowable values for counter\n\n        \"\"\"\n        self._check_in_range(value, self.a_available, \"a\")\n        self._a = value\n\n    @property\n    def b(self) -&gt; Union[int, List[int]]:\n        \"\"\"VCO calibration divider 2.\n\n        Valid dividers are 3-&gt;63\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._b\n\n    @b.setter\n    def b(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCO calibration divider 2.\n\n        Valid dividers are 3-&gt;63\n\n        Args:\n            value (int, list[int]): Allowable values for counter\n\n        \"\"\"\n        self._check_in_range(value, self.b_available, \"b\")\n        self._b = value\n\n    @property\n    def vco(self) -&gt; float:\n        \"\"\"VCO Frequency in Hz.\n\n        Returns:\n            float: computed VCO frequency\n        \"\"\"\n        r1 = self._get_val(self.config[\"r1\"])\n        m1 = self._get_val(self.config[\"m1\"])\n        n2 = self._get_val(self.config[\"n2\"])\n\n        return self.vcxo / r1 * m1 * n2\n\n    @property\n    def sysref(self) -&gt; int:\n        \"\"\"SYSREF Frequency in Hz.\n\n        Returns:\n            int: computed sysref frequency\n        \"\"\"\n        r1 = self._get_val(self.config[\"r1\"])\n        k = self._get_val(self.config[\"k\"])\n\n        if self.sysref_external:\n            sysref_src = self.vcxo\n        else:\n            sysref_src = self.vcxo / r1\n\n        return sysref_src / (2 * k)\n\n    @sysref.setter\n    def sysref(self, value: Union[int, float]) -&gt; None:\n        \"\"\"Set sysref frequency.\n\n        Args:\n            value (int, float): Frequency\n        \"\"\"\n        self._sysref = int(value)\n\n    def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n        \"\"\"Extract configurations from solver results.\n\n        Collect internal clock chip configuration and output clock definitions\n        leading to connected devices (converters, FPGAs)\n\n        Args:\n            solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n        Returns:\n            Dict: Dictionary of clocking rates and dividers for configuration\n\n        Raises:\n            Exception: If solver is not called first\n        \"\"\"\n        if not self._clk_names:\n            raise Exception(\"set_requested_clocks must be called before get_config\")\n\n        if solution:\n            self.solution = solution\n\n        # out_dividers = [solution.get_value(x) for x in self.config[\"out_dividers\"]]\n        out_dividers = [self._get_val(x) for x in self.config[\"out_dividers\"]]\n\n        config: Dict = {\n            \"vcxo\": self.vcxo / 2 if self.use_vcxo_double else self.vcxo,\n            \"vco\": self.vco,\n            \"r1\": self._get_val(self.config[\"r1\"]),\n            \"n2\": self._get_val(self.config[\"n2\"]),\n            \"m1\": self._get_val(self.config[\"m1\"]),\n            \"a\": self._get_val(self.config[\"a\"]),\n            \"b\": self._get_val(self.config[\"b\"]),\n            \"out_dividers\": out_dividers,\n            \"output_clocks\": [],\n        }\n\n        if self._sysref:\n            config[\"k\"] = self._get_val(self.config[\"k\"])\n            config[\"sysref\"] = self.sysref\n\n        clk = self.vcxo * config[\"n2\"] / config[\"r1\"]\n\n        output_cfg = {}\n        for i, div in enumerate(out_dividers):\n            rate = clk / div\n            output_cfg[self._clk_names[i]] = {\n                \"rate\": rate,\n                \"divider\": div,\n            }\n\n        config[\"output_clocks\"] = output_cfg\n        return config\n\n    def _setup_solver_constraints(self, vcxo: int) -&gt; None:\n        \"\"\"Apply constraints to solver model.\n\n        Args:\n            vcxo (int): VCXO frequency in hertz\n\n        Raises:\n            Exception: Unknown solver\n        \"\"\"\n        if not isinstance(vcxo, (float, int)):\n            vcxo = vcxo(self.model)\n            self.vcxo = vcxo[\"range\"]\n        else:\n            self.vcxo = vcxo\n\n        self.config = {\n            \"r1\": self._convert_input(self._r1, \"r1\"),\n            \"m1\": self._convert_input(self._m1, \"m1\"),\n            \"k\": self._convert_input(self._k, \"k\"),\n            \"n2\": self._convert_input(self._n2, \"n2\"),\n            \"a\": self._convert_input(self._a, \"a\"),\n            \"b\": self._convert_input(self._b, \"b\"),\n        }\n        # self.config = {\"r1\": self.model.Var(integer=True, lb=1, ub=31, value=1)}\n        # self.config[\"m1\"] = self.model.Var(integer=True, lb=3, ub=5, value=3)\n        # self.config[\"n2\"] = self.model.Var(integer=True, lb=12, ub=255, value=12)\n\n        # PLL2 equations\n        self._add_equation(\n            [\n                self.vcxo / self.config[\"r1\"] &lt;= self.pfd_max,\n                self.vcxo / self.config[\"r1\"] * self.config[\"m1\"] * self.config[\"n2\"]\n                &lt;= self.vco_max,\n                self.vcxo / self.config[\"r1\"] * self.config[\"m1\"] * self.config[\"n2\"]\n                &gt;= self.vco_min,\n                4 * self.config[\"b\"] + self.config[\"a\"] &gt;= 16,\n                4 * self.config[\"b\"] + self.config[\"a\"]\n                == self.config[\"m1\"] * self.config[\"n2\"],\n            ]\n        )\n        # Objectives\n        if self.minimize_feedback_dividers:\n            if self.solver == \"CPLEX\":\n                self._add_objective(self.config[\"n2\"])\n                # self.model.minimize(self.config[\"n2\"])\n            elif self.solver == \"gekko\":\n                self.model.Obj(self.config[\"n2\"])\n            else:\n                raise Exception(\"Unknown solver {}\".format(self.solver))\n        # self.model.Obj(self.config[\"n2\"] * self.config[\"m1\"])\n\n    def _setup(self, vcxo: int) -&gt; None:\n        # Setup clock chip internal constraints\n\n        # FIXME: ADD SPLIT m1 configuration support\n\n        # Setup clock chip internal constraints\n        if self.use_vcxo_double:\n            vcxo *= 2\n        self._setup_solver_constraints(vcxo)\n\n        # Add requested clocks to output constraints\n        self.config[\"out_dividers\"] = []\n\n    def _get_clock_constraint(\n        self, clk_name: str\n    ) -&gt; Union[int, float, CpoExpr, GK_Intermediate]:\n        \"\"\"Get abstract clock output.\n\n        Args:\n            clk_name (str):  String of clock name\n\n        Returns:\n            (int or float or CpoExpr or GK_Intermediate): Abstract\n                or concrete clock reference\n        \"\"\"\n        od = self._convert_input(self._d, \"d_\" + str(clk_name))\n        self.config[\"out_dividers\"].append(od)\n        return self.vcxo / self.config[\"r1\"] * self.config[\"n2\"] / od\n\n    def set_requested_clocks(\n        self,\n        vcxo: int,\n        out_freqs: List,\n        clk_names: List[str],\n    ) -&gt; None:\n        \"\"\"Define necessary clocks to be generated in model.\n\n        Args:\n            vcxo (int): VCXO frequency in hertz\n            out_freqs (List): list of required clocks to be output\n            clk_names (List[str]):  list of strings of clock names\n\n        Raises:\n            Exception: If len(out_freqs) != len(clk_names)\n        \"\"\"\n        if len(clk_names) != len(out_freqs):\n            raise Exception(\"clk_names is not the same size as out_freqs\")\n        self._clk_names = clk_names\n\n        # Setup clock chip internal constraints\n        self._setup(vcxo)\n\n        if self._sysref:\n            if self.sysref_external:\n                sysref_src = self.vcxo\n            else:\n                sysref_src = self.vcxo / self.config[\"r1\"]\n\n            self._add_equation([sysref_src / (2 * self.config[\"k\"]) == self._sysref])\n\n        # Add requested clocks to output constraints\n        for out_freq, name in zip(out_freqs, clk_names):  # noqa: B905\n            # od = self.model.Var(integer=True, lb=1, ub=256, value=1)\n            od = self._convert_input(self._d, f\"d_{name}_{out_freq}\")\n            # od = self.model.sos1([n*n for n in range(1,9)])\n            self._add_equation(\n                [self.vcxo / self.config[\"r1\"] * self.config[\"n2\"] / od == out_freq]\n            )\n            self.config[\"out_dividers\"].append(od)\n</code></pre>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.a","title":"<code>a: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>VCO calibration divider 1.</p> <p>Valid dividers are 0-&gt;3</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.b","title":"<code>b: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>VCO calibration divider 2.</p> <p>Valid dividers are 3-&gt;63</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.b_availble","title":"<code>b_availble = [*range(3, 64)]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VCXO dividers</p>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.d","title":"<code>d: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>Output dividers.</p> <p>Valid dividers are 1-&gt;1023</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.d_available","title":"<code>d_available = [*range(1, 1024)]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>sysref dividers</p>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.k","title":"<code>k: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>Sysref dividers.</p> <p>Valid dividers are 0-&gt;65535</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.k_available","title":"<code>k_available = [*range(0, 65536)]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VCXO multiplier</p>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.m1","title":"<code>m1: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>VCO divider path 1.</p> <p>Valid dividers are 3,4,5</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.m1_available","title":"<code>m1_available = [3, 4, 5]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Output dividers</p>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.n2","title":"<code>n2: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>n2: VCO feedback divider.</p> <p>Valid dividers are 1-&gt;255</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.n2_available","title":"<code>n2_available = [*range(1, 256)]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VCO calibration dividers</p>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.r1","title":"<code>r1: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>VCXO input dividers.</p> <p>Valid dividers are 1-&gt;31</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.sysref","title":"<code>sysref: int</code>  <code>property</code> <code>writable</code>","text":"<p>SYSREF Frequency in Hz.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>computed sysref frequency</p>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.vco","title":"<code>vco: float</code>  <code>property</code>","text":"<p>VCO Frequency in Hz.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>computed VCO frequency</p>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.get_config","title":"<code>get_config(solution=None)</code>","text":"<p>Extract configurations from solver results.</p> <p>Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs)</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>CpoSolveResult</code> <p>CPlex solution. Only needed for CPlex solver</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>Dictionary of clocking rates and dividers for configuration</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If solver is not called first</p> Source code in <code>adijif/clocks/ad9528.py</code> <pre><code>def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n    \"\"\"Extract configurations from solver results.\n\n    Collect internal clock chip configuration and output clock definitions\n    leading to connected devices (converters, FPGAs)\n\n    Args:\n        solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n    Returns:\n        Dict: Dictionary of clocking rates and dividers for configuration\n\n    Raises:\n        Exception: If solver is not called first\n    \"\"\"\n    if not self._clk_names:\n        raise Exception(\"set_requested_clocks must be called before get_config\")\n\n    if solution:\n        self.solution = solution\n\n    # out_dividers = [solution.get_value(x) for x in self.config[\"out_dividers\"]]\n    out_dividers = [self._get_val(x) for x in self.config[\"out_dividers\"]]\n\n    config: Dict = {\n        \"vcxo\": self.vcxo / 2 if self.use_vcxo_double else self.vcxo,\n        \"vco\": self.vco,\n        \"r1\": self._get_val(self.config[\"r1\"]),\n        \"n2\": self._get_val(self.config[\"n2\"]),\n        \"m1\": self._get_val(self.config[\"m1\"]),\n        \"a\": self._get_val(self.config[\"a\"]),\n        \"b\": self._get_val(self.config[\"b\"]),\n        \"out_dividers\": out_dividers,\n        \"output_clocks\": [],\n    }\n\n    if self._sysref:\n        config[\"k\"] = self._get_val(self.config[\"k\"])\n        config[\"sysref\"] = self.sysref\n\n    clk = self.vcxo * config[\"n2\"] / config[\"r1\"]\n\n    output_cfg = {}\n    for i, div in enumerate(out_dividers):\n        rate = clk / div\n        output_cfg[self._clk_names[i]] = {\n            \"rate\": rate,\n            \"divider\": div,\n        }\n\n    config[\"output_clocks\"] = output_cfg\n    return config\n</code></pre>"},{"location":"devs/clocks/#adijif.clocks.ad9528.ad9528.set_requested_clocks","title":"<code>set_requested_clocks(vcxo, out_freqs, clk_names)</code>","text":"<p>Define necessary clocks to be generated in model.</p> <p>Parameters:</p> Name Type Description Default <code>vcxo</code> <code>int</code> <p>VCXO frequency in hertz</p> required <code>out_freqs</code> <code>List</code> <p>list of required clocks to be output</p> required <code>clk_names</code> <code>List[str]</code> <p>list of strings of clock names</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If len(out_freqs) != len(clk_names)</p> Source code in <code>adijif/clocks/ad9528.py</code> <pre><code>def set_requested_clocks(\n    self,\n    vcxo: int,\n    out_freqs: List,\n    clk_names: List[str],\n) -&gt; None:\n    \"\"\"Define necessary clocks to be generated in model.\n\n    Args:\n        vcxo (int): VCXO frequency in hertz\n        out_freqs (List): list of required clocks to be output\n        clk_names (List[str]):  list of strings of clock names\n\n    Raises:\n        Exception: If len(out_freqs) != len(clk_names)\n    \"\"\"\n    if len(clk_names) != len(out_freqs):\n        raise Exception(\"clk_names is not the same size as out_freqs\")\n    self._clk_names = clk_names\n\n    # Setup clock chip internal constraints\n    self._setup(vcxo)\n\n    if self._sysref:\n        if self.sysref_external:\n            sysref_src = self.vcxo\n        else:\n            sysref_src = self.vcxo / self.config[\"r1\"]\n\n        self._add_equation([sysref_src / (2 * self.config[\"k\"]) == self._sysref])\n\n    # Add requested clocks to output constraints\n    for out_freq, name in zip(out_freqs, clk_names):  # noqa: B905\n        # od = self.model.Var(integer=True, lb=1, ub=256, value=1)\n        od = self._convert_input(self._d, f\"d_{name}_{out_freq}\")\n        # od = self.model.sos1([n*n for n in range(1,9)])\n        self._add_equation(\n            [self.vcxo / self.config[\"r1\"] * self.config[\"n2\"] / od == out_freq]\n        )\n        self.config[\"out_dividers\"].append(od)\n</code></pre>"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044","title":"<code>hmc7044</code>","text":"<p>               Bases: <code>hmc7044_bf</code></p> <p>HMC7044 clock chip model.</p> <p>This model currently supports VCXO+PLL2 configurations</p> Source code in <code>adijif/clocks/hmc7044.py</code> <pre><code>class hmc7044(hmc7044_bf):\n    \"\"\"HMC7044 clock chip model.\n\n    This model currently supports VCXO+PLL2 configurations\n    \"\"\"\n\n    # Ranges\n    # r2_divider_min = 1\n    # r2_divider_max = 4095\n    r2_available = [*range(1, 4095 + 1)]\n\n    \"\"\" Output dividers \"\"\"\n    d_available = [1, 3, 5, *range(2, 4095, 2)]\n    # When pulse generation is required (like for sysref) divder range\n    # is limited\n    d_syspulse_available = [*range(32, 4095, 2)]\n\n    # Defaults\n    _d: Union[int, List[int]] = [1, 3, 5, *range(2, 4095, 2)]\n    _r2: Union[int, List[int]] = [*range(1, 4095 + 1)]\n\n    # Limits\n    \"\"\" Internal limits \"\"\"\n    vco_min = 2400e6\n    vco_max = 3200e6\n    pfd_max = 250e6\n    vcxo_min = 10e6\n    vcxo_max = 500e6\n\n    use_vcxo_double = True\n    vxco_doubler_available = [1, 2]\n    _vxco_doubler = [1, 2]\n\n    minimize_feedback_dividers = True\n\n    # State management\n    _clk_names: List[str] = []\n\n    def __init__(\n        self, model: Union[GEKKO, CpoModel] = None, solver: str = \"CPLEX\"\n    ) -&gt; None:\n        \"\"\"Initialize HMC7044 clock chip model.\n\n        Args:\n            model (Model): Model to add constraints to\n            solver (str): Solver to use. Should be one of \"CPLEX\" or \"gekko\"\n\n        Raises:\n            Exception: Invalid solver\n        \"\"\"\n        super(hmc7044, self).__init__(model, solver)\n        if solver == \"gekko\":\n            self.n2_available = [*range(8, 65535 + 1)]\n            self._n2 = [*range(8, 65535 + 1)]\n        elif solver == \"CPLEX\":\n            self.n2_available = [*range(8, 65535 + 1)]\n            self._n2 = [*range(8, 65535 + 1)]\n        else:\n            raise Exception(\"Unknown solver {}\".format(solver))\n\n    @property\n    def d(self) -&gt; Union[int, List[int]]:\n        \"\"\"Output dividers.\n\n        Valid dividers are 1,2,3,4,5,6-&gt;(even)-&gt;4094\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._d\n\n    @d.setter\n    def d(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"Output dividers.\n\n        Valid dividers are 1,2,3,4,5,6-&gt;(even)-&gt;4094\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n        \"\"\"\n        self._check_in_range(value, self.d_available, \"d\")\n        self._d = value\n\n    @property\n    def n2(self) -&gt; Union[int, List[int]]:\n        \"\"\"n2: VCO feedback divider.\n\n        Valid dividers are 8-&gt;65536\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._n2\n\n    @n2.setter\n    def n2(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCO feedback divider.\n\n        Valid dividers are 8-&gt;65536\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n        \"\"\"\n        self._check_in_range(value, self.n2_available, \"n2\")\n        self._n2 = value\n\n    @property\n    def r2(self) -&gt; Union[int, List[int]]:\n        \"\"\"VCXO input dividers.\n\n        Valid dividers are 1-&gt;4096\n\n        Returns:\n            int: Current allowable dividers\n        \"\"\"\n        return self._r2\n\n    @r2.setter\n    def r2(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCXO input dividers.\n\n        Valid dividers are 1-&gt;4096\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n        \"\"\"\n        self._check_in_range(value, self.r2_available, \"r2\")\n        self._r2 = value\n\n    @property\n    def vxco_doubler(self) -&gt; Union[int, List[int]]:\n        \"\"\"VCXO doubler.\n\n        Valid dividers are 1,2\n\n        Returns:\n            int: Current doubler value\n        \"\"\"\n        return self._vxco_doubler\n\n    @vxco_doubler.setter\n    def vxco_doubler(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"VCXO doubler.\n\n        Valid dividers are 1,2\n\n        Args:\n            value (int, list[int]): Allowable values for divider\n\n        \"\"\"\n        self._check_in_range(value, self.vxco_doubler_available, \"vxco_doubler\")\n        self._vxco_doubler = value\n\n    def _init_diagram(self) -&gt; None:\n        \"\"\"Initialize diagram for HMC7044 alone.\"\"\"\n        self.ic_diagram_node = None\n        self._diagram_output_dividers = []\n\n        # lo = Layout(\"HMC7044 Example\")\n\n        self.ic_diagram_node = Node(\"HMC7044\")\n        # lo.add_node(root)\n\n        # External\n        # ref_in = Node(\"REF_IN\", ntype=\"input\")\n        # lo.add_node(ref_in)\n\n        vcxo_doubler = Node(\"VCXO Doubler\", ntype=\"shell\")\n        self.ic_diagram_node.add_child(vcxo_doubler)\n\n        # Inside the IC\n        r2_div = Node(\"R2\", ntype=\"divider\")\n        # r2_div.value = \"2\"\n        self.ic_diagram_node.add_child(r2_div)\n        pfd = Node(\"PFD\", ntype=\"phase-frequency-detector\")\n        self.ic_diagram_node.add_child(pfd)\n        lf = Node(\"LF\", ntype=\"loop-filter\")\n        self.ic_diagram_node.add_child(lf)\n        vco = Node(\"VCO\", ntype=\"voltage-controlled-oscillator\")\n        vco.shape = \"circle\"\n        self.ic_diagram_node.add_child(vco)\n        n2 = Node(\"N2\", ntype=\"divider\")\n        self.ic_diagram_node.add_child(n2)\n\n        out_dividers = Node(\"Output Dividers\", ntype=\"shell\")\n        # ds = 4\n        # out_divs = []\n        # for i in range(ds):\n        #     div = Node(f\"D{i+1}\", ntype=\"divider\")\n        #     out_dividers.add_child(div)\n        #     out_divs.append(div)\n\n        self.ic_diagram_node.add_child(out_dividers)\n\n        # Connections inside the IC\n        # lo.add_connection({\"from\": ref_in, \"to\": r2_div, 'rate': 125000000})\n        self.ic_diagram_node.add_connection({\"from\": vcxo_doubler, \"to\": r2_div})\n        self.ic_diagram_node.add_connection(\n            {\"from\": r2_div, \"to\": pfd, \"rate\": 125000000 / 2}\n        )\n        self.ic_diagram_node.add_connection({\"from\": pfd, \"to\": lf})\n        self.ic_diagram_node.add_connection({\"from\": lf, \"to\": vco})\n        self.ic_diagram_node.add_connection({\"from\": vco, \"to\": n2})\n        self.ic_diagram_node.add_connection({\"from\": n2, \"to\": pfd})\n\n        self.ic_diagram_node.add_connection(\n            {\"from\": vco, \"to\": out_dividers, \"rate\": 4000000000}\n        )\n        # for div in out_divs:\n        #     self.ic_diagram_node.add_connection({\"from\": out_dividers, \"to\": div})\n        #     # root.add_connection({\"from\": vco, \"to\": div})\n\n    def _update_diagram(self, config: Dict) -&gt; None:\n        \"\"\"Update diagram with configuration.\n\n        Args:\n            config (Dict): Configuration dictionary\n\n        Raises:\n            Exception: If key is not D followed by a number\n        \"\"\"\n        # Add output dividers\n        keys = config.keys()\n        output_dividers = self.ic_diagram_node.get_child(\"Output Dividers\")\n        for key in keys:\n            if key.startswith(\"D\"):\n                div = Node(key, ntype=\"divider\")\n                output_dividers.add_child(div)\n                self.ic_diagram_node.add_connection(\n                    {\"from\": output_dividers, \"to\": div}\n                )\n            else:\n                raise Exception(\n                    f\"Unknown key {key}. Must be of for DX where X is a number\"\n                )\n\n    def draw(self) -&gt; str:\n        \"\"\"Draw diagram in d2 language for IC alone with reference clock.\n\n        Returns:\n            str: Diagram in d2 language\n\n        Raises:\n            Exception: If no solution is saved\n        \"\"\"\n        if not self._saved_solution:\n            raise Exception(\"No solution to draw. Must call solve first.\")\n        lo = Layout(\"HMC7044 Example\")\n        lo.add_node(self.ic_diagram_node)\n\n        ref_in = Node(\"REF_IN\", ntype=\"input\")\n        lo.add_node(ref_in)\n        vcxo_double = self.ic_diagram_node.get_child(\"VCXO Doubler\")\n        lo.add_connection(\n            {\"from\": ref_in, \"to\": vcxo_double, \"rate\": self._saved_solution[\"vcxo\"]}\n        )\n\n        # Update Node values\n        node = self.ic_diagram_node.get_child(\"VCXO Doubler\")\n        node.value = str(self._saved_solution[\"vcxo_doubler\"])\n        node = self.ic_diagram_node.get_child(\"R2\")\n        node.value = str(self._saved_solution[\"r2\"])\n        node = self.ic_diagram_node.get_child(\"N2\")\n        node.value = str(self._saved_solution[\"n2\"])\n\n        # Update VCXO Doubler to R2\n        # con = self.ic_diagram_node.get_connection(\"VCXO Doubler\", \"R2\")\n        rate = self._saved_solution[\"vcxo_doubler\"] * self._saved_solution[\"vcxo\"]\n        self.ic_diagram_node.update_connection(\"VCXO Doubler\", \"R2\", rate)\n\n        # Update R2 to PFD\n        # con = self.ic_diagram_node.get_connection(\"R2\", \"PFD\")\n        rate = (\n            self._saved_solution[\"vcxo\"]\n            * self._saved_solution[\"vcxo_doubler\"]\n            / self._saved_solution[\"r2\"]\n        )\n        self.ic_diagram_node.update_connection(\"R2\", \"PFD\", rate)\n\n        # Update VCO\n        # con = self.ic_diagram_node.get_connection(\"VCO\", \"Output Dividers\")\n        self.ic_diagram_node.update_connection(\n            \"VCO\", \"Output Dividers\", self._saved_solution[\"vco\"]\n        )\n\n        # Update diagram with dividers and rates\n        d = 0\n        output_dividers = self.ic_diagram_node.get_child(\"Output Dividers\")\n\n        for key, val in self._saved_solution[\"output_clocks\"].items():\n            clk_node = Node(key, ntype=\"divider\")\n            div_value = val[\"divider\"]\n            div = output_dividers.get_child(f\"D{d}\")\n            div.value = str(div_value)\n            d += 1\n            lo.add_node(clk_node)\n            lo.add_connection({\"from\": div, \"to\": clk_node, \"rate\": val[\"rate\"]})\n\n        return lo.draw()\n\n    def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n        \"\"\"Extract configurations from solver results.\n\n        Collect internal clock chip configuration and output clock definitions\n        leading to connected devices (converters, FPGAs)\n\n        Args:\n            solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n        Returns:\n            Dict: Dictionary of clocking rates and dividers for configuration\n\n        Raises:\n            Exception: If solver is not called first\n        \"\"\"\n        if not self._clk_names:\n            raise Exception(\"set_requested_clocks must be called before get_config\")\n\n        if solution:\n            self.solution = solution\n\n        out_dividers = [self._get_val(x) for x in self.config[\"out_dividers\"]]\n\n        config: Dict = {\n            \"r2\": self._get_val(self.config[\"r2\"]),\n            \"n2\": self._get_val(self.config[\"n2\"]),\n            \"out_dividers\": out_dividers,\n            \"output_clocks\": [],\n        }\n\n        if self.vcxo_i:\n            vcxo = self._get_val(self.vcxo_i[\"range\"])\n            self.vcxo = vcxo\n\n        clk = self.vcxo / config[\"r2\"] * config[\"n2\"]\n\n        output_cfg = {}\n        vd = self._get_val(self.config[\"vcxo_doubler\"])\n        for i, div in enumerate(out_dividers):\n            rate = vd * clk / div\n            output_cfg[self._clk_names[i]] = {\"rate\": rate, \"divider\": div}\n\n        config[\"output_clocks\"] = output_cfg\n        config[\"vco\"] = clk * vd\n        config[\"vcxo\"] = self.vcxo\n        config[\"vcxo_doubler\"] = vd\n\n        self._saved_solution = config\n\n        return config\n\n    def _setup_solver_constraints(self, vcxo: int) -&gt; None:\n        \"\"\"Apply constraints to solver model.\n\n        Args:\n            vcxo (int): VCXO frequency in hertz\n\n        Raises:\n            Exception: Invalid solver\n        \"\"\"\n        self.vcxo = vcxo\n\n        if self.solver == \"gekko\":\n            self.config = {\"r2\": self.model.Var(integer=True, lb=1, ub=4095, value=1)}\n            self.config[\"n2\"] = self.model.Var(integer=True, lb=8, ub=4095)\n            if isinstance(vcxo, (int, float)):\n                vcxo_var = self.model.Const(int(vcxo))\n            else:\n                vcxo_var = vcxo\n            self.config[\"vcxo_doubler\"] = self.model.sos1([1, 2])\n            self.config[\"vcxod\"] = self.model.Intermediate(\n                self.config[\"vcxo_doubler\"] * vcxo_var\n            )\n        elif self.solver == \"CPLEX\":\n            self.config = {\n                \"r2\": self._convert_input(self._r2, \"r2\"),\n                \"n2\": self._convert_input(self._n2, \"n2\"),\n            }\n            self.config[\"vcxo_doubler\"] = self._convert_input(\n                self._vxco_doubler, \"vcxo_doubler\"\n            )\n            self.config[\"vcxod\"] = self._add_intermediate(\n                self.config[\"vcxo_doubler\"] * vcxo\n            )\n        else:\n            raise Exception(\"Unknown solver {}\".format(self.solver))\n\n        # PLL2 equations\n        self._add_equation(\n            [\n                self.config[\"vcxod\"] &lt;= self.pfd_max * self.config[\"r2\"],\n                self.config[\"vcxod\"] * self.config[\"n2\"]\n                &lt;= self.vco_max * self.config[\"r2\"],\n                self.config[\"vcxod\"] * self.config[\"n2\"]\n                &gt;= self.vco_min * self.config[\"r2\"],\n            ]\n        )\n\n        # Objectives\n        if self.minimize_feedback_dividers:\n            if self.solver == \"CPLEX\":\n                self._add_objective(self.config[\"r2\"])\n                # self.model.minimize(self.config[\"r2\"])\n            elif self.solver == \"gekko\":\n                self.model.Obj(self.config[\"r2\"])\n            else:\n                raise Exception(\"Unknown solver {}\".format(self.solver))\n\n    def _setup(self, vcxo: int) -&gt; None:\n        # Setup clock chip internal constraints\n\n        # FIXME: ADD SPLIT m1 configuration support\n\n        # Convert VCXO into intermediate in case we have range type\n        if type(vcxo) not in [int, float]:\n            self.vcxo_i = vcxo(self.model)\n            vcxo = self.vcxo_i[\"range\"]\n        else:\n            self.vcxo_i = False\n\n        self._setup_solver_constraints(vcxo)\n\n        # Add requested clocks to output constraints\n        self.config[\"out_dividers\"] = []\n\n    def _get_clock_constraint(\n        self, clk_name: List[str]\n    ) -&gt; Union[int, float, CpoExpr, GK_Intermediate]:\n        \"\"\"Get abstract clock output.\n\n        Args:\n            clk_name (str):  String of clock name\n\n        Returns:\n            (int or float or CpoExpr or GK_Intermediate): Abstract\n                or concrete clock reference\n\n        Raises:\n            Exception: Invalid solver\n        \"\"\"\n        if self.solver == \"gekko\":\n            __d = self._d if isinstance(self._d, list) else [self._d]\n\n            if __d.sort() != self.d_available.sort():\n                raise Exception(\"For solver gekko d is not configurable for HMC7044\")\n\n            even = self.model.Var(integer=True, lb=3, ub=2047)\n            odd = self.model.Intermediate(even * 2)\n            od = self.model.sos1([1, 2, 3, 4, 5, odd])\n\n        elif self.solver == \"CPLEX\":\n            od = self._convert_input(self._d, \"d_\" + str(clk_name))\n        else:\n            raise Exception(\"Unknown solver {}\".format(self.solver))\n\n        self.config[\"out_dividers\"].append(od)\n        return self.config[\"vcxod\"] / self.config[\"r2\"] * self.config[\"n2\"] / od\n\n    def set_requested_clocks(\n        self, vcxo: int, out_freqs: List, clk_names: List[str]\n    ) -&gt; None:\n        \"\"\"Define necessary clocks to be generated in model.\n\n        Args:\n            vcxo (int): VCXO frequency in hertz\n            out_freqs (List): list of required clocks to be output\n            clk_names (List[str]):  list of strings of clock names\n\n        Raises:\n            Exception: If len(out_freqs) != len(clk_names)\n        \"\"\"\n        if len(clk_names) != len(out_freqs):\n            raise Exception(\"clk_names is not the same size as out_freqs\")\n        self._clk_names = clk_names\n\n        # Setup clock chip internal constraints\n        self._setup(vcxo)\n        # if type(self.vcxo) not in [int,float]:\n        #     vcxo = self.vcxo['range']\n\n        self._saved_solution = None\n\n        # Add requested clocks to output constraints\n        for d_n, out_freq in enumerate(out_freqs):\n            if self.solver == \"gekko\":\n                __d = self._d if isinstance(self._d, list) else [self._d]\n                if __d.sort() != self.d_available.sort():\n                    raise Exception(\n                        \"For solver gekko d is not configurable for HMC7044\"\n                    )\n\n                # even = self.model.Var(integer=True, lb=3, ub=2047)\n                # odd = self.model.Intermediate(even * 2)\n                # od = self.model.sos1([1, 2, 3, 4, 5, odd])\n\n                # Since d is so disjoint it is very annoying to solve.\n                even = self.model.Var(integer=True, lb=1, ub=4094 // 2)\n\n                # odd = self.model.sos1([1, 3, 5])\n                odd_i = self.model.Var(integer=True, lb=0, ub=2)\n                odd = self.model.Intermediate(1 + odd_i * 2)\n\n                eo = self.model.Var(integer=True, lb=0, ub=1)\n                od = self.model.Intermediate(eo * odd + (1 - eo) * even * 2)\n\n            elif self.solver == \"CPLEX\":\n                od = self._convert_input(self._d, f\"d_{out_freq}_{d_n}\")\n\n            self._add_equation(\n                [\n                    self.config[\"vcxod\"] * self.config[\"n2\"]\n                    == out_freq * self.config[\"r2\"] * od\n                ]\n            )\n            self.config[\"out_dividers\"].append(od)\n\n            # Update diagram to include new divider\n            self._update_diagram({f\"D{d_n}\": od})\n</code></pre>"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.d","title":"<code>d: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>Output dividers.</p> <p>Valid dividers are 1,2,3,4,5,6-&gt;(even)-&gt;4094</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.n2","title":"<code>n2: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>n2: VCO feedback divider.</p> <p>Valid dividers are 8-&gt;65536</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.r2","title":"<code>r2: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>VCXO input dividers.</p> <p>Valid dividers are 1-&gt;4096</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current allowable dividers</p>"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.r2_available","title":"<code>r2_available = [*range(1, 4095 + 1)]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Output dividers</p>"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.vxco_doubler","title":"<code>vxco_doubler: Union[int, List[int]]</code>  <code>property</code> <code>writable</code>","text":"<p>VCXO doubler.</p> <p>Valid dividers are 1,2</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, List[int]]</code> <p>Current doubler value</p>"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.__init__","title":"<code>__init__(model=None, solver='CPLEX')</code>","text":"<p>Initialize HMC7044 clock chip model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>Model to add constraints to</p> <code>None</code> <code>solver</code> <code>str</code> <p>Solver to use. Should be one of \"CPLEX\" or \"gekko\"</p> <code>'CPLEX'</code> <p>Raises:</p> Type Description <code>Exception</code> <p>Invalid solver</p> Source code in <code>adijif/clocks/hmc7044.py</code> <pre><code>def __init__(\n    self, model: Union[GEKKO, CpoModel] = None, solver: str = \"CPLEX\"\n) -&gt; None:\n    \"\"\"Initialize HMC7044 clock chip model.\n\n    Args:\n        model (Model): Model to add constraints to\n        solver (str): Solver to use. Should be one of \"CPLEX\" or \"gekko\"\n\n    Raises:\n        Exception: Invalid solver\n    \"\"\"\n    super(hmc7044, self).__init__(model, solver)\n    if solver == \"gekko\":\n        self.n2_available = [*range(8, 65535 + 1)]\n        self._n2 = [*range(8, 65535 + 1)]\n    elif solver == \"CPLEX\":\n        self.n2_available = [*range(8, 65535 + 1)]\n        self._n2 = [*range(8, 65535 + 1)]\n    else:\n        raise Exception(\"Unknown solver {}\".format(solver))\n</code></pre>"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.draw","title":"<code>draw()</code>","text":"<p>Draw diagram in d2 language for IC alone with reference clock.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Diagram in d2 language</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no solution is saved</p> Source code in <code>adijif/clocks/hmc7044.py</code> <pre><code>def draw(self) -&gt; str:\n    \"\"\"Draw diagram in d2 language for IC alone with reference clock.\n\n    Returns:\n        str: Diagram in d2 language\n\n    Raises:\n        Exception: If no solution is saved\n    \"\"\"\n    if not self._saved_solution:\n        raise Exception(\"No solution to draw. Must call solve first.\")\n    lo = Layout(\"HMC7044 Example\")\n    lo.add_node(self.ic_diagram_node)\n\n    ref_in = Node(\"REF_IN\", ntype=\"input\")\n    lo.add_node(ref_in)\n    vcxo_double = self.ic_diagram_node.get_child(\"VCXO Doubler\")\n    lo.add_connection(\n        {\"from\": ref_in, \"to\": vcxo_double, \"rate\": self._saved_solution[\"vcxo\"]}\n    )\n\n    # Update Node values\n    node = self.ic_diagram_node.get_child(\"VCXO Doubler\")\n    node.value = str(self._saved_solution[\"vcxo_doubler\"])\n    node = self.ic_diagram_node.get_child(\"R2\")\n    node.value = str(self._saved_solution[\"r2\"])\n    node = self.ic_diagram_node.get_child(\"N2\")\n    node.value = str(self._saved_solution[\"n2\"])\n\n    # Update VCXO Doubler to R2\n    # con = self.ic_diagram_node.get_connection(\"VCXO Doubler\", \"R2\")\n    rate = self._saved_solution[\"vcxo_doubler\"] * self._saved_solution[\"vcxo\"]\n    self.ic_diagram_node.update_connection(\"VCXO Doubler\", \"R2\", rate)\n\n    # Update R2 to PFD\n    # con = self.ic_diagram_node.get_connection(\"R2\", \"PFD\")\n    rate = (\n        self._saved_solution[\"vcxo\"]\n        * self._saved_solution[\"vcxo_doubler\"]\n        / self._saved_solution[\"r2\"]\n    )\n    self.ic_diagram_node.update_connection(\"R2\", \"PFD\", rate)\n\n    # Update VCO\n    # con = self.ic_diagram_node.get_connection(\"VCO\", \"Output Dividers\")\n    self.ic_diagram_node.update_connection(\n        \"VCO\", \"Output Dividers\", self._saved_solution[\"vco\"]\n    )\n\n    # Update diagram with dividers and rates\n    d = 0\n    output_dividers = self.ic_diagram_node.get_child(\"Output Dividers\")\n\n    for key, val in self._saved_solution[\"output_clocks\"].items():\n        clk_node = Node(key, ntype=\"divider\")\n        div_value = val[\"divider\"]\n        div = output_dividers.get_child(f\"D{d}\")\n        div.value = str(div_value)\n        d += 1\n        lo.add_node(clk_node)\n        lo.add_connection({\"from\": div, \"to\": clk_node, \"rate\": val[\"rate\"]})\n\n    return lo.draw()\n</code></pre>"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.get_config","title":"<code>get_config(solution=None)</code>","text":"<p>Extract configurations from solver results.</p> <p>Collect internal clock chip configuration and output clock definitions leading to connected devices (converters, FPGAs)</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>CpoSolveResult</code> <p>CPlex solution. Only needed for CPlex solver</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>Dictionary of clocking rates and dividers for configuration</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If solver is not called first</p> Source code in <code>adijif/clocks/hmc7044.py</code> <pre><code>def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n    \"\"\"Extract configurations from solver results.\n\n    Collect internal clock chip configuration and output clock definitions\n    leading to connected devices (converters, FPGAs)\n\n    Args:\n        solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n    Returns:\n        Dict: Dictionary of clocking rates and dividers for configuration\n\n    Raises:\n        Exception: If solver is not called first\n    \"\"\"\n    if not self._clk_names:\n        raise Exception(\"set_requested_clocks must be called before get_config\")\n\n    if solution:\n        self.solution = solution\n\n    out_dividers = [self._get_val(x) for x in self.config[\"out_dividers\"]]\n\n    config: Dict = {\n        \"r2\": self._get_val(self.config[\"r2\"]),\n        \"n2\": self._get_val(self.config[\"n2\"]),\n        \"out_dividers\": out_dividers,\n        \"output_clocks\": [],\n    }\n\n    if self.vcxo_i:\n        vcxo = self._get_val(self.vcxo_i[\"range\"])\n        self.vcxo = vcxo\n\n    clk = self.vcxo / config[\"r2\"] * config[\"n2\"]\n\n    output_cfg = {}\n    vd = self._get_val(self.config[\"vcxo_doubler\"])\n    for i, div in enumerate(out_dividers):\n        rate = vd * clk / div\n        output_cfg[self._clk_names[i]] = {\"rate\": rate, \"divider\": div}\n\n    config[\"output_clocks\"] = output_cfg\n    config[\"vco\"] = clk * vd\n    config[\"vcxo\"] = self.vcxo\n    config[\"vcxo_doubler\"] = vd\n\n    self._saved_solution = config\n\n    return config\n</code></pre>"},{"location":"devs/clocks/#adijif.clocks.hmc7044.hmc7044.set_requested_clocks","title":"<code>set_requested_clocks(vcxo, out_freqs, clk_names)</code>","text":"<p>Define necessary clocks to be generated in model.</p> <p>Parameters:</p> Name Type Description Default <code>vcxo</code> <code>int</code> <p>VCXO frequency in hertz</p> required <code>out_freqs</code> <code>List</code> <p>list of required clocks to be output</p> required <code>clk_names</code> <code>List[str]</code> <p>list of strings of clock names</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If len(out_freqs) != len(clk_names)</p> Source code in <code>adijif/clocks/hmc7044.py</code> <pre><code>def set_requested_clocks(\n    self, vcxo: int, out_freqs: List, clk_names: List[str]\n) -&gt; None:\n    \"\"\"Define necessary clocks to be generated in model.\n\n    Args:\n        vcxo (int): VCXO frequency in hertz\n        out_freqs (List): list of required clocks to be output\n        clk_names (List[str]):  list of strings of clock names\n\n    Raises:\n        Exception: If len(out_freqs) != len(clk_names)\n    \"\"\"\n    if len(clk_names) != len(out_freqs):\n        raise Exception(\"clk_names is not the same size as out_freqs\")\n    self._clk_names = clk_names\n\n    # Setup clock chip internal constraints\n    self._setup(vcxo)\n    # if type(self.vcxo) not in [int,float]:\n    #     vcxo = self.vcxo['range']\n\n    self._saved_solution = None\n\n    # Add requested clocks to output constraints\n    for d_n, out_freq in enumerate(out_freqs):\n        if self.solver == \"gekko\":\n            __d = self._d if isinstance(self._d, list) else [self._d]\n            if __d.sort() != self.d_available.sort():\n                raise Exception(\n                    \"For solver gekko d is not configurable for HMC7044\"\n                )\n\n            # even = self.model.Var(integer=True, lb=3, ub=2047)\n            # odd = self.model.Intermediate(even * 2)\n            # od = self.model.sos1([1, 2, 3, 4, 5, odd])\n\n            # Since d is so disjoint it is very annoying to solve.\n            even = self.model.Var(integer=True, lb=1, ub=4094 // 2)\n\n            # odd = self.model.sos1([1, 3, 5])\n            odd_i = self.model.Var(integer=True, lb=0, ub=2)\n            odd = self.model.Intermediate(1 + odd_i * 2)\n\n            eo = self.model.Var(integer=True, lb=0, ub=1)\n            od = self.model.Intermediate(eo * odd + (1 - eo) * even * 2)\n\n        elif self.solver == \"CPLEX\":\n            od = self._convert_input(self._d, f\"d_{out_freq}_{d_n}\")\n\n        self._add_equation(\n            [\n                self.config[\"vcxod\"] * self.config[\"n2\"]\n                == out_freq * self.config[\"r2\"] * od\n            ]\n        )\n        self.config[\"out_dividers\"].append(od)\n\n        # Update diagram to include new divider\n        self._update_diagram({f\"D{d_n}\": od})\n</code></pre>"},{"location":"devs/converters/","title":"Reference","text":"<p>AD9081 high speed MxFE clocking model.</p> <p>AD9680 high speed ADC clocking model.</p> <p>AD9144 high speed DAC clocking model.</p> <p>ADRV9009 transceiver clocking model.</p>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081","title":"<code>ad9081</code>","text":"<p>               Bases: <code>ad9081_core</code></p> <p>AD9081 combined transmit and receive model.</p> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>class ad9081(ad9081_core):\n    \"\"\"AD9081 combined transmit and receive model.\"\"\"\n\n    converter_clock_min = ad9081_rx.converter_clock_min\n    converter_clock_max = ad9081_rx.converter_clock_max\n    quick_configuration_modes: Dict[str, Any] = {}\n    _nested = [\"adc\", \"dac\"]\n    converter_type = \"adc_dac\"\n\n    def __init__(\n        self, model: Union[GEKKO, CpoModel] = None, solver: str = None\n    ) -&gt; None:\n        \"\"\"Initialize AD9081 clocking model for TX and RX.\n\n        This is a common class used to handle TX and RX constraints\n        together.\n\n        Args:\n            model (GEKKO,CpoModel): Solver model\n            solver (str): Solver name (gekko or CPLEX)\n        \"\"\"\n        if solver:\n            self.solver = solver\n        self.adc = ad9081_rx(model, solver=self.solver)\n        self.dac = ad9081_tx(model, solver=self.solver)\n        self.model = model\n\n    def validate_config(self) -&gt; None:\n        \"\"\"Validate device configurations including JESD and clocks of both ADC and DAC.\n\n        This check only is for static configuration that does not include\n        variables which are solved.\n        \"\"\"\n        self.adc.validate_config()\n        self.dac.validate_config()\n\n    def _get_converters(self) -&gt; List[Union[converter, converter]]:\n        return [self.adc, self.dac]\n\n    def get_required_clock_names(self) -&gt; List[str]:\n        \"\"\"Get list of strings of names of requested clocks.\n\n        This list of names is for the clocks defined by get_required_clocks\n\n        Returns:\n            List[str]: List of strings of clock names in order\n        \"\"\"\n        clk = (\n            \"ad9081_dac_clock\"\n            if self.adc.clocking_option == \"direct\"\n            else \"ad9081_pll_ref\"\n        )\n        return [clk, \"ad9081_adc_sysref\", \"ad9081_dac_sysref\"]\n\n    def _converter_clock_config(self) -&gt; None:\n        adc_clk = self.adc.decimation * self.adc.sample_clock\n        dac_clk = self.dac.interpolation * self.dac.sample_clock\n        l = dac_clk / adc_clk\n        if np.abs(l - round(l)) &gt; 1e-6:\n            raise Exception(f\"Sample clock ratio is not integer {adc_clk} {dac_clk}\")\n        else:\n            l = int(round(l))\n        if l not in self.adc.l_available:\n            raise Exception(\n                f\"ADC clock must be DAC clock/L where L={self.adc.l_available}.\"\n                + f\" Got {l} ({dac_clk}/{adc_clk})\"\n            )\n\n        self.config[\"dac_clk\"] = self._convert_input(dac_clk)\n        self.config[\"adc_clk\"] = self._convert_input(adc_clk)\n        self.config[\"converter_clk\"] = self._add_intermediate(self.config[\"dac_clk\"])\n\n        # Add single PLL constraint\n        # JESD204B/C transmitter is a power of 2 divisor of the lane rate of\n        # the JESD204B/C receiver\n        if self.solver == \"gekko\":\n            raise Exception(\"Not implemented for GEKKO\")\n        elif self.solver == \"CPLEX\":\n            divs = [int(2**d) for d in range(16)]\n            self.config[\"serdes_pll_div\"] = self._convert_input(\n                divs, \"serdes_pll_div\", default=1\n            )\n        else:\n            raise Exception(f\"Unknown solver {self.solver}\")\n\n        self._add_equation(\n            [self.config[\"serdes_pll_div\"] * self.adc.bit_clock == self.dac.bit_clock]\n        )\n\n    def get_required_clocks(self) -&gt; List:\n        \"\"\"Generate list required clocks.\n\n        For AD9081 this will contain [converter clock, sysref requirement SOS]\n\n        Returns:\n            List: List of solver variables, equations, and constants\n        \"\"\"\n        # SYSREF\n        self.config = {}\n        self.config[\"adc_lmfc_divisor_sysref\"] = self._convert_input(\n            self.adc._adc_lmfc_divisor_sysref, \"adc_lmfc_divisor_sysref\"\n        )\n        self.config[\"dac_lmfc_divisor_sysref\"] = self._convert_input(\n            self.dac._dac_lmfc_divisor_sysref, \"dac_lmfc_divisor_sysref\"\n        )\n\n        self.config[\"sysref_adc\"] = self._add_intermediate(\n            self.adc.multiframe_clock / self.config[\"adc_lmfc_divisor_sysref\"]\n        )\n        self.config[\"sysref_dac\"] = self._add_intermediate(\n            self.dac.multiframe_clock / self.config[\"dac_lmfc_divisor_sysref\"]\n        )\n\n        # Device Clocking\n        if self.clocking_option == \"direct\":\n            # raise Exception(\"Not implemented yet\")\n            # adc_clk = self.sample_clock * self.datapath_decimation\n            # clk = dac_clk\n            clk = self.dac.interpolation * self.dac.sample_clock\n        else:\n            clk = self._pll_config(rxtx=True)\n\n        # Objectives\n        # self.model.Obj(self.config[\"sysref\"])  # This breaks many searches\n        # self.model.Obj(-1*self.config[\"lmfc_divisor_sysref\"])\n\n        return [clk, self.config[\"sysref_adc\"], self.config[\"sysref_dac\"]]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081.__init__","title":"<code>__init__(model=None, solver=None)</code>","text":"<p>Initialize AD9081 clocking model for TX and RX.</p> <p>This is a common class used to handle TX and RX constraints together.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>(GEKKO, CpoModel)</code> <p>Solver model</p> <code>None</code> <code>solver</code> <code>str</code> <p>Solver name (gekko or CPLEX)</p> <code>None</code> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>def __init__(\n    self, model: Union[GEKKO, CpoModel] = None, solver: str = None\n) -&gt; None:\n    \"\"\"Initialize AD9081 clocking model for TX and RX.\n\n    This is a common class used to handle TX and RX constraints\n    together.\n\n    Args:\n        model (GEKKO,CpoModel): Solver model\n        solver (str): Solver name (gekko or CPLEX)\n    \"\"\"\n    if solver:\n        self.solver = solver\n    self.adc = ad9081_rx(model, solver=self.solver)\n    self.dac = ad9081_tx(model, solver=self.solver)\n    self.model = model\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081.get_required_clock_names","title":"<code>get_required_clock_names()</code>","text":"<p>Get list of strings of names of requested clocks.</p> <p>This list of names is for the clocks defined by get_required_clocks</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of strings of clock names in order</p> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>def get_required_clock_names(self) -&gt; List[str]:\n    \"\"\"Get list of strings of names of requested clocks.\n\n    This list of names is for the clocks defined by get_required_clocks\n\n    Returns:\n        List[str]: List of strings of clock names in order\n    \"\"\"\n    clk = (\n        \"ad9081_dac_clock\"\n        if self.adc.clocking_option == \"direct\"\n        else \"ad9081_pll_ref\"\n    )\n    return [clk, \"ad9081_adc_sysref\", \"ad9081_dac_sysref\"]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081.get_required_clocks","title":"<code>get_required_clocks()</code>","text":"<p>Generate list required clocks.</p> <p>For AD9081 this will contain [converter clock, sysref requirement SOS]</p> <p>Returns:</p> Name Type Description <code>List</code> <code>List</code> <p>List of solver variables, equations, and constants</p> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>def get_required_clocks(self) -&gt; List:\n    \"\"\"Generate list required clocks.\n\n    For AD9081 this will contain [converter clock, sysref requirement SOS]\n\n    Returns:\n        List: List of solver variables, equations, and constants\n    \"\"\"\n    # SYSREF\n    self.config = {}\n    self.config[\"adc_lmfc_divisor_sysref\"] = self._convert_input(\n        self.adc._adc_lmfc_divisor_sysref, \"adc_lmfc_divisor_sysref\"\n    )\n    self.config[\"dac_lmfc_divisor_sysref\"] = self._convert_input(\n        self.dac._dac_lmfc_divisor_sysref, \"dac_lmfc_divisor_sysref\"\n    )\n\n    self.config[\"sysref_adc\"] = self._add_intermediate(\n        self.adc.multiframe_clock / self.config[\"adc_lmfc_divisor_sysref\"]\n    )\n    self.config[\"sysref_dac\"] = self._add_intermediate(\n        self.dac.multiframe_clock / self.config[\"dac_lmfc_divisor_sysref\"]\n    )\n\n    # Device Clocking\n    if self.clocking_option == \"direct\":\n        # raise Exception(\"Not implemented yet\")\n        # adc_clk = self.sample_clock * self.datapath_decimation\n        # clk = dac_clk\n        clk = self.dac.interpolation * self.dac.sample_clock\n    else:\n        clk = self._pll_config(rxtx=True)\n\n    # Objectives\n    # self.model.Obj(self.config[\"sysref\"])  # This breaks many searches\n    # self.model.Obj(-1*self.config[\"lmfc_divisor_sysref\"])\n\n    return [clk, self.config[\"sysref_adc\"], self.config[\"sysref_dac\"]]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081.validate_config","title":"<code>validate_config()</code>","text":"<p>Validate device configurations including JESD and clocks of both ADC and DAC.</p> <p>This check only is for static configuration that does not include variables which are solved.</p> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>def validate_config(self) -&gt; None:\n    \"\"\"Validate device configurations including JESD and clocks of both ADC and DAC.\n\n    This check only is for static configuration that does not include\n    variables which are solved.\n    \"\"\"\n    self.adc.validate_config()\n    self.dac.validate_config()\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_core","title":"<code>ad9081_core</code>","text":"<p>               Bases: <code>converter</code></p> <p>AD9081 high speed MxFE model.</p> <p>This model supports both direct clock configurations and on-board generation</p> <p>Clocking: AD9081 can internally generate or leverage external clocks. The high speed clock within the system is referred to as the DAC clock and the ADC clock will be a divided down version of the clock:     adc_clock  == dac_clock / L, where L = 1,2,3,4</p> <p>For internal generation, the DAC clock is generated through an integer PLL through the following relation:     dac_clock == ((m_vco * n_vco) / R * ref_clock) / D</p> <p>For external clocks, the clock must be provided at the DAC clock rate</p> <p>Once we have the DAC clock the data rates can be directly evaluated into each JESD framer:</p> <p>rx_baseband_sample_rate = (dac_clock / L) / datapath_decimation tx_baseband_sample_rate = dac_clock / datapath_interpolation</p> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>class ad9081_core(converter, metaclass=ABCMeta):\n    \"\"\"AD9081 high speed MxFE model.\n\n    This model supports both direct clock configurations and on-board\n    generation\n\n    Clocking: AD9081 can internally generate or leverage external clocks. The\n    high speed clock within the system is referred to as the DAC clock and\n    the ADC clock will be a divided down version of the clock:\n        adc_clock  == dac_clock / L, where L = 1,2,3,4\n\n\n    For internal generation, the DAC clock is generated through an integer PLL\n    through the following relation:\n        dac_clock == ((m_vco * n_vco) / R * ref_clock) / D\n\n    For external clocks, the clock must be provided at the DAC clock rate\n\n    Once we have the DAC clock the data rates can be directly evaluated into\n    each JESD framer:\n\n    rx_baseband_sample_rate = (dac_clock / L) / datapath_decimation\n    tx_baseband_sample_rate = dac_clock / datapath_interpolation\n\n    \"\"\"\n\n    device_clock_available = None  # FIXME\n    device_clock_ranges = None  # FIXME\n\n    model: Union[GEKKO, CpoModel] = None\n\n    name = \"AD9081\"\n\n    # Integrated PLL constants\n    l_available = [1, 2, 3, 4]\n    l = 1  # pylint:  disable=E741\n    m_vco_available = [5, 7, 8, 11]  # 8 is nominal\n    m_vco = 8\n    n_vco_available = [*range(2, 50 + 1)]\n    n_vco = 2\n    r_available = [1, 2, 3, 4]\n    r = 1\n    d_available = [1, 2, 3, 4]\n    d = 1\n    # Integrated PLL limits\n    pfd_min = 25e6\n    pfd_max = 750e6\n    vco_min = 6e9\n    vco_max = 12e9\n\n    # JESD parameters\n    available_jesd_modes = [\"jesd204b\", \"jesd204c\"]\n    M_available = [1, 2, 3, 4, 6, 8, 12, 16]\n    L_available = [1, 2, 3, 4, 6, 8]\n    N_available = [12, 16]\n    Np_available = [12, 16, 24]\n    F_available = [1, 2, 3, 4, 6, 8, 12, 16, 24, 32]\n    S_available = [1, 2, 4, 8]\n    # FIXME\n    # K_available = [4, 8, 12, 16, 20, 24, 28, 32]\n    K_available = [16, 32, 64, 128, 256]\n    CS_available = [0, 1, 2, 3]\n    CF_available = [0]\n    # FIXME\n\n    # Clocking constraints\n    clocking_option_available = [\"integrated_pll\", \"direct\"]\n    _clocking_option = \"integrated_pll\"\n    bit_clock_min_available = {\"jesd204b\": 1.5e9, \"jesd204c\": 6e9}\n    bit_clock_max_available = {\"jesd204b\": 15.5e9, \"jesd204c\": 24.75e9}\n\n    config = {}  # type: ignore\n\n    device_clock_max = 12e9\n    _lmfc_divisor_sysref_available = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n\n    def _check_valid_internal_configuration(self) -&gt; None:\n        # FIXME\n        pass\n\n    def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n        \"\"\"Extract configurations from solver results.\n\n        Collect internal converter configuration and output clock definitions\n        leading to connected devices (clock chips, FPGAs)\n\n        Args:\n            solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n        Returns:\n            Dict: Dictionary of clocking rates and dividers for configuration\n        \"\"\"\n        if solution:\n            self.solution = solution\n        if self.clocking_option == \"integrated_pll\":\n            pll_config: Dict = {\n                \"m_vco\": self._get_val(self.config[\"ad9081_m_vco\"]),\n                \"n_vco\": self._get_val(self.config[\"ad9081_n_vco\"]),\n                \"r\": self._get_val(self.config[\"ad9081_r\"]),\n                \"d\": self._get_val(self.config[\"ad9081_d\"]),\n            }\n            if \"serdes_pll_div\" in self.config:\n                pll_config[\"serdes_pll_div\"] = self._get_val(\n                    self.config[\"serdes_pll_div\"]\n                )\n            return {\"clocking_option\": self.clocking_option, \"pll_config\": pll_config}\n        else:\n            if \"serdes_pll_div\" in self.config:\n                return {\n                    \"serdes_pll_div\": self._get_val(self.config[\"serdes_pll_div\"]),\n                    \"clocking_option\": self.clocking_option,\n                }\n            return {\"clocking_option\": self.clocking_option}\n\n    def get_required_clock_names(self) -&gt; List[str]:\n        \"\"\"Get list of strings of names of requested clocks.\n\n        This list of names is for the clocks defined by get_required_clocks\n\n        Returns:\n            List[str]: List of strings of clock names in order\n        \"\"\"\n        clk = (\n            \"ad9081_dac_clock\" if self.clocking_option == \"direct\" else \"ad9081_pll_ref\"\n        )\n        return [clk, \"ad9081_sysref\"]\n\n    @property\n    @abstractmethod\n    def _converter_clock_config(self) -&gt; None:\n        \"\"\"Define source clocking relation based on ADC, DAC, or both.\n\n        Raises:\n            NotImplementedError: Method not implemented\n        \"\"\"\n        raise NotImplementedError\n\n    def _pll_config(self, rxtx: bool = False) -&gt; Dict:\n        self._converter_clock_config()  # type: ignore\n\n        self.config[\"ad9081_m_vco\"] = self._convert_input([5, 7, 8, 11], \"ad9081_m_vco\")\n        self.config[\"ad9081_n_vco\"] = self._convert_input(\n            [*range(2, 51)], \"ad9081_n_vco\"\n        )\n        self.config[\"ad9081_r\"] = self._convert_input([1, 2, 3, 4], \"ad9081_r\")\n        self.config[\"ad9081_d\"] = self._convert_input([1, 2, 3, 4], \"ad9081_d\")\n\n        self.config[\"ad9081_ref_clk\"] = self._add_intermediate(\n            self.config[\"converter_clk\"]\n            * self.config[\"ad9081_d\"]\n            * self.config[\"ad9081_r\"]\n            / (self.config[\"ad9081_m_vco\"] * self.config[\"ad9081_n_vco\"])\n        )\n        # if self.solver == \"gekko\":\n        #     self.config[\"ref_clk\"] = self.model.Var(\n        #         integer=True,\n        #         lb=1e6,\n        #         ub=self.device_clock_max,\n        #         value=self.device_clock_max,\n        #     )\n        # elif self.solver == \"CPLEX\":\n        #     # self.config[\"ref_clk\"] = integer_var(\n        #     #     int(1e6), int(self.device_clock_max), \"ref_clk\"\n        #     # )\n        #     self.config[\"ref_clk\"] = (\n        #         self.config[\"converter_clk\"]\n        #         * self.config[\"d\"]\n        #         * self.config[\"r\"]\n        #         / (self.config[\"m_vco\"] * self.config[\"n_vco\"])\n        #     )\n        # else:\n        #     raise Exception(\"Unknown solver\")\n\n        self.config[\"ad9081_vco\"] = self._add_intermediate(\n            self.config[\"ad9081_ref_clk\"]\n            * self.config[\"ad9081_m_vco\"]\n            * self.config[\"ad9081_n_vco\"]\n            / self.config[\"ad9081_r\"],\n        )\n\n        # if self.solver == \"gekko\":\n        #     self.config[\"vco\"] = self.model.Intermediate(\n        #         self.config[\"ref_clk\"]\n        #         * self.config[\"m_vco\"]\n        #         * self.config[\"n_vco\"]\n        #         / self.config[\"r\"],\n        #     )\n        # elif self.solver == \"CPLEX\":\n        #     self.config[\"vco\"] = (\n        #         self.config[\"ref_clk\"]\n        #         * self.config[\"m_vco\"]\n        #         * self.config[\"n_vco\"]\n        #         / self.config[\"r\"]\n        #     )\n        # else:\n        #     raise Exception(\"Unknown solver: %s\" % self.solver)\n\n        self._add_equation(\n            [\n                self.config[\"ad9081_vco\"] &gt;= self.vco_min,\n                self.config[\"ad9081_vco\"] &lt;= self.vco_max,\n                self.config[\"ad9081_ref_clk\"] / self.config[\"ad9081_r\"] &lt;= self.pfd_max,\n                self.config[\"ad9081_ref_clk\"] / self.config[\"ad9081_r\"] &gt;= self.pfd_min,\n                self.config[\"ad9081_ref_clk\"] &gt;= int(100e6),\n                self.config[\"ad9081_ref_clk\"] &lt;= int(2e9),\n                # self.config[\"converter_clk\"] &lt;= self.device_clock_max,\n                self.config[\"converter_clk\"]\n                &gt;= (\n                    self.converter_clock_min\n                    if not rxtx\n                    else self.dac.converter_clock_min  # type: ignore\n                ),\n                self.config[\"converter_clk\"]\n                &lt;= (\n                    self.converter_clock_max\n                    if not rxtx\n                    else self.dac.converter_clock_max  # type: ignore\n                ),\n            ]\n        )\n\n        # Make ref_clk an integer since API requires it\n        if self.solver == \"CPLEX\":\n            self.config[\"integer_ad9081_ref_clk\"] = integer_var(\n                min=int(100e6), max=int(2e9), name=\"integer_ad9081_ref_clk\"\n            )\n            self._add_equation(\n                [self.config[\"integer_ad9081_ref_clk\"] == self.config[\"ad9081_ref_clk\"]]\n            )\n        else:\n            raise Exception(\"Only CPLEX solver supported\")\n\n        return self.config[\"ad9081_ref_clk\"]\n\n    def get_required_clocks(self) -&gt; List:\n        \"\"\"Generate list required clocks.\n\n        For AD9081 this will contain [converter clock, sysref requirement SOS]\n\n        Returns:\n            List: List of solver variables, equations, and constants\n        \"\"\"\n        # SYSREF\n        self.config = {}\n        self.config[\"lmfc_divisor_sysref\"] = self._convert_input(\n            self._lmfc_divisor_sysref_available, \"lmfc_divisor_sysref\"\n        )\n\n        self.config[\"sysref\"] = self._add_intermediate(\n            self.multiframe_clock / self.config[\"lmfc_divisor_sysref\"]\n        )\n\n        # Device Clocking\n        if self.clocking_option == \"direct\":\n            # raise Exception(\"Not implemented yet\")\n            clk = self.sample_clock * self.datapath_decimation\n        else:\n            clk = self._pll_config()  # type: ignore\n\n        # Objectives\n        # self.model.Obj(self.config[\"sysref\"])  # This breaks many searches\n        # self.model.Obj(-1*self.config[\"lmfc_divisor_sysref\"])\n\n        return [clk, self.config[\"sysref\"]]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_core.get_config","title":"<code>get_config(solution=None)</code>","text":"<p>Extract configurations from solver results.</p> <p>Collect internal converter configuration and output clock definitions leading to connected devices (clock chips, FPGAs)</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>CpoSolveResult</code> <p>CPlex solution. Only needed for CPlex solver</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>Dictionary of clocking rates and dividers for configuration</p> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n    \"\"\"Extract configurations from solver results.\n\n    Collect internal converter configuration and output clock definitions\n    leading to connected devices (clock chips, FPGAs)\n\n    Args:\n        solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n    Returns:\n        Dict: Dictionary of clocking rates and dividers for configuration\n    \"\"\"\n    if solution:\n        self.solution = solution\n    if self.clocking_option == \"integrated_pll\":\n        pll_config: Dict = {\n            \"m_vco\": self._get_val(self.config[\"ad9081_m_vco\"]),\n            \"n_vco\": self._get_val(self.config[\"ad9081_n_vco\"]),\n            \"r\": self._get_val(self.config[\"ad9081_r\"]),\n            \"d\": self._get_val(self.config[\"ad9081_d\"]),\n        }\n        if \"serdes_pll_div\" in self.config:\n            pll_config[\"serdes_pll_div\"] = self._get_val(\n                self.config[\"serdes_pll_div\"]\n            )\n        return {\"clocking_option\": self.clocking_option, \"pll_config\": pll_config}\n    else:\n        if \"serdes_pll_div\" in self.config:\n            return {\n                \"serdes_pll_div\": self._get_val(self.config[\"serdes_pll_div\"]),\n                \"clocking_option\": self.clocking_option,\n            }\n        return {\"clocking_option\": self.clocking_option}\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_core.get_required_clock_names","title":"<code>get_required_clock_names()</code>","text":"<p>Get list of strings of names of requested clocks.</p> <p>This list of names is for the clocks defined by get_required_clocks</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of strings of clock names in order</p> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>def get_required_clock_names(self) -&gt; List[str]:\n    \"\"\"Get list of strings of names of requested clocks.\n\n    This list of names is for the clocks defined by get_required_clocks\n\n    Returns:\n        List[str]: List of strings of clock names in order\n    \"\"\"\n    clk = (\n        \"ad9081_dac_clock\" if self.clocking_option == \"direct\" else \"ad9081_pll_ref\"\n    )\n    return [clk, \"ad9081_sysref\"]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_core.get_required_clocks","title":"<code>get_required_clocks()</code>","text":"<p>Generate list required clocks.</p> <p>For AD9081 this will contain [converter clock, sysref requirement SOS]</p> <p>Returns:</p> Name Type Description <code>List</code> <code>List</code> <p>List of solver variables, equations, and constants</p> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>def get_required_clocks(self) -&gt; List:\n    \"\"\"Generate list required clocks.\n\n    For AD9081 this will contain [converter clock, sysref requirement SOS]\n\n    Returns:\n        List: List of solver variables, equations, and constants\n    \"\"\"\n    # SYSREF\n    self.config = {}\n    self.config[\"lmfc_divisor_sysref\"] = self._convert_input(\n        self._lmfc_divisor_sysref_available, \"lmfc_divisor_sysref\"\n    )\n\n    self.config[\"sysref\"] = self._add_intermediate(\n        self.multiframe_clock / self.config[\"lmfc_divisor_sysref\"]\n    )\n\n    # Device Clocking\n    if self.clocking_option == \"direct\":\n        # raise Exception(\"Not implemented yet\")\n        clk = self.sample_clock * self.datapath_decimation\n    else:\n        clk = self._pll_config()  # type: ignore\n\n    # Objectives\n    # self.model.Obj(self.config[\"sysref\"])  # This breaks many searches\n    # self.model.Obj(-1*self.config[\"lmfc_divisor_sysref\"])\n\n    return [clk, self.config[\"sysref\"]]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_rx","title":"<code>ad9081_rx</code>","text":"<p>               Bases: <code>adc</code>, <code>ad9081_core</code></p> <p>AD9081 Receive model.</p> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>class ad9081_rx(adc, ad9081_core):\n    \"\"\"AD9081 Receive model.\"\"\"\n\n    name = \"AD9081_RX\"\n    converter_type = \"adc\"\n\n    converter_clock_min = 1.45e9\n    converter_clock_max = 4e9\n\n    sample_clock_min = 312.5e6 / 16\n    sample_clock_max = 4e9\n\n    quick_configuration_modes = _load_rx_config_modes()\n\n    datapath = ad9081_dp_rx()\n    decimation_available = [\n        1,\n        2,\n        3,\n        4,\n        6,\n        8,\n        9,\n        12,\n        16,\n        18,\n        24,\n        32,\n        36,\n        48,\n        64,\n        72,\n        96,\n        144,\n        \"auto\",\n    ]\n\n    @property\n    def decimation(self) -&gt; int:\n        \"\"\"Decimation factor. This is the product of the coarse and fine decimation.\"\"\"\n        return self.datapath.decimation_overall\n\n    @decimation.setter\n    def decimation(self, value: int) -&gt; None:\n        raise Exception(\n            \"Decimation is not writable and should be set by the properties\\n\"\n            + \" datapath.cddc_decimations and datapath.fddc_decimations\"\n        )\n\n    _adc_lmfc_divisor_sysref = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n\n    def __init__(\n        self, model: Union[GEKKO, CpoModel] = None, solver: str = None\n    ) -&gt; None:\n        \"\"\"Initialize AD9081 clocking model for RX.\n\n        This is a common class used to handle RX constraints\n        together.\n\n        Args:\n            model (GEKKO,CpoModel): Solver model\n            solver (str): Solver name (gekko or CPLEX)\n        \"\"\"\n        if solver:\n            self.solver = solver\n        if model:\n            self.model = model\n        self.set_quick_configuration_mode(\"3.01\", \"jesd204b\")\n\n    def _converter_clock_config(self) -&gt; None:\n        \"\"\"RX specific configuration of internal PLL config.\n\n        This method will update the config struct to include\n        the RX clocking constraints\n        \"\"\"\n        adc_clk = self.decimation * self.sample_clock\n        self.config[\"l\"] = self._convert_input([1, 2, 3, 4], \"l\")\n        self.config[\"adc_clk\"] = self._convert_input(adc_clk)\n        self.config[\"converter_clk\"] = self._add_intermediate(\n            self.config[\"adc_clk\"] * self.config[\"l\"]\n        )\n\n    def _check_valid_internal_configuration(self) -&gt; None:\n        mode = self._check_valid_jesd_mode()\n        cfg = self.quick_configuration_modes[self.jesd_class][mode]\n\n        # Check decimation is valid\n        if isinstance(self.decimation, int) or isinstance(self.decimation, float):\n            found = False\n            for dec in cfg[\"decimations\"]:\n                found = found or dec[\"coarse\"] * dec[\"fine\"] == self.decimation\n            assert (\n                found\n            ), f\"Decimation {self.decimation} not valid for current JESD mode\"\n        elif self.decimation == \"auto\":\n            for dec in cfg[\"decimations\"]:\n                dec = dec[\"coarse\"] * dec[\"fine\"]\n                # Check\n                cc = dec * self.sample_clock\n                # if dec == 64:\n                #     print(\"dec\", dec, cc, cfg[\"coarse\"], cfg[\"fine\"])\n                if cc &lt;= self.converter_clock_max and cc &gt;= self.converter_clock_min:\n                    self.decimation = dec\n                    print(\"Decimation automatically determined:\", dec)\n                    return\n            raise Exception(\"No valid decimation found\")\n        else:\n            raise Exception(\"Decimation not valid\")\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_rx.decimation","title":"<code>decimation: int</code>  <code>property</code> <code>writable</code>","text":"<p>Decimation factor. This is the product of the coarse and fine decimation.</p>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_rx.__init__","title":"<code>__init__(model=None, solver=None)</code>","text":"<p>Initialize AD9081 clocking model for RX.</p> <p>This is a common class used to handle RX constraints together.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>(GEKKO, CpoModel)</code> <p>Solver model</p> <code>None</code> <code>solver</code> <code>str</code> <p>Solver name (gekko or CPLEX)</p> <code>None</code> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>def __init__(\n    self, model: Union[GEKKO, CpoModel] = None, solver: str = None\n) -&gt; None:\n    \"\"\"Initialize AD9081 clocking model for RX.\n\n    This is a common class used to handle RX constraints\n    together.\n\n    Args:\n        model (GEKKO,CpoModel): Solver model\n        solver (str): Solver name (gekko or CPLEX)\n    \"\"\"\n    if solver:\n        self.solver = solver\n    if model:\n        self.model = model\n    self.set_quick_configuration_mode(\"3.01\", \"jesd204b\")\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_tx","title":"<code>ad9081_tx</code>","text":"<p>               Bases: <code>dac</code>, <code>ad9081_core</code></p> <p>AD9081 Transmit model.</p> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>class ad9081_tx(dac, ad9081_core):\n    \"\"\"AD9081 Transmit model.\"\"\"\n\n    name = \"AD9081_TX\"\n    converter_type = \"dac\"\n\n    converter_clock_min = 2.9e9\n    converter_clock_max = 12e9\n\n    sample_clock_min = 2.9e9 / (6 * 24)  # with max interpolation\n    sample_clock_max = 12e9\n\n    quick_configuration_modes = _load_tx_config_modes()\n\n    datapath = ad9081_dp_tx()\n    interpolation_available = [\n        1,\n        2,\n        3,\n        4,\n        6,\n        8,\n        9,\n        12,\n        16,\n        18,\n        24,\n        32,\n        36,\n        48,\n        64,\n        72,\n        96,\n        144,\n    ]\n\n    @property\n    def interpolation(self) -&gt; int:\n        \"\"\"Interpolation factor.\n\n        This is the product of the coarse and fine interpolation.\n\n        Returns:\n            int: Interpolation factor\n        \"\"\"\n        return self.datapath.interpolation_overall\n\n    @interpolation.setter\n    def interpolation(self, value: int) -&gt; None:\n        raise Exception(\n            \"Interpolation is not writable and should be set by the properties\\n\"\n            + \" datapath.cduc_interpolation and datapath.fduc_interpolation\"\n        )\n\n    _dac_lmfc_divisor_sysref = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n\n    def __init__(\n        self, model: Union[GEKKO, CpoModel] = None, solver: str = None\n    ) -&gt; None:\n        \"\"\"Initialize AD9081 clocking model for TX.\n\n        This is a common class used to handle TX constraints\n        together.\n\n        Args:\n            model (GEKKO,CpoModel): Solver model\n            solver (str): Solver name (gekko or CPLEX)\n        \"\"\"\n        if solver:\n            self.solver = solver\n        if model:\n            self.model = model\n        self.set_quick_configuration_mode(\"0\", \"jesd204c\")\n\n    def _converter_clock_config(self) -&gt; None:\n        \"\"\"TX specific configuration of internall PLL config.\n\n        This method will update the config struct to include\n        the TX clocking constraints\n        \"\"\"\n        dac_clk = self.interpolation * self.sample_clock\n        self.config[\"dac_clk\"] = self._convert_input(dac_clk)\n        self.config[\"converter_clk\"] = self._add_intermediate(self.config[\"dac_clk\"])\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_tx.interpolation","title":"<code>interpolation: int</code>  <code>property</code> <code>writable</code>","text":"<p>Interpolation factor.</p> <p>This is the product of the coarse and fine interpolation.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Interpolation factor</p>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9081_tx.__init__","title":"<code>__init__(model=None, solver=None)</code>","text":"<p>Initialize AD9081 clocking model for TX.</p> <p>This is a common class used to handle TX constraints together.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>(GEKKO, CpoModel)</code> <p>Solver model</p> <code>None</code> <code>solver</code> <code>str</code> <p>Solver name (gekko or CPLEX)</p> <code>None</code> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>def __init__(\n    self, model: Union[GEKKO, CpoModel] = None, solver: str = None\n) -&gt; None:\n    \"\"\"Initialize AD9081 clocking model for TX.\n\n    This is a common class used to handle TX constraints\n    together.\n\n    Args:\n        model (GEKKO,CpoModel): Solver model\n        solver (str): Solver name (gekko or CPLEX)\n    \"\"\"\n    if solver:\n        self.solver = solver\n    if model:\n        self.model = model\n    self.set_quick_configuration_mode(\"0\", \"jesd204c\")\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9082","title":"<code>ad9082</code>","text":"<p>               Bases: <code>ad9081</code></p> <p>AD9081 combined transmit and receive model.</p> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>class ad9082(ad9081):\n    \"\"\"AD9081 combined transmit and receive model.\"\"\"\n\n    converter_clock_min = ad9082_rx.converter_clock_min\n    converter_clock_max = ad9082_rx.converter_clock_max\n    quick_configuration_modes: Dict[str, Any] = {}\n    _nested = [\"adc\", \"dac\"]\n\n    def __init__(\n        self, model: Union[GEKKO, CpoModel] = None, solver: str = None\n    ) -&gt; None:\n        \"\"\"Initialize AD9081 clocking model for TX and RX.\n\n        This is a common class used to handle TX and RX constraints\n        together.\n\n        Args:\n            model (GEKKO,CpoModel): Solver model\n            solver (str): Solver name (gekko or CPLEX)\n        \"\"\"\n        if solver:\n            self.solver = solver\n        self.adc = ad9082_rx(model, solver=self.solver)\n        self.dac = ad9082_tx(model, solver=self.solver)\n        self.model = model\n\n    def _get_converters(self) -&gt; List[Union[converter, converter]]:\n        return [self.adc, self.dac]\n\n    def get_required_clock_names(self) -&gt; List[str]:\n        \"\"\"Get list of strings of names of requested clocks.\n\n        This list of names is for the clocks defined by get_required_clocks\n\n        Returns:\n            List[str]: List of strings of clock names in order\n        \"\"\"\n        clk = (\n            \"ad9082_dac_clock\"\n            if self.adc.clocking_option == \"direct\"\n            else \"ad9082_pll_ref\"\n        )\n        return [clk, \"ad9082_adc_sysref\", \"ad9082_dac_sysref\"]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9082.__init__","title":"<code>__init__(model=None, solver=None)</code>","text":"<p>Initialize AD9081 clocking model for TX and RX.</p> <p>This is a common class used to handle TX and RX constraints together.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>(GEKKO, CpoModel)</code> <p>Solver model</p> <code>None</code> <code>solver</code> <code>str</code> <p>Solver name (gekko or CPLEX)</p> <code>None</code> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>def __init__(\n    self, model: Union[GEKKO, CpoModel] = None, solver: str = None\n) -&gt; None:\n    \"\"\"Initialize AD9081 clocking model for TX and RX.\n\n    This is a common class used to handle TX and RX constraints\n    together.\n\n    Args:\n        model (GEKKO,CpoModel): Solver model\n        solver (str): Solver name (gekko or CPLEX)\n    \"\"\"\n    if solver:\n        self.solver = solver\n    self.adc = ad9082_rx(model, solver=self.solver)\n    self.dac = ad9082_tx(model, solver=self.solver)\n    self.model = model\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9082.get_required_clock_names","title":"<code>get_required_clock_names()</code>","text":"<p>Get list of strings of names of requested clocks.</p> <p>This list of names is for the clocks defined by get_required_clocks</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of strings of clock names in order</p> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>def get_required_clock_names(self) -&gt; List[str]:\n    \"\"\"Get list of strings of names of requested clocks.\n\n    This list of names is for the clocks defined by get_required_clocks\n\n    Returns:\n        List[str]: List of strings of clock names in order\n    \"\"\"\n    clk = (\n        \"ad9082_dac_clock\"\n        if self.adc.clocking_option == \"direct\"\n        else \"ad9082_pll_ref\"\n    )\n    return [clk, \"ad9082_adc_sysref\", \"ad9082_dac_sysref\"]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9082_rx","title":"<code>ad9082_rx</code>","text":"<p>               Bases: <code>ad9081_rx</code></p> <p>AD9082 MxFE RX Clocking Model.</p> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>class ad9082_rx(ad9081_rx):\n    \"\"\"AD9082 MxFE RX Clocking Model.\"\"\"\n\n    converter_clock_max = 6e9\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9081.ad9082_tx","title":"<code>ad9082_tx</code>","text":"<p>               Bases: <code>ad9081_tx</code></p> <p>AD9082 MxFE TX Clocking Model.</p> Source code in <code>adijif/converters/ad9081.py</code> <pre><code>class ad9082_tx(ad9081_tx):\n    \"\"\"AD9082 MxFE TX Clocking Model.\"\"\"\n\n    pass\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9680.ad9680","title":"<code>ad9680</code>","text":"<p>               Bases: <code>ad9680_bf</code></p> <p>AD9680 high speed ADC model.</p> <p>This model supports direct clock configurations</p> <p>Clocking: AD9680 has directly clocked ADC that have optional input dividers. The sample rate can be determined as follows:</p> <pre><code>baseband_sample_rate = (input_clock / input_clock_divider) / datapath_decimation\n</code></pre> Source code in <code>adijif/converters/ad9680.py</code> <pre><code>class ad9680(ad9680_bf):\n    \"\"\"AD9680 high speed ADC model.\n\n    This model supports direct clock configurations\n\n    Clocking: AD9680 has directly clocked ADC that have optional input dividers.\n    The sample rate can be determined as follows:\n\n        baseband_sample_rate = (input_clock / input_clock_divider) / datapath_decimation\n    \"\"\"\n\n    name = \"AD9680\"\n    converter_type = \"adc\"\n\n    # JESD parameters\n    _jesd_params_to_skip_check = [\"DualLink\", \"CS\", \"N\", \"HD\"]\n    available_jesd_modes = [\"jesd204b\"]\n    K_available = [4, 8, 12, 16, 20, 24, 28, 32]\n    L_available = [1, 2, 4]\n    M_available = [1, 2, 4, 8]\n    N_available = [*range(7, 16)]\n    Np_available = [8, 16]\n    F_available = [1, 2, 4, 8, 16]\n    CS_available = [0, 1, 2, 3]\n    CF_available = [0]\n    S_available = [1, 2, 4]\n\n    # Clock constraints\n    clocking_option_available = [\"direct\"]\n    _clocking_option = \"direct\"\n    converter_clock_min = 300e6\n    converter_clock_max = 1.25e9\n    bit_clock_min_available = {\"jesd204b\": 3.125e9}\n    bit_clock_max_available = {\"jesd204b\": 12.5e9}\n    sample_clock_min = 300e6\n    sample_clock_max = 1250e6\n    decimation_available = [1, 2, 4, 8, 16]\n    _decimation = 1\n    _lmfc_sys_divisor = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    quick_configuration_modes = {\"jesd204b\": quick_configuration_modes}\n\n    # Input clock requirements\n    input_clock_divider_available = [1, 2, 4, 8]  # FIXME\n    input_clock_divider = 1  # FIXME\n    input_clock_max = 4e9  # FIXME\n\n    \"\"\" Clocking\n        AD9680 has directly clocked ADCs that have optional input dividers.\n        The sample rate can be determined as follows:\n\n        baseband_sample_rate = (input_clock / input_clock_divider) / datapath_decimation\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ANN401\n        \"\"\"Initialize AD9680 class.\n\n        Objects will default to mode 0x88 with 1e9 sample_clock.\n\n        Args:\n            *args (Any): Pass through arguments\n            **kwargs (Any): Pass through keyword arguments\n        \"\"\"\n        # Set default mode\n        self.set_quick_configuration_mode(str(0x88))\n        self.K = 32\n        self.sample_clock = 1e9\n        super().__init__(*args, **kwargs)\n\n    def _check_valid_jesd_mode(self) -&gt; str:\n        \"\"\"Verify current JESD configuration for part is valid.\n\n        Returns:\n            str: Current JESD mode\n        \"\"\"\n        if self.F == 1:\n            assert self.K in [20, 24, 28, 32], \"Invalid K value for F=1\"\n        if self.F == 2:\n            assert self.K in [12, 16, 20, 24, 28, 32], \"Invalid K value for F=1\"\n        if self.F == 4:\n            assert self.K in [8, 12, 16, 20, 24, 28, 32], \"Invalid K value for F=1\"\n        if self.F in [8, 16]:\n            assert self.K in [4, 8, 12, 16, 20, 24, 28, 32], \"Invalid K value for F=1\"\n\n        return super()._check_valid_jesd_mode()\n\n    def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n        \"\"\"Extract configurations from solver results.\n\n        Collect internal converter configuration and output clock definitions\n        leading to connected devices (clock chips, FPGAs)\n\n        Args:\n            solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n        Returns:\n            Dict: Dictionary of clocking rates and dividers for configuration\n        \"\"\"\n        return {\"clocking_option\": self.clocking_option, \"decimation\": self.decimation}\n\n    def get_required_clock_names(self) -&gt; List[str]:\n        \"\"\"Get list of strings of names of requested clocks.\n\n        This list of names is for the clocks defined by get_required_clocks\n\n        Returns:\n            List[str]: List of strings of clock names in order\n        \"\"\"\n        return [\"ad9680_adc_clock\", \"ad9680_sysref\"]\n\n    def get_required_clocks(self) -&gt; List:\n        \"\"\"Generate list required clocks.\n\n        For AD9680 this will contain [converter clock, sysref requirement SOS]\n\n        Returns:\n            List: List of solver variables, equations, and constants\n        \"\"\"\n        # possible_sysrefs = []\n        # for n in range(1, 10):\n        #     r = self.multiframe_clock / (n * n)\n        #     if r == int(r) and r &gt; 1e6:\n        #         possible_sysrefs.append(r)\n        # self.config = {\"sysref\": self.model.sos1(possible_sysrefs)}\n\n        self.config = {}\n        self.config[\"lmfc_divisor_sysref\"] = self._convert_input(\n            self._lmfc_sys_divisor,\n            default=self._lmfc_sys_divisor[-1],\n            name=\"AD9680_lmfc_divisor_sysref\",\n        )\n\n        self.config[\"lmfc_divisor_sysref_squared\"] = self._add_intermediate(\n            self.config[\"lmfc_divisor_sysref\"] * self.config[\"lmfc_divisor_sysref\"]\n        )\n        self.config[\"sysref\"] = self._add_intermediate(\n            self.multiframe_clock / self.config[\"lmfc_divisor_sysref_squared\"]\n        )\n\n        # Objectives\n        # self.model.Obj(self.config[\"sysref\"])  # This breaks many searches\n\n        return [self.converter_clock, self.config[\"sysref\"]]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9680.ad9680.input_clock_max","title":"<code>input_clock_max = 4000000000.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Clocking AD9680 has directly clocked ADCs that have optional input dividers. The sample rate can be determined as follows:</p> <p>baseband_sample_rate = (input_clock / input_clock_divider) / datapath_decimation</p>"},{"location":"devs/converters/#adijif.converters.ad9680.ad9680.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize AD9680 class.</p> <p>Objects will default to mode 0x88 with 1e9 sample_clock.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Pass through arguments</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Pass through keyword arguments</p> <code>{}</code> Source code in <code>adijif/converters/ad9680.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ANN401\n    \"\"\"Initialize AD9680 class.\n\n    Objects will default to mode 0x88 with 1e9 sample_clock.\n\n    Args:\n        *args (Any): Pass through arguments\n        **kwargs (Any): Pass through keyword arguments\n    \"\"\"\n    # Set default mode\n    self.set_quick_configuration_mode(str(0x88))\n    self.K = 32\n    self.sample_clock = 1e9\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9680.ad9680.get_config","title":"<code>get_config(solution=None)</code>","text":"<p>Extract configurations from solver results.</p> <p>Collect internal converter configuration and output clock definitions leading to connected devices (clock chips, FPGAs)</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>CpoSolveResult</code> <p>CPlex solution. Only needed for CPlex solver</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>Dictionary of clocking rates and dividers for configuration</p> Source code in <code>adijif/converters/ad9680.py</code> <pre><code>def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n    \"\"\"Extract configurations from solver results.\n\n    Collect internal converter configuration and output clock definitions\n    leading to connected devices (clock chips, FPGAs)\n\n    Args:\n        solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n    Returns:\n        Dict: Dictionary of clocking rates and dividers for configuration\n    \"\"\"\n    return {\"clocking_option\": self.clocking_option, \"decimation\": self.decimation}\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9680.ad9680.get_required_clock_names","title":"<code>get_required_clock_names()</code>","text":"<p>Get list of strings of names of requested clocks.</p> <p>This list of names is for the clocks defined by get_required_clocks</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of strings of clock names in order</p> Source code in <code>adijif/converters/ad9680.py</code> <pre><code>def get_required_clock_names(self) -&gt; List[str]:\n    \"\"\"Get list of strings of names of requested clocks.\n\n    This list of names is for the clocks defined by get_required_clocks\n\n    Returns:\n        List[str]: List of strings of clock names in order\n    \"\"\"\n    return [\"ad9680_adc_clock\", \"ad9680_sysref\"]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9680.ad9680.get_required_clocks","title":"<code>get_required_clocks()</code>","text":"<p>Generate list required clocks.</p> <p>For AD9680 this will contain [converter clock, sysref requirement SOS]</p> <p>Returns:</p> Name Type Description <code>List</code> <code>List</code> <p>List of solver variables, equations, and constants</p> Source code in <code>adijif/converters/ad9680.py</code> <pre><code>def get_required_clocks(self) -&gt; List:\n    \"\"\"Generate list required clocks.\n\n    For AD9680 this will contain [converter clock, sysref requirement SOS]\n\n    Returns:\n        List: List of solver variables, equations, and constants\n    \"\"\"\n    # possible_sysrefs = []\n    # for n in range(1, 10):\n    #     r = self.multiframe_clock / (n * n)\n    #     if r == int(r) and r &gt; 1e6:\n    #         possible_sysrefs.append(r)\n    # self.config = {\"sysref\": self.model.sos1(possible_sysrefs)}\n\n    self.config = {}\n    self.config[\"lmfc_divisor_sysref\"] = self._convert_input(\n        self._lmfc_sys_divisor,\n        default=self._lmfc_sys_divisor[-1],\n        name=\"AD9680_lmfc_divisor_sysref\",\n    )\n\n    self.config[\"lmfc_divisor_sysref_squared\"] = self._add_intermediate(\n        self.config[\"lmfc_divisor_sysref\"] * self.config[\"lmfc_divisor_sysref\"]\n    )\n    self.config[\"sysref\"] = self._add_intermediate(\n        self.multiframe_clock / self.config[\"lmfc_divisor_sysref_squared\"]\n    )\n\n    # Objectives\n    # self.model.Obj(self.config[\"sysref\"])  # This breaks many searches\n\n    return [self.converter_clock, self.config[\"sysref\"]]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9144.ad9144","title":"<code>ad9144</code>","text":"<p>               Bases: <code>ad9144_bf</code></p> <p>AD9144 high speed DAC model.</p> <p>This model supports both direct clock configurations and on-board generation</p> <p>Clocking: AD9144 has directly clocked DAC that have optional input dividers. The sample rate can be determined as follows:</p> <pre><code>baseband_sample_rate = (input_clock / input_clock_divider) / datapath_decimation\n</code></pre> Source code in <code>adijif/converters/ad9144.py</code> <pre><code>class ad9144(ad9144_bf):\n    \"\"\"AD9144 high speed DAC model.\n\n    This model supports both direct clock configurations and on-board\n    generation\n\n    Clocking: AD9144 has directly clocked DAC that have optional input dividers.\n    The sample rate can be determined as follows:\n\n        baseband_sample_rate = (input_clock / input_clock_divider) / datapath_decimation\n    \"\"\"\n\n    name = \"AD9144\"\n    converter_type = \"DAC\"\n\n    # JESD parameters\n    _jesd_params_to_skip_check = [\"DualLink\", \"K\"]\n    DualLink = False\n    available_jesd_modes = [\"jesd204b\"]\n    K_available = [16, 32]\n    _K = 32  # Valid for all cases pg 31 of datasheet\n    L_available = [1, 2, 4, 8]\n    M_available = [1, 2, 4, 4]\n    N_available = [*range(7, 16 + 1)]\n    Np_available = [8, 16]\n    F_available = [1, 2, 4, 8, 16]\n    CS_available = [0, 1, 2, 3]\n    CF_available = [0]\n    S_available = [1, 2]\n\n    # Clock constraints\n    clocking_option_available = [\"integrated_pll\", \"direct\"]\n    _clocking_option = \"direct\"\n\n    converter_clock_min = 420e6  # checked by dac\n    converter_clock_max = 2.8e9  # checked by dac\n\n    bit_clock_min_available = {\"jesd204b\": 1.44e9}  # checked by jesd\n    bit_clock_max_available = {\"jesd204b\": 12.4e9}  # checked by jesd\n\n    sample_clock_min = 1.44e9 / 40  # checked by jesd\n    sample_clock_max = 1.06e9  # checked by jesd\n\n    interpolation_available = [1, 2, 4, 8]\n    _interpolation = 1\n\n    quick_configuration_modes = {\"jesd204b\": quick_configuration_modes}\n\n    # Input clock requirements\n    input_clock_divider_available = [\n        1,\n        2,\n        4,\n        8,\n        16,\n    ]  # only used with integrated PLL for now\n\n    # Integrated PLL limits\n    pfd_min = 35e6\n    pfd_max = 80e6\n\n    # With integrated PLL\n    input_clock_min = 35e6\n    input_clock_max = 1e9\n\n    def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n        \"\"\"Extract configurations from solver results.\n\n        Collect internal converter configuration and output clock definitions\n        leading to connected devices (clock chips, FPGAs)\n\n        Args:\n            solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n        Returns:\n            Dict: Dictionary of clocking rates and dividers for configuration\n        \"\"\"\n        config: Dict = {\n            \"clocking_option\": self.clocking_option,\n            \"interpolation\": self._interpolation,\n        }\n        if self.clocking_option == \"direct\":\n            return config\n\n        if self.solver == \"CPLEX\":\n            if solution:\n                self.solution = solution\n            config.update(\n                {\n                    \"BCount\": self._get_val(self.config[\"BCount\"]),\n                    \"ref_div_factor\": self._get_val(self.config[\"ref_div_factor\"]),\n                    \"lo_div_mode\": np.log2(\n                        self._get_val(self.config[\"lo_div_mode_p2\"])\n                    ),\n                }\n            )\n        return config\n\n    def get_required_clock_names(self) -&gt; List[str]:\n        \"\"\"Get list of strings of names of requested clocks.\n\n        This list of names is for the clocks defined by get_required_clocks\n\n        Returns:\n            List[str]: List of strings of clock names in order\n        \"\"\"\n        clk = (\n            \"ad9144_dac_clock\" if self.clocking_option == \"direct\" else \"ad9144_pll_ref\"\n        )\n        return [clk, \"ad9144_sysref\"]\n\n    def _check_valid_internal_configuration(self) -&gt; None:\n        mode = self._check_valid_jesd_mode()\n        # cfg = self.quick_configuration_modes[self.jesd_class][mode]\n\n        if mode in [\"0\", \"4\", \"9\"]:\n            assert self.K == 32, \"K must be 32 for JESD mode 0, 4, or 9\"\n\n    def _pll_config(self) -&gt; Dict:\n        dac_clk = self.interpolation * self.sample_clock\n        self.config[\"dac_clk\"] = self._convert_input(dac_clk, \"dac_clk\")\n\n        self.config[\"BCount\"] = self._convert_input([*range(6, 127 + 1)], name=\"BCount\")\n\n        # Datasheet says refclk div can support 32 but tables do not reflect this and\n        # a div of 32 would put you under supported range\n\n        if self.solver == \"gekko\":\n            self.config[\"ref_div_factor\"] = self.model.sos1(\n                self.input_clock_divider_available\n            )\n            # self.config[\"ref_div_factor_i\"] = self.model.Var(\n            #     integer=True, lb=0, ub=4, value=4\n            # )\n            # self.config[\"ref_div_factor\"] = self.model.Intermediate(\n            #     2 ** (self.config[\"ref_div_factor_i\"])\n            # )\n\n            self.config[\"ref_clk\"] = self.model.Var(\n                integer=False, lb=35e6, ub=1e9, value=35e6\n            )\n        elif self.solver == \"CPLEX\":\n            self.config[\"ref_div_factor\"] = self._convert_input(\n                self.input_clock_divider_available, \"ref_div_factor\"\n            )\n\n            self.config[\"ref_clk\"] = (\n                self.config[\"dac_clk\"]\n                * self.config[\"ref_div_factor\"]\n                / self.config[\"BCount\"]\n                / 2\n            )\n\n        if dac_clk &gt; 2800e6:\n            raise Exception(\"DAC Clock too fast\")\n        elif dac_clk &gt;= 1500e6:\n            self.config[\"lo_div_mode_p2\"] = self._convert_input(\n                2 ** (1 + 1), name=\"lo_div_mode_p2\"\n            )\n        elif dac_clk &gt;= 720e6:\n            self.config[\"lo_div_mode_p2\"] = self._convert_input(\n                2 ** (2 + 1), name=\"lo_div_mode_p2\"\n            )\n        elif dac_clk &gt;= 420e6:\n            self.config[\"lo_div_mode_p2\"] = self._convert_input(\n                2 ** (3 + 1), name=\"lo_div_mode_p2\"\n            )\n        else:\n            raise Exception(\"DAC Clock too slow\")\n\n        self.config[\"vco\"] = self._add_intermediate(\n            self.config[\"dac_clk\"] * self.config[\"lo_div_mode_p2\"]\n        )\n\n        self._add_equation(\n            [\n                self.config[\"ref_div_factor\"] * self.pfd_min &lt; self.config[\"ref_clk\"],\n                self.config[\"ref_div_factor\"] * self.pfd_max &gt; self.config[\"ref_clk\"],\n                self.config[\"ref_clk\"] &gt;= self.input_clock_min,\n                self.config[\"ref_clk\"] &lt;= self.input_clock_max,\n            ]\n        )\n\n        if self.solver == \"gekko\":\n            self._add_equation(\n                [\n                    self.config[\"ref_clk\"] * 2 * self.config[\"BCount\"]\n                    == self.config[\"dac_clk\"] * self.config[\"ref_div_factor\"]\n                ]\n            )\n\n        return self.config[\"ref_clk\"]\n\n    def get_required_clocks(self) -&gt; List:\n        \"\"\"Generate list required clocks.\n\n        For AD9144 this will contain [converter clock, sysref requirement SOS]\n\n        Returns:\n            List: List of dictionaries of solver components\n        \"\"\"\n        self.config = {}\n\n        self.config[\"lmfc_divisor_sysref\"] = self._convert_input(\n            [*range(1, 20 + 1)], name=\"lmfc_divisor_sysref\"\n        )\n\n        self.config[\"sysref\"] = self._add_intermediate(\n            self.multiframe_clock / (self.config[\"lmfc_divisor_sysref\"])\n        )\n\n        if self.clocking_option == \"direct\":\n            clk = self.sample_clock * self.interpolation\n            # LaneRate = (20 \u00d7 DataRate \u00d7 M)/L\n            assert (\n                self.bit_clock == (20 * self.sample_clock * self.M) / self.L\n            ), \"AD9144 direct clock requirement invalid\"\n        else:\n            # vco = dac_clk * 2^(LO_DIV_MODE + 1)\n            # 6 GHz &lt;= vco &lt;= 12 GHz\n            # BCount = floor( dac_clk/(2 * ref_clk/ref_div ) )\n            # 5 &lt;= BCount &lt;= 127\n            # ref_div = 2^ref_div_mode = 1,2,4,8,16\n            clk = self._pll_config()  # type: ignore\n\n        # Objectives\n        # self.model.Obj(self.config[\"sysref\"])  # This breaks many searches\n        # self.model.Obj(-1*self.config[\"lmfc_divisor_sysref\"])\n\n        return [clk, self.config[\"sysref\"]]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9144.ad9144.get_config","title":"<code>get_config(solution=None)</code>","text":"<p>Extract configurations from solver results.</p> <p>Collect internal converter configuration and output clock definitions leading to connected devices (clock chips, FPGAs)</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>CpoSolveResult</code> <p>CPlex solution. Only needed for CPlex solver</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>Dictionary of clocking rates and dividers for configuration</p> Source code in <code>adijif/converters/ad9144.py</code> <pre><code>def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n    \"\"\"Extract configurations from solver results.\n\n    Collect internal converter configuration and output clock definitions\n    leading to connected devices (clock chips, FPGAs)\n\n    Args:\n        solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n    Returns:\n        Dict: Dictionary of clocking rates and dividers for configuration\n    \"\"\"\n    config: Dict = {\n        \"clocking_option\": self.clocking_option,\n        \"interpolation\": self._interpolation,\n    }\n    if self.clocking_option == \"direct\":\n        return config\n\n    if self.solver == \"CPLEX\":\n        if solution:\n            self.solution = solution\n        config.update(\n            {\n                \"BCount\": self._get_val(self.config[\"BCount\"]),\n                \"ref_div_factor\": self._get_val(self.config[\"ref_div_factor\"]),\n                \"lo_div_mode\": np.log2(\n                    self._get_val(self.config[\"lo_div_mode_p2\"])\n                ),\n            }\n        )\n    return config\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9144.ad9144.get_required_clock_names","title":"<code>get_required_clock_names()</code>","text":"<p>Get list of strings of names of requested clocks.</p> <p>This list of names is for the clocks defined by get_required_clocks</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of strings of clock names in order</p> Source code in <code>adijif/converters/ad9144.py</code> <pre><code>def get_required_clock_names(self) -&gt; List[str]:\n    \"\"\"Get list of strings of names of requested clocks.\n\n    This list of names is for the clocks defined by get_required_clocks\n\n    Returns:\n        List[str]: List of strings of clock names in order\n    \"\"\"\n    clk = (\n        \"ad9144_dac_clock\" if self.clocking_option == \"direct\" else \"ad9144_pll_ref\"\n    )\n    return [clk, \"ad9144_sysref\"]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.ad9144.ad9144.get_required_clocks","title":"<code>get_required_clocks()</code>","text":"<p>Generate list required clocks.</p> <p>For AD9144 this will contain [converter clock, sysref requirement SOS]</p> <p>Returns:</p> Name Type Description <code>List</code> <code>List</code> <p>List of dictionaries of solver components</p> Source code in <code>adijif/converters/ad9144.py</code> <pre><code>def get_required_clocks(self) -&gt; List:\n    \"\"\"Generate list required clocks.\n\n    For AD9144 this will contain [converter clock, sysref requirement SOS]\n\n    Returns:\n        List: List of dictionaries of solver components\n    \"\"\"\n    self.config = {}\n\n    self.config[\"lmfc_divisor_sysref\"] = self._convert_input(\n        [*range(1, 20 + 1)], name=\"lmfc_divisor_sysref\"\n    )\n\n    self.config[\"sysref\"] = self._add_intermediate(\n        self.multiframe_clock / (self.config[\"lmfc_divisor_sysref\"])\n    )\n\n    if self.clocking_option == \"direct\":\n        clk = self.sample_clock * self.interpolation\n        # LaneRate = (20 \u00d7 DataRate \u00d7 M)/L\n        assert (\n            self.bit_clock == (20 * self.sample_clock * self.M) / self.L\n        ), \"AD9144 direct clock requirement invalid\"\n    else:\n        # vco = dac_clk * 2^(LO_DIV_MODE + 1)\n        # 6 GHz &lt;= vco &lt;= 12 GHz\n        # BCount = floor( dac_clk/(2 * ref_clk/ref_div ) )\n        # 5 &lt;= BCount &lt;= 127\n        # ref_div = 2^ref_div_mode = 1,2,4,8,16\n        clk = self._pll_config()  # type: ignore\n\n    # Objectives\n    # self.model.Obj(self.config[\"sysref\"])  # This breaks many searches\n    # self.model.Obj(-1*self.config[\"lmfc_divisor_sysref\"])\n\n    return [clk, self.config[\"sysref\"]]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009","title":"<code>adrv9009</code>","text":"<p>               Bases: <code>adrv9009_core</code></p> <p>ADRV9009 combined transmit and receive model.</p> Source code in <code>adijif/converters/adrv9009.py</code> <pre><code>class adrv9009(adrv9009_core):\n    \"\"\"ADRV9009 combined transmit and receive model.\"\"\"\n\n    name = \"ADRV9009\"\n    solver = \"CPLEX\"\n    _nested = [\"adc\", \"dac\"]\n    converter_type = \"adc_dac\"\n\n    def __init__(\n        self, model: Union[GEKKO, CpoModel] = None, solver: str = None\n    ) -&gt; None:\n        \"\"\"Initialize ADRV9009 clocking model for TX and RX.\n\n        This is a common class used to handle TX and RX constraints\n        together.\n\n        Args:\n            model (GEKKO,CpoModel): Solver model\n            solver (str): Solver name (gekko or CPLEX)\n        \"\"\"\n        if solver:\n            self.solver = solver\n        self.adc = adrv9009_rx(model, solver=self.solver)\n        self.dac = adrv9009_tx(model, solver=self.solver)\n        self.model = model\n\n    def validate_config(self) -&gt; None:\n        \"\"\"Validate device configurations including JESD and clocks of both ADC and DAC.\n\n        This check only is for static configuration that does not include\n        variables which are solved.\n        \"\"\"\n        self.adc.validate_config()\n        self.dac.validate_config()\n\n    def _get_converters(self) -&gt; List[Union[converter, converter]]:\n        return [self.adc, self.dac]\n\n    def get_required_clocks(self) -&gt; List[Dict]:\n        \"\"\"Generate list of required clocks.\n\n        For ADRV9009 this will contain:\n        [device clock requirement SOS, sysref requirement SOS]\n\n        Returns:\n            list[dict]: List of dictionaries of solver variables, equations, and constants\n\n        Raises:\n            Exception: Invalid relation of rates between RX and TX\n            AssertionError: Gekko called\n        \"\"\"\n        # Validate sample rates feasible\n        if self.dac.sample_clock / self.adc.sample_clock not in [\n            1,\n            2,\n            4,\n        ] or self.adc.sample_clock / self.dac.sample_clock not in [1, 2, 4]:\n            raise Exception(\n                \"ADRV9009 RX and TX sample rates must be related by power of 2\"\n            )\n\n        if self.solver == \"gekko\":\n            raise AssertionError\n\n        self.config = {}\n        self.config[\"adc_lmfc_divisor_sysref\"] = self._convert_input(\n            self._lmfc_divisor_sysref_available, name=\"adc_lmfc_divisor_sysref\"\n        )\n        self.config[\"dac_lmfc_divisor_sysref\"] = self._convert_input(\n            self._lmfc_divisor_sysref_available, name=\"dac_lmfc_divisor_sysref\"\n        )\n\n        self.config[\"input_clock_divider_x2\"] = self._convert_input(\n            self.input_clock_dividers_times2_available\n        )\n\n        faster_clk = max([self.adc.sample_clock, self.dac.sample_clock])\n        self.config[\"device_clock\"] = self._add_intermediate(\n            faster_clk / self.config[\"input_clock_divider_x2\"]\n        )\n\n        self.config[\"sysref_adc\"] = self._add_intermediate(\n            self.adc.multiframe_clock / self.config[\"adc_lmfc_divisor_sysref\"]\n        )\n        self.config[\"sysref_dac\"] = self._add_intermediate(\n            self.dac.multiframe_clock / self.config[\"dac_lmfc_divisor_sysref\"]\n        )\n\n        self._add_equation(\n            [\n                self.device_clock_min &lt;= self.config[\"device_clock\"],\n                self.config[\"device_clock\"] &lt;= self.device_clock_max,\n            ]\n        )\n\n        return [\n            self.config[\"device_clock\"],\n            self.config[\"sysref_adc\"],\n            self.config[\"sysref_dac\"],\n        ]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009.__init__","title":"<code>__init__(model=None, solver=None)</code>","text":"<p>Initialize ADRV9009 clocking model for TX and RX.</p> <p>This is a common class used to handle TX and RX constraints together.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>(GEKKO, CpoModel)</code> <p>Solver model</p> <code>None</code> <code>solver</code> <code>str</code> <p>Solver name (gekko or CPLEX)</p> <code>None</code> Source code in <code>adijif/converters/adrv9009.py</code> <pre><code>def __init__(\n    self, model: Union[GEKKO, CpoModel] = None, solver: str = None\n) -&gt; None:\n    \"\"\"Initialize ADRV9009 clocking model for TX and RX.\n\n    This is a common class used to handle TX and RX constraints\n    together.\n\n    Args:\n        model (GEKKO,CpoModel): Solver model\n        solver (str): Solver name (gekko or CPLEX)\n    \"\"\"\n    if solver:\n        self.solver = solver\n    self.adc = adrv9009_rx(model, solver=self.solver)\n    self.dac = adrv9009_tx(model, solver=self.solver)\n    self.model = model\n</code></pre>"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009.get_required_clocks","title":"<code>get_required_clocks()</code>","text":"<p>Generate list of required clocks.</p> <p>For ADRV9009 this will contain: [device clock requirement SOS, sysref requirement SOS]</p> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>list[dict]: List of dictionaries of solver variables, equations, and constants</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Invalid relation of rates between RX and TX</p> <code>AssertionError</code> <p>Gekko called</p> Source code in <code>adijif/converters/adrv9009.py</code> <pre><code>def get_required_clocks(self) -&gt; List[Dict]:\n    \"\"\"Generate list of required clocks.\n\n    For ADRV9009 this will contain:\n    [device clock requirement SOS, sysref requirement SOS]\n\n    Returns:\n        list[dict]: List of dictionaries of solver variables, equations, and constants\n\n    Raises:\n        Exception: Invalid relation of rates between RX and TX\n        AssertionError: Gekko called\n    \"\"\"\n    # Validate sample rates feasible\n    if self.dac.sample_clock / self.adc.sample_clock not in [\n        1,\n        2,\n        4,\n    ] or self.adc.sample_clock / self.dac.sample_clock not in [1, 2, 4]:\n        raise Exception(\n            \"ADRV9009 RX and TX sample rates must be related by power of 2\"\n        )\n\n    if self.solver == \"gekko\":\n        raise AssertionError\n\n    self.config = {}\n    self.config[\"adc_lmfc_divisor_sysref\"] = self._convert_input(\n        self._lmfc_divisor_sysref_available, name=\"adc_lmfc_divisor_sysref\"\n    )\n    self.config[\"dac_lmfc_divisor_sysref\"] = self._convert_input(\n        self._lmfc_divisor_sysref_available, name=\"dac_lmfc_divisor_sysref\"\n    )\n\n    self.config[\"input_clock_divider_x2\"] = self._convert_input(\n        self.input_clock_dividers_times2_available\n    )\n\n    faster_clk = max([self.adc.sample_clock, self.dac.sample_clock])\n    self.config[\"device_clock\"] = self._add_intermediate(\n        faster_clk / self.config[\"input_clock_divider_x2\"]\n    )\n\n    self.config[\"sysref_adc\"] = self._add_intermediate(\n        self.adc.multiframe_clock / self.config[\"adc_lmfc_divisor_sysref\"]\n    )\n    self.config[\"sysref_dac\"] = self._add_intermediate(\n        self.dac.multiframe_clock / self.config[\"dac_lmfc_divisor_sysref\"]\n    )\n\n    self._add_equation(\n        [\n            self.device_clock_min &lt;= self.config[\"device_clock\"],\n            self.config[\"device_clock\"] &lt;= self.device_clock_max,\n        ]\n    )\n\n    return [\n        self.config[\"device_clock\"],\n        self.config[\"sysref_adc\"],\n        self.config[\"sysref_dac\"],\n    ]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009.validate_config","title":"<code>validate_config()</code>","text":"<p>Validate device configurations including JESD and clocks of both ADC and DAC.</p> <p>This check only is for static configuration that does not include variables which are solved.</p> Source code in <code>adijif/converters/adrv9009.py</code> <pre><code>def validate_config(self) -&gt; None:\n    \"\"\"Validate device configurations including JESD and clocks of both ADC and DAC.\n\n    This check only is for static configuration that does not include\n    variables which are solved.\n    \"\"\"\n    self.adc.validate_config()\n    self.dac.validate_config()\n</code></pre>"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_clock_common","title":"<code>adrv9009_clock_common</code>","text":"<p>               Bases: <code>adrv9009_core</code>, <code>adrv9009_bf</code></p> <p>ADRV9009 class managing common singleton (Rx,Tx) methods.</p> Source code in <code>adijif/converters/adrv9009.py</code> <pre><code>class adrv9009_clock_common(adrv9009_core, adrv9009_bf):\n    \"\"\"ADRV9009 class managing common singleton (Rx,Tx) methods.\"\"\"\n\n    def _check_valid_jesd_mode(self) -&gt; None:\n        \"\"\"Verify current JESD configuration for part is valid.\"\"\"\n        _extra_jesd_check(self)\n        return super()._check_valid_jesd_mode()\n\n    def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n        \"\"\"Extract configurations from solver results.\n\n        Collect internal converter configuration and output clock definitions\n        leading to connected devices (clock chips, FPGAs)\n\n        Args:\n            solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n        Returns:\n            Dict: Dictionary of clocking rates and dividers for configuration\n        \"\"\"\n        return {\"clocking_option\": self.clocking_option}\n\n    def _gekko_get_required_clocks(self) -&gt; List[Dict]:\n        possible_sysrefs = []\n        for n in range(1, 20):\n            r = self.multiframe_clock / (n * n)\n            if r == int(r):\n                possible_sysrefs.append(r)\n\n        self.config = {\"sysref\": self.model.sos1(possible_sysrefs)}\n        self.model.Obj(self.config[\"sysref\"])\n\n        possible_device_clocks = []\n        for div in self.input_clock_dividers_available:\n            dev_clock = self.sample_clock / div\n            if self.device_clock_min &lt;= dev_clock &lt;= self.device_clock_max:\n                possible_device_clocks.append(dev_clock)\n\n        self.config[\"device_clock\"] = self.model.sos1(possible_device_clocks)\n        # self.model.Obj(-1 * self.config[\"device_clock\"])\n\n        return [self.config[\"device_clock\"], self.config[\"sysref\"]]\n\n    def get_required_clocks(self) -&gt; List[Dict]:\n        \"\"\"Generate list of required clocks.\n\n        For ADRV9009 this will contain:\n        [device clock requirement SOS, sysref requirement SOS]\n\n        Returns:\n            list[dict]: List of dictionaries of solver variables, equations, and constants\n        \"\"\"\n        if self.solver == \"gekko\":\n            return self._gekko_get_required_clocks()\n        self.config = {}\n        self.config[\"lmfc_divisor_sysref\"] = self._convert_input(\n            [*range(1, 20)], name=\"lmfc_divisor_sysref\"\n        )\n\n        self.config[\"input_clock_divider_x2\"] = self._convert_input(\n            self.input_clock_dividers_times2_available\n        )\n        self.config[\"device_clock\"] = self._add_intermediate(\n            self.sample_clock / self.config[\"input_clock_divider_x2\"]\n        )\n        self.config[\"sysref\"] = self._add_intermediate(\n            self.multiframe_clock\n            / (self.config[\"lmfc_divisor_sysref\"] * self.config[\"lmfc_divisor_sysref\"])\n        )\n\n        self._add_equation(\n            [\n                self.device_clock_min &lt;= self.config[\"device_clock\"],\n                self.config[\"device_clock\"] &lt;= self.device_clock_max,\n            ]\n        )\n\n        return [self.config[\"device_clock\"], self.config[\"sysref\"]]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_clock_common.get_config","title":"<code>get_config(solution=None)</code>","text":"<p>Extract configurations from solver results.</p> <p>Collect internal converter configuration and output clock definitions leading to connected devices (clock chips, FPGAs)</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>CpoSolveResult</code> <p>CPlex solution. Only needed for CPlex solver</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>Dictionary of clocking rates and dividers for configuration</p> Source code in <code>adijif/converters/adrv9009.py</code> <pre><code>def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n    \"\"\"Extract configurations from solver results.\n\n    Collect internal converter configuration and output clock definitions\n    leading to connected devices (clock chips, FPGAs)\n\n    Args:\n        solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n    Returns:\n        Dict: Dictionary of clocking rates and dividers for configuration\n    \"\"\"\n    return {\"clocking_option\": self.clocking_option}\n</code></pre>"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_clock_common.get_required_clocks","title":"<code>get_required_clocks()</code>","text":"<p>Generate list of required clocks.</p> <p>For ADRV9009 this will contain: [device clock requirement SOS, sysref requirement SOS]</p> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>list[dict]: List of dictionaries of solver variables, equations, and constants</p> Source code in <code>adijif/converters/adrv9009.py</code> <pre><code>def get_required_clocks(self) -&gt; List[Dict]:\n    \"\"\"Generate list of required clocks.\n\n    For ADRV9009 this will contain:\n    [device clock requirement SOS, sysref requirement SOS]\n\n    Returns:\n        list[dict]: List of dictionaries of solver variables, equations, and constants\n    \"\"\"\n    if self.solver == \"gekko\":\n        return self._gekko_get_required_clocks()\n    self.config = {}\n    self.config[\"lmfc_divisor_sysref\"] = self._convert_input(\n        [*range(1, 20)], name=\"lmfc_divisor_sysref\"\n    )\n\n    self.config[\"input_clock_divider_x2\"] = self._convert_input(\n        self.input_clock_dividers_times2_available\n    )\n    self.config[\"device_clock\"] = self._add_intermediate(\n        self.sample_clock / self.config[\"input_clock_divider_x2\"]\n    )\n    self.config[\"sysref\"] = self._add_intermediate(\n        self.multiframe_clock\n        / (self.config[\"lmfc_divisor_sysref\"] * self.config[\"lmfc_divisor_sysref\"])\n    )\n\n    self._add_equation(\n        [\n            self.device_clock_min &lt;= self.config[\"device_clock\"],\n            self.config[\"device_clock\"] &lt;= self.device_clock_max,\n        ]\n    )\n\n    return [self.config[\"device_clock\"], self.config[\"sysref\"]]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_core","title":"<code>adrv9009_core</code>","text":"<p>               Bases: <code>converter</code></p> <p>ADRV9009 transceiver clocking model.</p> <p>This model manage the JESD configuration and input clock constraints. External LO constraints are not modeled.</p> <p>Clocking: ADRV9009 uses onboard PLLs to generate the JESD clocks</p> <pre><code>Lane Rate = I/Q Sample Rate * M * Np * (10 / 8) / L\nLane Rate = sample_clock * M * Np * (10 / 8) / L\n</code></pre> Source code in <code>adijif/converters/adrv9009.py</code> <pre><code>class adrv9009_core(converter, metaclass=ABCMeta):\n    \"\"\"ADRV9009 transceiver clocking model.\n\n    This model manage the JESD configuration and input clock constraints.\n    External LO constraints are not modeled.\n\n    Clocking: ADRV9009 uses onboard PLLs to generate the JESD clocks\n\n        Lane Rate = I/Q Sample Rate * M * Np * (10 / 8) / L\n        Lane Rate = sample_clock * M * Np * (10 / 8) / L\n    \"\"\"\n\n    device_clock_available = None  # FIXME\n    device_clock_ranges = None  # FIXME\n\n    name = \"ADRV9009\"\n\n    # JESD configurations\n    quick_configuration_modes = None  # FIXME\n    available_jesd_modes = [\"jesd204b\"]\n    M_available = [1, 2, 4]\n    L_available = [1, 2, 3, 4, 6, 8]\n    N_available = [12, 16]\n    Np_available = [12, 16, 24]\n    F_available = [1, 2, 3, 4, 8]\n    S_available = [1]  # FIXME?\n    K_available = [*np.arange(1, 32 + 1)]\n    CS_available = [0]\n    CF_available = [0]\n\n    # Clock constraints\n    converter_clock_min = 39.063e6 * 8\n    converter_clock_max = 12288e6\n\n    sample_clock_min = 39.063e6\n    sample_clock_max = 491520000\n\n    device_clock_min = 10e6\n    device_clock_max = 1e9\n\n    clocking_option_available = [\"integrated_pll\"]\n    _clocking_option = \"integrated_pll\"\n\n    # Divider ranges\n    input_clock_dividers_available = [1 / 2, 1, 2, 4, 8, 16]\n    input_clock_dividers_times2_available = [1, 2, 4, 8, 16, 32]\n\n    _lmfc_divisor_sysref_available = [*range(1, 20)]\n\n    # Unused\n    max_rx_sample_clock = 250e6\n    max_tx_sample_clock = 500e6\n    max_obs_sample_clock = 500e6\n\n    def _check_valid_internal_configuration(self) -&gt; None:\n        # FIXME\n        pass\n\n    def get_required_clock_names(self) -&gt; List[str]:\n        \"\"\"Get list of strings of names of requested clocks.\n\n        This list of names is for the clocks defined by\n        get_required_clocks\n\n        Returns:\n            List[str]: List of strings of clock names mapped by get_required_clocks\n        \"\"\"\n        return [\"adrv9009_device_clock\", \"adrv9009_sysref\"]\n\n    def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n        \"\"\"Extract configurations from solver results.\n\n        Collect internal converter configuration and output clock definitions\n        leading to connected devices (clock chips, FPGAs)\n\n        Args:\n            solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n        Returns:\n            Dict: Dictionary of clocking rates and dividers for configuration\n        \"\"\"\n        if solution:\n            self.solution = solution\n        return {}\n</code></pre>"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_core.get_config","title":"<code>get_config(solution=None)</code>","text":"<p>Extract configurations from solver results.</p> <p>Collect internal converter configuration and output clock definitions leading to connected devices (clock chips, FPGAs)</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>CpoSolveResult</code> <p>CPlex solution. Only needed for CPlex solver</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>Dictionary of clocking rates and dividers for configuration</p> Source code in <code>adijif/converters/adrv9009.py</code> <pre><code>def get_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n    \"\"\"Extract configurations from solver results.\n\n    Collect internal converter configuration and output clock definitions\n    leading to connected devices (clock chips, FPGAs)\n\n    Args:\n        solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n    Returns:\n        Dict: Dictionary of clocking rates and dividers for configuration\n    \"\"\"\n    if solution:\n        self.solution = solution\n    return {}\n</code></pre>"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_core.get_required_clock_names","title":"<code>get_required_clock_names()</code>","text":"<p>Get list of strings of names of requested clocks.</p> <p>This list of names is for the clocks defined by get_required_clocks</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of strings of clock names mapped by get_required_clocks</p> Source code in <code>adijif/converters/adrv9009.py</code> <pre><code>def get_required_clock_names(self) -&gt; List[str]:\n    \"\"\"Get list of strings of names of requested clocks.\n\n    This list of names is for the clocks defined by\n    get_required_clocks\n\n    Returns:\n        List[str]: List of strings of clock names mapped by get_required_clocks\n    \"\"\"\n    return [\"adrv9009_device_clock\", \"adrv9009_sysref\"]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_rx","title":"<code>adrv9009_rx</code>","text":"<p>               Bases: <code>adc</code>, <code>adrv9009_clock_common</code>, <code>adrv9009_core</code></p> <p>ADRV9009 Receive model.</p> Source code in <code>adijif/converters/adrv9009.py</code> <pre><code>class adrv9009_rx(adc, adrv9009_clock_common, adrv9009_core):\n    \"\"\"ADRV9009 Receive model.\"\"\"\n\n    quick_configuration_modes = {\"jesd204b\": quick_configuration_modes_rx}\n    name = \"ADRV9009_RX\"\n    converter_type = \"adc\"\n\n    # JESD configurations\n    K_available = [*np.arange(1, 32 + 1)]\n    L_available = [1, 2, 4]\n    M_available = [1, 2, 4]\n    N_available = [12, 14, 16, 24]\n    Np_available = [12, 16, 24]\n    F_available = [\n        1,\n        2,\n        3,\n        4,\n        6,\n        8,\n    ]\n    CS_available = [0]\n    CF_available = [0]\n    S_available = [1, 2, 4]\n\n    # Clock constraints\n    bit_clock_min_available = {\"jesd204b\": 3.6864e9}\n    bit_clock_max_available = {\"jesd204b\": 12.288e9}\n\n    \"\"\"\n    ADRV9009 Rx decimation stages.\n                    +-----------+\n        +-----------+ Dec 5 (5) +---------+\n        |           +-----------+         |\n        |                                 |\n        |   +----------+   +----------+   |  +------------+   +--------------+\n    &gt;---+---+ RHB3 (2) +---+ RHB2 (2) +---+--+ RHB1 (1,2) +---+ RFIR (1,2,4) +\n            +----------+   +----------+      +------------+   +--------------+\n\n    \"\"\"\n    _decimation = 8\n    decimation_available = [4, 5, 8, 10, 16, 20, 32, 40]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_rx.bit_clock_max_available","title":"<code>bit_clock_max_available = {'jesd204b': 12288000000.0}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ADRV9009 Rx decimation stages.                 +-----------+     +-----------+ Dec 5 (5) +---------+     |           +-----------+         |     |                                 |     |   +----------+   +----------+   |  +------------+   +--------------+</p> <p>---+---+ RHB3 (2) +---+ RHB2 (2) +---+--+ RHB1 (1,2) +---+ RFIR (1,2,4) +         +----------+   +----------+      +------------+   +--------------+</p>"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_tx","title":"<code>adrv9009_tx</code>","text":"<p>               Bases: <code>dac</code>, <code>adrv9009_clock_common</code>, <code>adrv9009_core</code></p> <p>ADRV9009 Transmit model.</p> Source code in <code>adijif/converters/adrv9009.py</code> <pre><code>class adrv9009_tx(dac, adrv9009_clock_common, adrv9009_core):\n    \"\"\"ADRV9009 Transmit model.\"\"\"\n\n    quick_configuration_modes = {\"jesd204b\": quick_configuration_modes_tx}\n    name = \"ADRV9009_TX\"\n    converter_type = \"dac\"\n\n    # JESD configurations\n    K_available = [*np.arange(1, 32 + 1)]\n    L_available = [1, 2, 4]\n    M_available = [1, 2, 4]\n    N_available = [12, 16]\n    Np_available = [12, 16]\n    F_available = [1, 2, 3, 4, 8]\n    CS_available = [0]\n    CF_available = [0]\n    S_available = [1]\n\n    # Clock constraints\n    bit_clock_min_available = {\"jesd204b\": 2457.6e6}\n    bit_clock_max_available = {\"jesd204b\": 12.288e9}\n\n    \"\"\"\n    ADRV9009 Tx interpolation stages.\n                             +------------+\n        +--------------------+ Int 5  (5) +--------------------+\n        |                    +------------+                    |\n        |                                                      |\n        |   +------------+   +------------+   +------------+   |   +--------------+\n    &lt;---+---+ THB3 (1,2) +---+ THB2 (1,2) +---+ THB1 (1,2) +---+---+ TFIR (1,2,4) +\n            +------------+   +------------+   +------------+       +--------------+\n\n    \"\"\"\n    _interpolation = 8\n    interpolation_available = [1, 2, 4, 5, 8, 10, 16, 20, 32]\n</code></pre>"},{"location":"devs/converters/#adijif.converters.adrv9009.adrv9009_tx.bit_clock_max_available","title":"<code>bit_clock_max_available = {'jesd204b': 12288000000.0}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ADRV9009 Tx interpolation stages.                          +------------+     +--------------------+ Int 5  (5) +--------------------+     |                    +------------+                    |     |                                                      |     |   +------------+   +------------+   +------------+   |   +--------------+ &lt;---+---+ THB3 (1,2) +---+ THB2 (1,2) +---+ THB1 (1,2) +---+---+ TFIR (1,2,4) +         +------------+   +------------+   +------------+       +--------------+</p>"},{"location":"devs/jesd/","title":"Reference","text":"<p>JESD parameterization definitions and helper functions.</p>"},{"location":"devs/jesd/#adijif.jesd.jesd","title":"<code>jesd</code>","text":"<p>JESD interface class to manage JESD notations and definitions.</p> Source code in <code>adijif/jesd.py</code> <pre><code>class jesd(metaclass=ABCMeta):\n    \"\"\"JESD interface class to manage JESD notations and definitions.\"\"\"\n\n    # Lane rate min/max defaulting to JESD spec (parts may differ)\n    bit_clock_min_available = {\"jesd204b\": 312.5e6, \"jesd204c\": 312.5e6}\n    bit_clock_max_available = {\"jesd204b\": 12.5e9, \"jesd204c\": 32e9}\n\n    solver = \"CPLEX\"\n\n    _parameters_to_return = [\n        \"bit_clock\",\n        \"multiframe_clock\",\n        \"sample_clock\",\n        \"F\",\n        \"HD\",\n        \"K\",\n        \"L\",\n        \"M\",\n        \"Np\",\n        \"S\",\n        \"CS\",\n        \"jesd_class\",\n        \"converter_clock\",\n    ]\n\n    _skip_clock_validation = False\n\n    def __init__(self, sample_clock: int, M: int, L: int, Np: int, K: int) -&gt; None:\n        \"\"\"Initialize JESD device through link parameterization.\n\n        Args:\n            sample_clock (int): Human readable string describing the exception.\n            M (int): Number of virtual converters\n            L (int): Number of lanes\n            Np (int): Number of bits per sample\n            K (int): Frames per multiframe\n\n        \"\"\"\n        self.sample_clock = sample_clock\n        self.K = K\n        self.L = L\n        self.M = M\n        self.Np = Np\n        # self.S = S\n\n    def _check_clock_relations(self) -&gt; None:\n        \"\"\"Check clock relations between clocks and JESD parameters.\"\"\"\n        sc = self.sample_clock\n        assert sc == self.frame_clock * self.S, \"sample_clock != S * frame_clock\"\n        if self.jesd_class == \"jesd204b\":\n            assert sc == (self.bit_clock / 10 / self.F) * self.S\n            assert sc == (self.multiframe_clock * self.K * self.S)\n\n    def get_jesd_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n        \"\"\"Extract configurations from solver results.\n\n        Collect JESD related parameters, includes modes and clocks.\n\n        Args:\n            solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n        Returns:\n            Dict: Dictionary of JESD parameters\n        \"\"\"\n        if solution:  # type: ignore\n            self.solution = solution\n        cfg = {p: getattr(self, p) for p in self._parameters_to_return}\n        cfg[\"jesd_mode\"] = self._check_valid_jesd_mode()\n        return cfg\n\n    def validate_clocks(self) -&gt; None:\n        \"\"\"Validate all clocks clock settings are within range.\"\"\"\n        if self._skip_clock_validation:\n            for name in [\"bit\", \"sample\"]:\n                clk = getattr(self, name + \"_clock\")\n                lim = getattr(self, name + \"_clock_max\")\n                assert clk &lt;= lim, (\n                    name + f\" clock too fast for device {clk} (limit: {lim})\"\n                )\n                lim = getattr(self, name + \"_clock_min\")\n                assert clk &gt;= lim, (\n                    name + f\" clock too slow for device {clk} (limit: {lim})\"\n                )\n\n    @property\n    def bit_clock_min(self) -&gt; Union[int, float]:\n        \"\"\"Get bit clock (lane rate) minimum based on JESD mode.\n\n        Returns:\n            int: bit clock in bits per second\n        \"\"\"\n        if isinstance(self.jesd_class, list):\n            return self.bit_clock_min_available[\"jesd204b\"]\n        return self.bit_clock_min_available[self.jesd_class]\n\n    @property\n    def bit_clock_max(self) -&gt; Union[int, float]:\n        \"\"\"Get bit clock (lane rate) maximum based on JESD mode.\n\n        Returns:\n            int: bit clock in bits per second\n        \"\"\"\n        if isinstance(self.jesd_class, list):\n            return self.bit_clock_max_available[\"jesd204b\"]\n        return self.bit_clock_max_available[self.jesd_class]\n\n    _jesd_class = \"jesd204b\"\n\n    @property\n    def jesd_class(self) -&gt; Union[str, List[str]]:\n        \"\"\"Get JESD selected mode. Wil be either jesd204b or jesd204c.\"\"\"\n        return self._jesd_class\n\n    @jesd_class.setter\n    def jesd_class(self, value: str) -&gt; None:\n        \"\"\"Set JESD selected mode and must be either jesd204b or jesd204c.\n\n        Args:\n            value (str): String of JESD class and must be jesd204b or jesd204c\n\n        Raises:\n            Exception: Invalid JESD class selected\n        \"\"\"\n        if value not in self.available_jesd_modes:\n            raise Exception(\n                f\"Invalid JESD class. Valid are: {self.available_jesd_modes}\"\n            )\n        self._jesd_class = value\n        if value == \"jesd204b\":\n            self._encoding = \"8b10b\"\n        else:\n            self._encoding = \"64b66b\"\n\n    def _check_jesd_config(self) -&gt; None:\n        \"\"\"Check if bit clock is within JESD limits based on supported standard.\n\n        Raises:\n            Exception: bit clock (lane rate) too high for JESD mode or invalid\n        \"\"\"\n        if \"jesd204c\" in self.available_jesd_modes:\n            if self.bit_clock &gt; 32e9:\n                raise Exception(\n                    f\"bit clock (lane rate) {self.bit_clock} too high for JESD204C\"\n                )\n        elif \"jesd204b\" in self.available_jesd_modes:\n            if self.bit_clock &gt; 12.5e9:\n                raise Exception(\n                    f\"bit clock (lane rate) {self.bit_clock} too high for JESD204B\"\n                )\n        else:\n            raise Exception(f\"JESD mode(s) {self.available_jesd_modes}\")\n\n    @property\n    @abstractmethod\n    def available_jesd_modes(self) -&gt; List[str]:\n        \"\"\"Available JESD modes supported by device.\n\n        Must be a list of strings\n\n        Raises:\n            NotImplementedError: If child classes do not implement method/property\n        \"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    \"\"\" CS: Control bits per conversion sample 0-3\"\"\"\n    _CS = 0\n    CS_available = [0, 1, 2, 3]\n\n    @property\n    def CS(self) -&gt; Union[int, float]:\n        \"\"\"Get Control bits per conversion sample.\n\n        Returns:\n            int: Control bits per conversion sample\n        \"\"\"\n        return self._CS\n\n    @CS.setter\n    def CS(self, value: int) -&gt; None:\n        \"\"\"Set Control bits per conversion sample.\n\n        Args:\n            value (int): Control bits per conversion sample\n\n        Raises:\n            Exception: CS not an integer or not in range\n        \"\"\"\n        if int(value) != value:\n            raise Exception(\"CS must be an integer\")\n        if value not in self.CS_available:\n            raise Exception(\"CS not in range for device\")\n        self._CS = value\n\n    \"\"\" CF: Control word per frame clock period per link 0-32 \"\"\"\n    _CF = 0\n    CF_available = [0, 1]\n\n    @property\n    def CF(self) -&gt; Union[int, float]:\n        \"\"\"Get Control words per frame clock period per link.\n\n        Returns:\n            int: Control words per frame clock period per link\n        \"\"\"\n        return self._CF\n\n    @CF.setter\n    def CF(self, value: int) -&gt; None:\n        \"\"\"Set Control words per frame clock period per link.\n\n        Args:\n            value (int): Control words per frame clock period per link\n\n        Raises:\n            Exception: CF not an integer or not in range\n        \"\"\"\n        if int(value) != value:\n            raise Exception(\"CF must be an integer\")\n        if value not in self.CF_available:\n            raise Exception(\"CF not in range for device\")\n        self._CF = value\n\n    # Encoding functions\n\n    encodings_n = {\"8b10b\": 8, \"64b66b\": 64}\n    encodings_d = {\"8b10b\": 10, \"64b66b\": 66}\n    _encoding = \"8b10b\"\n\n    @property\n    def encoding(self) -&gt; str:\n        \"\"\"Get JESD FEC encoding.\n\n        Current options are: \"8b10b\", \"64b66b\"\n\n        Returns:\n            str: String of supported encodings.\n        \"\"\"\n        return self._encoding\n\n    @encoding.setter\n    def encoding(self, value: str) -&gt; None:\n        \"\"\"Set JESD FEC encoding.\n\n        Current options are: \"8b10b\", \"64b66b\"\n\n        Args:\n            value (str): String of desired encoding to use\n\n        Raises:\n            Exception: If encoding selected that is not supported\n        \"\"\"\n        if self._check_encoding(value):\n            raise Exception(\n                \"JESD encoding not possible due to available modes: {}\".format(\n                    self.available_jesd_modes\n                )\n            )\n        self._encoding = value\n\n    @property\n    def encoding_d(self) -&gt; Union[int, float]:\n        \"\"\"Get JESD FEC encoding denominator.\n\n        Current options are: 10 or 66\n\n        Returns:\n            int: Denominator of link encoding.\n        \"\"\"\n        return self.encodings_d[self._encoding]\n\n    @property\n    def encoding_n(self) -&gt; Union[int, float]:\n        \"\"\"Get JESD FEC encoding numerator.\n\n        Current options are: 8 or 64\n\n        Returns:\n            int: Numerator of link encoding.\n        \"\"\"\n        return self.encodings_n[self._encoding]\n\n    def _check_encoding(self, encode: str) -&gt; bool:\n        if \"jesd204c\" in self.available_jesd_modes:\n            allowed_encodings = [\"8b10b\", \"64b66b\"]\n        else:\n            allowed_encodings = [\"8b10b\"]\n        return encode not in allowed_encodings\n\n    # SCALERS\n    @property\n    @abstractmethod\n    def K_available(self) -&gt; List[int]:\n        \"\"\"Allowable K settings for device.\n\n        Must be a list ints\n\n        Raises:\n            NotImplementedError: If child classes do not implement method/property\n        \"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    @property\n    @abstractmethod\n    def L_available(self) -&gt; List[int]:\n        \"\"\"Allowable L settings for device.\n\n        Must be a list ints\n\n        Raises:\n            NotImplementedError: If child classes do not implement method/property\n        \"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    @property\n    @abstractmethod\n    def M_available(self) -&gt; List[int]:\n        \"\"\"Allowable M settings for device.\n\n        Must be a list ints\n\n        Raises:\n            NotImplementedError: If child classes do not implement method/property\n        \"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    @property\n    @abstractmethod\n    def N_available(self) -&gt; List[int]:\n        \"\"\"Allowable N settings for device.\n\n        Must be a list ints\n\n        Raises:\n            NotImplementedError: If child classes do not implement method/property\n        \"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    @property\n    @abstractmethod\n    def Np_available(self) -&gt; List[int]:\n        \"\"\"Allowable Np settings for device.\n\n        Must be a list ints\n\n        Raises:\n            NotImplementedError: If child classes do not implement method/property\n        \"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    @property\n    @abstractmethod\n    def F_available(self) -&gt; List[int]:\n        \"\"\"Allowable F settings for device.\n\n        Must be a list ints\n\n        Raises:\n            NotImplementedError: If child classes do not implement method/property\n        \"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    \"\"\" bits\n        Usually:\n            32 for JESD204B\n            64 for JESD204C\n    \"\"\"\n    _data_path_width = 32\n\n    @property\n    def data_path_width(self) -&gt; Union[int, float]:\n        \"\"\"Get JESD data path width in bits.\n\n        Current options are: 32 (204B) and 64 (204C)\n\n        Returns:\n            int: Numerator of link encoding.\n        \"\"\"\n        return self._data_path_width\n\n    @data_path_width.setter\n    def data_path_width(self, value: int) -&gt; None:\n        \"\"\"Set JESD data path width in bits.\n\n        Current options are: 32 (204B) and 64 (204C)\n\n        Args:\n            value (int): Data path width in bits\n\n        Raises:\n            Exception: If DMA width is not an integer\n        \"\"\"\n        if int(value) != value:\n            raise Exception(\"data_path_width must be an integer\")\n        self._data_path_width = value\n\n    \"\"\" HD: High-density mode (Single sample split over multiple lanes)\"\"\"\n    # HD_min = 0\n    # HD_max = 1\n    _HD = 0\n    HD_available = [0, 1]\n\n    @property\n    def HD(self) -&gt; Union[int, float]:\n        \"\"\"Get High density mode.\n\n        Returns:\n            int: High density mode\n        \"\"\"\n        return self._HD\n\n    @HD.setter\n    def HD(self, value: int) -&gt; None:\n        \"\"\"Set High density mode.\n\n        Args:\n            value (int): High density mode\n\n        Raises:\n            Exception: HD not an integer or not in range\n        \"\"\"\n        if int(value) != value:\n            raise Exception(\"HD must be an integer\")\n        if value not in self.HD_available:\n            raise Exception(\"HD not in range for device\")\n        self._HD = value\n\n    \"\"\" K: Frames per multiframe\n        17/F &lt;= K &lt;= 32\n    \"\"\"\n    # K_min = 4\n    # K_max = 32\n    # K_available = [4, 8, 12, 16, 20, 24, 28, 32]\n    _K = 4\n\n    @property\n    def K(self) -&gt; Union[int, float]:\n        \"\"\"Get Frames per multiframe.\n\n        17/F &lt;= K &lt;= 32, is generally a multiple of 2\n\n        Returns:\n            int: Number of frames per multiframe\n        \"\"\"\n        return self._K\n\n    @K.setter\n    def K(self, value: int) -&gt; None:\n        \"\"\"Set Frames per multiframe.\n\n        Args:\n            value (int): Frames per multiframe\n\n        Raises:\n            Exception: K not an integer or not in range\n        \"\"\"\n        if int(value) != value:\n            raise Exception(\"K must be an integer\")\n        if value not in self.K_available:\n            raise Exception(\"K not in range for device\")\n        self._K = value\n\n    @property\n    def D(self) -&gt; Union[int, float]:\n        \"\"\"FIXME.\"\"\"\n        return self._data_path_width * self.encoding_d / self.encoding_n\n\n    \"\"\" S: Samples per converter per frame\"\"\"\n    _S = 1\n\n    @property\n    def S(self) -&gt; Union[int, float]:\n        \"\"\"Get Samples per converter per frame.\n\n        S == F/(M*Np) * encoding_p * L\n\n        Returns:\n            int: Samples per converter per frame\n        \"\"\"\n        return self._S\n\n    @S.setter\n    def S(self, value: int) -&gt; None:\n        \"\"\"Set samples per converter per frame.\n\n        Args:\n            value (int): Samples per converter per frame\n\n        Raises:\n            Exception: S not an integer or not in range\n        \"\"\"\n        if int(value) != value:\n            raise Exception(\"S must be an integer\")\n        if value not in self.L_available:\n            raise Exception(\"S not in range for device\")\n        self._S = value\n\n    \"\"\" L: Lanes per link \"\"\"\n    # L_min = 1\n    # L_max = 8\n    # L_available = [1, 2, 4, 8]\n    _L = 1\n\n    @property\n    def L(self) -&gt; Union[int, float]:\n        \"\"\"Get lanes per link.\n\n        Generally a multiple of 2\n\n        Returns:\n            int: Number of frames per multiframe\n        \"\"\"\n        return self._L\n\n    @L.setter\n    def L(self, value: int) -&gt; None:\n        \"\"\"Set lanes per link.\n\n        Args:\n            value (int): Lanes per link\n\n        Raises:\n            Exception: L not an integer or not in range\n        \"\"\"\n        if int(value) != value:\n            raise Exception(\"L must be an integer\")\n        if value not in self.L_available:\n            raise Exception(\"L not in range for device\")\n        self._L = value\n\n    \"\"\" M: Number of virtual converters \"\"\"\n    # M_min = 1\n    # M_max = 8\n    # M_available = [1, 2, 4, 8, 16, 32]\n    _M = 1\n\n    @property\n    def M(self) -&gt; Union[int, float]:\n        \"\"\"Get number of virtual converters.\n\n        Generally a power of 2\n\n        Returns:\n            int: Number of frames per multiframe\n        \"\"\"\n        return self._M\n\n    @M.setter\n    def M(self, value: int) -&gt; None:\n        \"\"\"Set number of virtual converters.\n\n        Args:\n            value (int): Number of virtual converters\n\n        Raises:\n            Exception: M not an integer or not in range\n        \"\"\"\n        if int(value) != value:\n            raise Exception(\"M must be an integer\")\n        if value not in self.M_available:\n            raise Exception(\"M not in range for device\")\n        self._M = value\n\n    \"\"\" N: Number of non-dummy bits per sample \"\"\"\n    # N_min = 12\n    # N_max = 16\n    # N_available = [12, 14, 16]\n    _N = 12\n\n    @property\n    def N(self) -&gt; Union[int, float]:\n        \"\"\"Get number of non-dummy bits per sample.\n\n        Generally a multiple of 2\n\n        Returns:\n            int: Number of non-dummy bits per sample\n        \"\"\"\n        return self._N\n\n    @N.setter\n    def N(self, value: int) -&gt; None:\n        \"\"\"Set number of non-dummy bits per sample.\n\n        Args:\n            value (int): Number of non-dummy bits per sample\n\n        Raises:\n            Exception: N not an integer or not in range\n        \"\"\"\n        if int(value) != value:\n            raise Exception(\"N must be an integer\")\n        if value not in self.N_available:\n            raise Exception(\"N not in range for device\")\n        self._N = value\n\n    \"\"\" Np: Number of bits per sample \"\"\"\n    # Np_min = 12\n    # Np_max = 16\n    # Np_available = [12, 14, 16]\n    _Np = 16\n\n    @property\n    def Np(self) -&gt; Union[int, float]:\n        \"\"\"Get number of bits per sample.\n\n        Generally a multiple of 2\n\n        Returns:\n            int: Number of bits per sample\n        \"\"\"\n        return self._Np\n\n    @Np.setter\n    def Np(self, value: int) -&gt; None:\n        \"\"\"Set number of bits per sample.\n\n        Args:\n            value (int): Number of bits per sample\n\n        Raises:\n            Exception: Np not an integer or not in range\n        \"\"\"\n        if int(value) != value:\n            raise Exception(\"Np must be an integer\")\n        if value not in self.Np_available:\n            raise Exception(\"Np not in range for device\")\n        self._Np = value\n\n    # DERIVED SCALERS\n    \"\"\" F: Octets per frame per link\n        This is read-only since it depends on L,M,Np,S, and encoding\n    \"\"\"\n    # F_min = 1\n    # F_max = 16\n    # F_available = [1, 2, 4, 8, 16]\n    _F = 1\n\n    @property\n    def F(self) -&gt; Union[int, float]:\n        \"\"\"Get octets per frame per link.\n\n        Generally a power of 2\n\n        Returns:\n            int: Number of octets per frame per link\n        \"\"\"\n        return self._F\n\n    @F.setter\n    def F(self, value: int) -&gt; None:\n        \"\"\"Set octets per frame per link.\n\n        Args:\n            value (int): Number of octets per frame per link\n\n        Raises:\n            Exception: F not an integer or not in range\n        \"\"\"\n        if int(value) != value:\n            raise Exception(\"F must be an integer\")\n        if value not in self.F_available:\n            raise Exception(\"F not in range for device\")\n        self._F = value\n\n    # CLOCKS\n    \"\"\" sample_clock: Data rate after decimation stages in Samples/second \"\"\"\n\n    _sample_clock = 122.88e6\n\n    @property\n    def sample_clock(self) -&gt; Union[int, float]:\n        \"\"\"Data rate after decimation stages in Samples/second.\n\n        Returns:\n            int: Data rate in samples per second\n        \"\"\"\n        return self._sample_clock\n\n    @sample_clock.setter\n    def sample_clock(self, value: int) -&gt; None:\n        \"\"\"Data rate after decimation stages in Samples/second.\n\n        Args:\n            value (int): Number of octets per frame per link\n        \"\"\"\n        self._sample_clock = value\n\n    @property\n    def frame_clock(self) -&gt; Union[int, float]:\n        \"\"\"frame_clock in frames per second.\n\n        frame_clock == sample_clock / S\n\n        Returns:\n            int: Data rate in samples per second\n        \"\"\"\n        return self.sample_clock / self.S\n\n    @property\n    def multiframe_clock(self) -&gt; Union[int, float]:\n        \"\"\"multiframe_clock: aka LMFC in frames per multiframe.\n\n        multiframe_clock == frame_clock / K\n\n        Returns:\n            int: Frames per multiframe\n        \"\"\"\n        return self.frame_clock / self.K\n\n    @property\n    def bit_clock(self) -&gt; Union[int, float]:\n        \"\"\"bit_clock: aka line rate aka lane rate.\n\n        bit_clock == (M * S * Np * encoding_d/encoding_n * frame_clock) / L\n\n        Returns:\n            int: Bits per second aka lane rate\n        \"\"\"\n        return (\n            (self.M / self.L)\n            * self.Np\n            * (self.encoding_d / self.encoding_n)\n            * self.sample_clock\n        )\n\n    @bit_clock.setter\n    def bit_clock(self, value: int) -&gt; None:\n        \"\"\"bit_clock: aka line rate aka lane rate.\n\n        bit_clock == (M * S * Np * encoding_d/encoding_n * frame_clock) / L\n\n        Args:\n            value (int): Bits per second aka lane rate\n        \"\"\"\n        # This actually sets sample_clock\n        # frame_clock = bit_clock*L*encoding_n/encoding_d / (M*S*Np)\n        # sample_clock = bit_clock*L*encoding_n/encoding_d / (M*Np)\n        value_cal = (\n            value * self.L * self.encoding_n / self.encoding_d / (self.M * self.Np)\n        )\n        self._sample_clock = value_cal\n\n    @property\n    def device_clock(self) -&gt; Union[int, float]:\n        \"\"\"device_clock is the lane rate over D.\n\n        device_clock == bit_clock / D\n\n        Returns:\n            int: bits per second per device\n        \"\"\"\n        return self.bit_clock / self.D\n</code></pre>"},{"location":"devs/jesd/#adijif.jesd.jesd.CF","title":"<code>CF: Union[int, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Get Control words per frame clock period per link.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Control words per frame clock period per link</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.CS","title":"<code>CS: Union[int, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Get Control bits per conversion sample.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Control bits per conversion sample</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.D","title":"<code>D: Union[int, float]</code>  <code>property</code>","text":"<p>FIXME.</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.F","title":"<code>F: Union[int, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Get octets per frame per link.</p> <p>Generally a power of 2</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Number of octets per frame per link</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.F_available","title":"<code>F_available: List[int]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Allowable F settings for device.</p> <p>Must be a list ints</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If child classes do not implement method/property</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.HD","title":"<code>HD: Union[int, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Get High density mode.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>High density mode</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.K","title":"<code>K: Union[int, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Get Frames per multiframe.</p> <p>17/F &lt;= K &lt;= 32, is generally a multiple of 2</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Number of frames per multiframe</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.K_available","title":"<code>K_available: List[int]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Allowable K settings for device.</p> <p>Must be a list ints</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If child classes do not implement method/property</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.L","title":"<code>L: Union[int, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Get lanes per link.</p> <p>Generally a multiple of 2</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Number of frames per multiframe</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.L_available","title":"<code>L_available: List[int]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Allowable L settings for device.</p> <p>Must be a list ints</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If child classes do not implement method/property</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.M","title":"<code>M: Union[int, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Get number of virtual converters.</p> <p>Generally a power of 2</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Number of frames per multiframe</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.M_available","title":"<code>M_available: List[int]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Allowable M settings for device.</p> <p>Must be a list ints</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If child classes do not implement method/property</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.N","title":"<code>N: Union[int, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Get number of non-dummy bits per sample.</p> <p>Generally a multiple of 2</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Number of non-dummy bits per sample</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.N_available","title":"<code>N_available: List[int]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Allowable N settings for device.</p> <p>Must be a list ints</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If child classes do not implement method/property</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.Np","title":"<code>Np: Union[int, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Get number of bits per sample.</p> <p>Generally a multiple of 2</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Number of bits per sample</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.Np_available","title":"<code>Np_available: List[int]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Allowable Np settings for device.</p> <p>Must be a list ints</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If child classes do not implement method/property</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.S","title":"<code>S: Union[int, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Get Samples per converter per frame.</p> <p>S == F/(M*Np) * encoding_p * L</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Samples per converter per frame</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.available_jesd_modes","title":"<code>available_jesd_modes: List[str]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Available JESD modes supported by device.</p> <p>Must be a list of strings</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If child classes do not implement method/property</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.bit_clock","title":"<code>bit_clock: Union[int, float]</code>  <code>property</code> <code>writable</code>","text":"<p>bit_clock: aka line rate aka lane rate.</p> <p>bit_clock == (M * S * Np * encoding_d/encoding_n * frame_clock) / L</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Bits per second aka lane rate</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.bit_clock_max","title":"<code>bit_clock_max: Union[int, float]</code>  <code>property</code>","text":"<p>Get bit clock (lane rate) maximum based on JESD mode.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>bit clock in bits per second</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.bit_clock_min","title":"<code>bit_clock_min: Union[int, float]</code>  <code>property</code>","text":"<p>Get bit clock (lane rate) minimum based on JESD mode.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>bit clock in bits per second</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.data_path_width","title":"<code>data_path_width: Union[int, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Get JESD data path width in bits.</p> <p>Current options are: 32 (204B) and 64 (204C)</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Numerator of link encoding.</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.device_clock","title":"<code>device_clock: Union[int, float]</code>  <code>property</code>","text":"<p>device_clock is the lane rate over D.</p> <p>device_clock == bit_clock / D</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>bits per second per device</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.encoding","title":"<code>encoding: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get JESD FEC encoding.</p> <p>Current options are: \"8b10b\", \"64b66b\"</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String of supported encodings.</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.encoding_d","title":"<code>encoding_d: Union[int, float]</code>  <code>property</code>","text":"<p>Get JESD FEC encoding denominator.</p> <p>Current options are: 10 or 66</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Denominator of link encoding.</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.encoding_n","title":"<code>encoding_n: Union[int, float]</code>  <code>property</code>","text":"<p>Get JESD FEC encoding numerator.</p> <p>Current options are: 8 or 64</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Numerator of link encoding.</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.frame_clock","title":"<code>frame_clock: Union[int, float]</code>  <code>property</code>","text":"<p>frame_clock in frames per second.</p> <p>frame_clock == sample_clock / S</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Data rate in samples per second</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.jesd_class","title":"<code>jesd_class: Union[str, List[str]]</code>  <code>property</code> <code>writable</code>","text":"<p>Get JESD selected mode. Wil be either jesd204b or jesd204c.</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.multiframe_clock","title":"<code>multiframe_clock: Union[int, float]</code>  <code>property</code>","text":"<p>multiframe_clock: aka LMFC in frames per multiframe.</p> <p>multiframe_clock == frame_clock / K</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Frames per multiframe</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.sample_clock","title":"<code>sample_clock: Union[int, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Data rate after decimation stages in Samples/second.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Data rate in samples per second</p>"},{"location":"devs/jesd/#adijif.jesd.jesd.__init__","title":"<code>__init__(sample_clock, M, L, Np, K)</code>","text":"<p>Initialize JESD device through link parameterization.</p> <p>Parameters:</p> Name Type Description Default <code>sample_clock</code> <code>int</code> <p>Human readable string describing the exception.</p> required <code>M</code> <code>int</code> <p>Number of virtual converters</p> required <code>L</code> <code>int</code> <p>Number of lanes</p> required <code>Np</code> <code>int</code> <p>Number of bits per sample</p> required <code>K</code> <code>int</code> <p>Frames per multiframe</p> required Source code in <code>adijif/jesd.py</code> <pre><code>def __init__(self, sample_clock: int, M: int, L: int, Np: int, K: int) -&gt; None:\n    \"\"\"Initialize JESD device through link parameterization.\n\n    Args:\n        sample_clock (int): Human readable string describing the exception.\n        M (int): Number of virtual converters\n        L (int): Number of lanes\n        Np (int): Number of bits per sample\n        K (int): Frames per multiframe\n\n    \"\"\"\n    self.sample_clock = sample_clock\n    self.K = K\n    self.L = L\n    self.M = M\n    self.Np = Np\n</code></pre>"},{"location":"devs/jesd/#adijif.jesd.jesd.get_jesd_config","title":"<code>get_jesd_config(solution=None)</code>","text":"<p>Extract configurations from solver results.</p> <p>Collect JESD related parameters, includes modes and clocks.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>CpoSolveResult</code> <p>CPlex solution. Only needed for CPlex solver</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>Dictionary of JESD parameters</p> Source code in <code>adijif/jesd.py</code> <pre><code>def get_jesd_config(self, solution: CpoSolveResult = None) -&gt; Dict:\n    \"\"\"Extract configurations from solver results.\n\n    Collect JESD related parameters, includes modes and clocks.\n\n    Args:\n        solution (CpoSolveResult): CPlex solution. Only needed for CPlex solver\n\n    Returns:\n        Dict: Dictionary of JESD parameters\n    \"\"\"\n    if solution:  # type: ignore\n        self.solution = solution\n    cfg = {p: getattr(self, p) for p in self._parameters_to_return}\n    cfg[\"jesd_mode\"] = self._check_valid_jesd_mode()\n    return cfg\n</code></pre>"},{"location":"devs/jesd/#adijif.jesd.jesd.validate_clocks","title":"<code>validate_clocks()</code>","text":"<p>Validate all clocks clock settings are within range.</p> Source code in <code>adijif/jesd.py</code> <pre><code>def validate_clocks(self) -&gt; None:\n    \"\"\"Validate all clocks clock settings are within range.\"\"\"\n    if self._skip_clock_validation:\n        for name in [\"bit\", \"sample\"]:\n            clk = getattr(self, name + \"_clock\")\n            lim = getattr(self, name + \"_clock_max\")\n            assert clk &lt;= lim, (\n                name + f\" clock too fast for device {clk} (limit: {lim})\"\n            )\n            lim = getattr(self, name + \"_clock_min\")\n            assert clk &gt;= lim, (\n                name + f\" clock too slow for device {clk} (limit: {lim})\"\n            )\n</code></pre>"}]}